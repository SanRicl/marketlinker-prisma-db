
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model OperationMessage
 * 
 */
export type OperationMessage = $Result.DefaultSelection<Prisma.$OperationMessagePayload>
/**
 * Model OperationMessageTranslation
 * 
 */
export type OperationMessageTranslation = $Result.DefaultSelection<Prisma.$OperationMessageTranslationPayload>
/**
 * Model InviteCode
 * 
 */
export type InviteCode = $Result.DefaultSelection<Prisma.$InviteCodePayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model ProductColor
 * 
 */
export type ProductColor = $Result.DefaultSelection<Prisma.$ProductColorPayload>
/**
 * Model ProductSize
 * 
 */
export type ProductSize = $Result.DefaultSelection<Prisma.$ProductSizePayload>
/**
 * Model ProductVoltage
 * 
 */
export type ProductVoltage = $Result.DefaultSelection<Prisma.$ProductVoltagePayload>
/**
 * Model ProductFlavor
 * 
 */
export type ProductFlavor = $Result.DefaultSelection<Prisma.$ProductFlavorPayload>
/**
 * Model ProductPower
 * 
 */
export type ProductPower = $Result.DefaultSelection<Prisma.$ProductPowerPayload>
/**
 * Model SaleChannel
 * 
 */
export type SaleChannel = $Result.DefaultSelection<Prisma.$SaleChannelPayload>
/**
 * Model ProductCustomCategory
 * 
 */
export type ProductCustomCategory = $Result.DefaultSelection<Prisma.$ProductCustomCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  BILLING: 'BILLING',
  BASIC: 'BASIC'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.operationMessage`: Exposes CRUD operations for the **OperationMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationMessages
    * const operationMessages = await prisma.operationMessage.findMany()
    * ```
    */
  get operationMessage(): Prisma.OperationMessageDelegate<ExtArgs>;

  /**
   * `prisma.operationMessageTranslation`: Exposes CRUD operations for the **OperationMessageTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationMessageTranslations
    * const operationMessageTranslations = await prisma.operationMessageTranslation.findMany()
    * ```
    */
  get operationMessageTranslation(): Prisma.OperationMessageTranslationDelegate<ExtArgs>;

  /**
   * `prisma.inviteCode`: Exposes CRUD operations for the **InviteCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InviteCodes
    * const inviteCodes = await prisma.inviteCode.findMany()
    * ```
    */
  get inviteCode(): Prisma.InviteCodeDelegate<ExtArgs>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs>;

  /**
   * `prisma.productColor`: Exposes CRUD operations for the **ProductColor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductColors
    * const productColors = await prisma.productColor.findMany()
    * ```
    */
  get productColor(): Prisma.ProductColorDelegate<ExtArgs>;

  /**
   * `prisma.productSize`: Exposes CRUD operations for the **ProductSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductSizes
    * const productSizes = await prisma.productSize.findMany()
    * ```
    */
  get productSize(): Prisma.ProductSizeDelegate<ExtArgs>;

  /**
   * `prisma.productVoltage`: Exposes CRUD operations for the **ProductVoltage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVoltages
    * const productVoltages = await prisma.productVoltage.findMany()
    * ```
    */
  get productVoltage(): Prisma.ProductVoltageDelegate<ExtArgs>;

  /**
   * `prisma.productFlavor`: Exposes CRUD operations for the **ProductFlavor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductFlavors
    * const productFlavors = await prisma.productFlavor.findMany()
    * ```
    */
  get productFlavor(): Prisma.ProductFlavorDelegate<ExtArgs>;

  /**
   * `prisma.productPower`: Exposes CRUD operations for the **ProductPower** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductPowers
    * const productPowers = await prisma.productPower.findMany()
    * ```
    */
  get productPower(): Prisma.ProductPowerDelegate<ExtArgs>;

  /**
   * `prisma.saleChannel`: Exposes CRUD operations for the **SaleChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleChannels
    * const saleChannels = await prisma.saleChannel.findMany()
    * ```
    */
  get saleChannel(): Prisma.SaleChannelDelegate<ExtArgs>;

  /**
   * `prisma.productCustomCategory`: Exposes CRUD operations for the **ProductCustomCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCustomCategories
    * const productCustomCategories = await prisma.productCustomCategory.findMany()
    * ```
    */
  get productCustomCategory(): Prisma.ProductCustomCategoryDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    Profile: 'Profile',
    Member: 'Member',
    Customer: 'Customer',
    OperationMessage: 'OperationMessage',
    OperationMessageTranslation: 'OperationMessageTranslation',
    InviteCode: 'InviteCode',
    ProductCategory: 'ProductCategory',
    ProductColor: 'ProductColor',
    ProductSize: 'ProductSize',
    ProductVoltage: 'ProductVoltage',
    ProductFlavor: 'ProductFlavor',
    ProductPower: 'ProductPower',
    SaleChannel: 'SaleChannel',
    ProductCustomCategory: 'ProductCustomCategory',
    Product: 'Product'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "organization" | "profile" | "member" | "customer" | "operationMessage" | "operationMessageTranslation" | "inviteCode" | "productCategory" | "productColor" | "productSize" | "productVoltage" | "productFlavor" | "productPower" | "saleChannel" | "productCustomCategory" | "product"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      OperationMessage: {
        payload: Prisma.$OperationMessagePayload<ExtArgs>
        fields: Prisma.OperationMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload>
          }
          findFirst: {
            args: Prisma.OperationMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload>
          }
          findMany: {
            args: Prisma.OperationMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload>[]
          }
          create: {
            args: Prisma.OperationMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload>
          }
          createMany: {
            args: Prisma.OperationMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperationMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload>[]
          }
          delete: {
            args: Prisma.OperationMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload>
          }
          update: {
            args: Prisma.OperationMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload>
          }
          deleteMany: {
            args: Prisma.OperationMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperationMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessagePayload>
          }
          aggregate: {
            args: Prisma.OperationMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationMessage>
          }
          groupBy: {
            args: Prisma.OperationMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationMessageCountArgs<ExtArgs>
            result: $Utils.Optional<OperationMessageCountAggregateOutputType> | number
          }
        }
      }
      OperationMessageTranslation: {
        payload: Prisma.$OperationMessageTranslationPayload<ExtArgs>
        fields: Prisma.OperationMessageTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationMessageTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationMessageTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload>
          }
          findFirst: {
            args: Prisma.OperationMessageTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationMessageTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload>
          }
          findMany: {
            args: Prisma.OperationMessageTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload>[]
          }
          create: {
            args: Prisma.OperationMessageTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload>
          }
          createMany: {
            args: Prisma.OperationMessageTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperationMessageTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload>[]
          }
          delete: {
            args: Prisma.OperationMessageTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload>
          }
          update: {
            args: Prisma.OperationMessageTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload>
          }
          deleteMany: {
            args: Prisma.OperationMessageTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationMessageTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OperationMessageTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationMessageTranslationPayload>
          }
          aggregate: {
            args: Prisma.OperationMessageTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationMessageTranslation>
          }
          groupBy: {
            args: Prisma.OperationMessageTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationMessageTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationMessageTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<OperationMessageTranslationCountAggregateOutputType> | number
          }
        }
      }
      InviteCode: {
        payload: Prisma.$InviteCodePayload<ExtArgs>
        fields: Prisma.InviteCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload>
          }
          findFirst: {
            args: Prisma.InviteCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload>
          }
          findMany: {
            args: Prisma.InviteCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload>[]
          }
          create: {
            args: Prisma.InviteCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload>
          }
          createMany: {
            args: Prisma.InviteCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload>[]
          }
          delete: {
            args: Prisma.InviteCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload>
          }
          update: {
            args: Prisma.InviteCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload>
          }
          deleteMany: {
            args: Prisma.InviteCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InviteCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InviteCodePayload>
          }
          aggregate: {
            args: Prisma.InviteCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInviteCode>
          }
          groupBy: {
            args: Prisma.InviteCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteCodeCountArgs<ExtArgs>
            result: $Utils.Optional<InviteCodeCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductColor: {
        payload: Prisma.$ProductColorPayload<ExtArgs>
        fields: Prisma.ProductColorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductColorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductColorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          findFirst: {
            args: Prisma.ProductColorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductColorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          findMany: {
            args: Prisma.ProductColorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>[]
          }
          create: {
            args: Prisma.ProductColorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          createMany: {
            args: Prisma.ProductColorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductColorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>[]
          }
          delete: {
            args: Prisma.ProductColorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          update: {
            args: Prisma.ProductColorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          deleteMany: {
            args: Prisma.ProductColorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductColorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductColorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductColorPayload>
          }
          aggregate: {
            args: Prisma.ProductColorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductColor>
          }
          groupBy: {
            args: Prisma.ProductColorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductColorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductColorCountArgs<ExtArgs>
            result: $Utils.Optional<ProductColorCountAggregateOutputType> | number
          }
        }
      }
      ProductSize: {
        payload: Prisma.$ProductSizePayload<ExtArgs>
        fields: Prisma.ProductSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          findFirst: {
            args: Prisma.ProductSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          findMany: {
            args: Prisma.ProductSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>[]
          }
          create: {
            args: Prisma.ProductSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          createMany: {
            args: Prisma.ProductSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductSizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>[]
          }
          delete: {
            args: Prisma.ProductSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          update: {
            args: Prisma.ProductSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          deleteMany: {
            args: Prisma.ProductSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          aggregate: {
            args: Prisma.ProductSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductSize>
          }
          groupBy: {
            args: Prisma.ProductSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductSizeCountArgs<ExtArgs>
            result: $Utils.Optional<ProductSizeCountAggregateOutputType> | number
          }
        }
      }
      ProductVoltage: {
        payload: Prisma.$ProductVoltagePayload<ExtArgs>
        fields: Prisma.ProductVoltageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVoltageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVoltageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload>
          }
          findFirst: {
            args: Prisma.ProductVoltageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVoltageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload>
          }
          findMany: {
            args: Prisma.ProductVoltageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload>[]
          }
          create: {
            args: Prisma.ProductVoltageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload>
          }
          createMany: {
            args: Prisma.ProductVoltageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVoltageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload>[]
          }
          delete: {
            args: Prisma.ProductVoltageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload>
          }
          update: {
            args: Prisma.ProductVoltageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload>
          }
          deleteMany: {
            args: Prisma.ProductVoltageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVoltageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductVoltageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVoltagePayload>
          }
          aggregate: {
            args: Prisma.ProductVoltageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVoltage>
          }
          groupBy: {
            args: Prisma.ProductVoltageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVoltageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVoltageCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVoltageCountAggregateOutputType> | number
          }
        }
      }
      ProductFlavor: {
        payload: Prisma.$ProductFlavorPayload<ExtArgs>
        fields: Prisma.ProductFlavorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFlavorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFlavorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload>
          }
          findFirst: {
            args: Prisma.ProductFlavorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFlavorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload>
          }
          findMany: {
            args: Prisma.ProductFlavorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload>[]
          }
          create: {
            args: Prisma.ProductFlavorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload>
          }
          createMany: {
            args: Prisma.ProductFlavorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductFlavorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload>[]
          }
          delete: {
            args: Prisma.ProductFlavorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload>
          }
          update: {
            args: Prisma.ProductFlavorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload>
          }
          deleteMany: {
            args: Prisma.ProductFlavorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductFlavorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductFlavorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductFlavorPayload>
          }
          aggregate: {
            args: Prisma.ProductFlavorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductFlavor>
          }
          groupBy: {
            args: Prisma.ProductFlavorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductFlavorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductFlavorCountArgs<ExtArgs>
            result: $Utils.Optional<ProductFlavorCountAggregateOutputType> | number
          }
        }
      }
      ProductPower: {
        payload: Prisma.$ProductPowerPayload<ExtArgs>
        fields: Prisma.ProductPowerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductPowerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductPowerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload>
          }
          findFirst: {
            args: Prisma.ProductPowerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductPowerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload>
          }
          findMany: {
            args: Prisma.ProductPowerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload>[]
          }
          create: {
            args: Prisma.ProductPowerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload>
          }
          createMany: {
            args: Prisma.ProductPowerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductPowerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload>[]
          }
          delete: {
            args: Prisma.ProductPowerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload>
          }
          update: {
            args: Prisma.ProductPowerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload>
          }
          deleteMany: {
            args: Prisma.ProductPowerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductPowerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductPowerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPowerPayload>
          }
          aggregate: {
            args: Prisma.ProductPowerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductPower>
          }
          groupBy: {
            args: Prisma.ProductPowerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductPowerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductPowerCountArgs<ExtArgs>
            result: $Utils.Optional<ProductPowerCountAggregateOutputType> | number
          }
        }
      }
      SaleChannel: {
        payload: Prisma.$SaleChannelPayload<ExtArgs>
        fields: Prisma.SaleChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload>
          }
          findFirst: {
            args: Prisma.SaleChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload>
          }
          findMany: {
            args: Prisma.SaleChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload>[]
          }
          create: {
            args: Prisma.SaleChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload>
          }
          createMany: {
            args: Prisma.SaleChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload>[]
          }
          delete: {
            args: Prisma.SaleChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload>
          }
          update: {
            args: Prisma.SaleChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload>
          }
          deleteMany: {
            args: Prisma.SaleChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SaleChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleChannelPayload>
          }
          aggregate: {
            args: Prisma.SaleChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleChannel>
          }
          groupBy: {
            args: Prisma.SaleChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleChannelCountArgs<ExtArgs>
            result: $Utils.Optional<SaleChannelCountAggregateOutputType> | number
          }
        }
      }
      ProductCustomCategory: {
        payload: Prisma.$ProductCustomCategoryPayload<ExtArgs>
        fields: Prisma.ProductCustomCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCustomCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCustomCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCustomCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCustomCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCustomCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCustomCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCustomCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCustomCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCustomCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload>
          }
          update: {
            args: Prisma.ProductCustomCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCustomCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCustomCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCustomCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCustomCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCustomCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCustomCategory>
          }
          groupBy: {
            args: Prisma.ProductCustomCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCustomCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCustomCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCustomCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    user_organizations: number
    teams: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_organizations?: boolean | UserCountOutputTypeCountUser_organizationsArgs
    teams?: boolean | UserCountOutputTypeCountTeamsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    members: number
    customer: number
    invite_code: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
    customer?: boolean | OrganizationCountOutputTypeCountCustomerArgs
    invite_code?: boolean | OrganizationCountOutputTypeCountInvite_codeArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvite_codeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteCodeWhereInput
  }


  /**
   * Count Type OperationMessageCountOutputType
   */

  export type OperationMessageCountOutputType = {
    operation_message_translations: number
  }

  export type OperationMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operation_message_translations?: boolean | OperationMessageCountOutputTypeCountOperation_message_translationsArgs
  }

  // Custom InputTypes
  /**
   * OperationMessageCountOutputType without action
   */
  export type OperationMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageCountOutputType
     */
    select?: OperationMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperationMessageCountOutputType without action
   */
  export type OperationMessageCountOutputTypeCountOperation_message_translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationMessageTranslationWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    product: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductCategoryCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductColorCountOutputType
   */

  export type ProductColorCountOutputType = {
    product: number
  }

  export type ProductColorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductColorCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductColorCountOutputType without action
   */
  export type ProductColorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColorCountOutputType
     */
    select?: ProductColorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductColorCountOutputType without action
   */
  export type ProductColorCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductSizeCountOutputType
   */

  export type ProductSizeCountOutputType = {
    product: number
  }

  export type ProductSizeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductSizeCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductSizeCountOutputType without action
   */
  export type ProductSizeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSizeCountOutputType
     */
    select?: ProductSizeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductSizeCountOutputType without action
   */
  export type ProductSizeCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductVoltageCountOutputType
   */

  export type ProductVoltageCountOutputType = {
    product: number
  }

  export type ProductVoltageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductVoltageCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductVoltageCountOutputType without action
   */
  export type ProductVoltageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltageCountOutputType
     */
    select?: ProductVoltageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductVoltageCountOutputType without action
   */
  export type ProductVoltageCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductFlavorCountOutputType
   */

  export type ProductFlavorCountOutputType = {
    product: number
  }

  export type ProductFlavorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductFlavorCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductFlavorCountOutputType without action
   */
  export type ProductFlavorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavorCountOutputType
     */
    select?: ProductFlavorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductFlavorCountOutputType without action
   */
  export type ProductFlavorCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductPowerCountOutputType
   */

  export type ProductPowerCountOutputType = {
    product: number
  }

  export type ProductPowerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductPowerCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductPowerCountOutputType without action
   */
  export type ProductPowerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPowerCountOutputType
     */
    select?: ProductPowerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductPowerCountOutputType without action
   */
  export type ProductPowerCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCustomCategoryCountOutputType
   */

  export type ProductCustomCategoryCountOutputType = {
    product: number
  }

  export type ProductCustomCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductCustomCategoryCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * ProductCustomCategoryCountOutputType without action
   */
  export type ProductCustomCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategoryCountOutputType
     */
    select?: ProductCustomCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCustomCategoryCountOutputType without action
   */
  export type ProductCustomCategoryCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    sales_channels: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales_channels?: boolean | ProductCountOutputTypeCountSales_channelsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSales_channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleChannelWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    gender: string | null
    phone: string | null
    active: boolean | null
    visitor: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    gender: string | null
    phone: string | null
    active: boolean | null
    visitor: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    first_name: number
    last_name: number
    gender: number
    phone: number
    active: number
    visitor: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    gender?: true
    phone?: true
    active?: true
    visitor?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    gender?: true
    phone?: true
    active?: true
    visitor?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    gender?: true
    phone?: true
    active?: true
    visitor?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender: string | null
    phone: string | null
    active: boolean
    visitor: boolean | null
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    gender?: boolean
    phone?: boolean
    active?: boolean
    visitor?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_organizations?: boolean | User$user_organizationsArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    gender?: boolean
    phone?: boolean
    active?: boolean
    visitor?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    gender?: boolean
    phone?: boolean
    active?: boolean
    visitor?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_organizations?: boolean | User$user_organizationsArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      user_organizations: Prisma.$OrganizationPayload<ExtArgs>[]
      teams: Prisma.$MemberPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      first_name: string
      last_name: string
      gender: string | null
      phone: string | null
      active: boolean
      visitor: boolean | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_organizations<T extends User$user_organizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$user_organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany"> | Null>
    teams<T extends User$teamsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly first_name: FieldRef<"User", 'String'>
    readonly last_name: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly visitor: FieldRef<"User", 'Boolean'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.user_organizations
   */
  export type User$user_organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    cursor?: OrganizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * User.teams
   */
  export type User$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    zip_code: string | null
    active: boolean | null
    business_name: string | null
    address_one: string | null
    address_two: string | null
    fantasy_name: string | null
    email: string | null
    phone_number: string | null
    website: string | null
    registration_number: string | null
    slug: string | null
    owner_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    zip_code: string | null
    active: boolean | null
    business_name: string | null
    address_one: string | null
    address_two: string | null
    fantasy_name: string | null
    email: string | null
    phone_number: string | null
    website: string | null
    registration_number: string | null
    slug: string | null
    owner_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    zip_code: number
    active: number
    business_name: number
    address_one: number
    address_two: number
    fantasy_name: number
    email: number
    phone_number: number
    website: number
    registration_number: number
    slug: number
    owner_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    zip_code?: true
    active?: true
    business_name?: true
    address_one?: true
    address_two?: true
    fantasy_name?: true
    email?: true
    phone_number?: true
    website?: true
    registration_number?: true
    slug?: true
    owner_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    zip_code?: true
    active?: true
    business_name?: true
    address_one?: true
    address_two?: true
    fantasy_name?: true
    email?: true
    phone_number?: true
    website?: true
    registration_number?: true
    slug?: true
    owner_id?: true
    created_at?: true
    updated_at?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    zip_code?: true
    active?: true
    business_name?: true
    address_one?: true
    address_two?: true
    fantasy_name?: true
    email?: true
    phone_number?: true
    website?: true
    registration_number?: true
    slug?: true
    owner_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    zip_code: string | null
    active: boolean
    business_name: string
    address_one: string | null
    address_two: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website: string | null
    registration_number: string
    slug: string
    owner_id: string
    created_at: Date
    updated_at: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zip_code?: boolean
    active?: boolean
    business_name?: boolean
    address_one?: boolean
    address_two?: boolean
    fantasy_name?: boolean
    email?: boolean
    phone_number?: boolean
    website?: boolean
    registration_number?: boolean
    slug?: boolean
    owner_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Organization$membersArgs<ExtArgs>
    customer?: boolean | Organization$customerArgs<ExtArgs>
    invite_code?: boolean | Organization$invite_codeArgs<ExtArgs>
    profile?: boolean | Organization$profileArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    zip_code?: boolean
    active?: boolean
    business_name?: boolean
    address_one?: boolean
    address_two?: boolean
    fantasy_name?: boolean
    email?: boolean
    phone_number?: boolean
    website?: boolean
    registration_number?: boolean
    slug?: boolean
    owner_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    zip_code?: boolean
    active?: boolean
    business_name?: boolean
    address_one?: boolean
    address_two?: boolean
    fantasy_name?: boolean
    email?: boolean
    phone_number?: boolean
    website?: boolean
    registration_number?: boolean
    slug?: boolean
    owner_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Organization$membersArgs<ExtArgs>
    customer?: boolean | Organization$customerArgs<ExtArgs>
    invite_code?: boolean | Organization$invite_codeArgs<ExtArgs>
    profile?: boolean | Organization$profileArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$MemberPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs>[]
      invite_code: Prisma.$InviteCodePayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      zip_code: string | null
      active: boolean
      business_name: string
      address_one: string | null
      address_two: string | null
      fantasy_name: string
      email: string
      phone_number: string
      website: string | null
      registration_number: string
      slug: string
      owner_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany"> | Null>
    customer<T extends Organization$customerArgs<ExtArgs> = {}>(args?: Subset<T, Organization$customerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany"> | Null>
    invite_code<T extends Organization$invite_codeArgs<ExtArgs> = {}>(args?: Subset<T, Organization$invite_codeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends Organization$profileArgs<ExtArgs> = {}>(args?: Subset<T, Organization$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly zip_code: FieldRef<"Organization", 'String'>
    readonly active: FieldRef<"Organization", 'Boolean'>
    readonly business_name: FieldRef<"Organization", 'String'>
    readonly address_one: FieldRef<"Organization", 'String'>
    readonly address_two: FieldRef<"Organization", 'String'>
    readonly fantasy_name: FieldRef<"Organization", 'String'>
    readonly email: FieldRef<"Organization", 'String'>
    readonly phone_number: FieldRef<"Organization", 'String'>
    readonly website: FieldRef<"Organization", 'String'>
    readonly registration_number: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly owner_id: FieldRef<"Organization", 'String'>
    readonly created_at: FieldRef<"Organization", 'DateTime'>
    readonly updated_at: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Organization.customer
   */
  export type Organization$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Organization.invite_code
   */
  export type Organization$invite_codeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    where?: InviteCodeWhereInput
    orderBy?: InviteCodeOrderByWithRelationInput | InviteCodeOrderByWithRelationInput[]
    cursor?: InviteCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteCodeScalarFieldEnum | InviteCodeScalarFieldEnum[]
  }

  /**
   * Organization.profile
   */
  export type Organization$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    profile_avatar: string | null
    profile_cover: string | null
    user_id: string | null
    organization_id: string | null
    username: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    profile_avatar: string | null
    profile_cover: string | null
    user_id: string | null
    organization_id: string | null
    username: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    profile_avatar: number
    profile_cover: number
    user_id: number
    organization_id: number
    username: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    profile_avatar?: true
    profile_cover?: true
    user_id?: true
    organization_id?: true
    username?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    profile_avatar?: true
    profile_cover?: true
    user_id?: true
    organization_id?: true
    username?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    profile_avatar?: true
    profile_cover?: true
    user_id?: true
    organization_id?: true
    username?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    profile_avatar: string | null
    profile_cover: string | null
    user_id: string | null
    organization_id: string | null
    username: string
    description: string | null
    created_at: Date
    updated_at: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_avatar?: boolean
    profile_cover?: boolean
    user_id?: boolean
    organization_id?: boolean
    username?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | Profile$userArgs<ExtArgs>
    organization?: boolean | Profile$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profile_avatar?: boolean
    profile_cover?: boolean
    user_id?: boolean
    organization_id?: boolean
    username?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | Profile$userArgs<ExtArgs>
    organization?: boolean | Profile$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    profile_avatar?: boolean
    profile_cover?: boolean
    user_id?: boolean
    organization_id?: boolean
    username?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Profile$userArgs<ExtArgs>
    organization?: boolean | Profile$organizationArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Profile$userArgs<ExtArgs>
    organization?: boolean | Profile$organizationArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profile_avatar: string | null
      profile_cover: string | null
      user_id: string | null
      organization_id: string | null
      username: string
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Profile$userArgs<ExtArgs> = {}>(args?: Subset<T, Profile$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    organization<T extends Profile$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Profile$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly profile_avatar: FieldRef<"Profile", 'String'>
    readonly profile_cover: FieldRef<"Profile", 'String'>
    readonly user_id: FieldRef<"Profile", 'String'>
    readonly organization_id: FieldRef<"Profile", 'String'>
    readonly username: FieldRef<"Profile", 'String'>
    readonly description: FieldRef<"Profile", 'String'>
    readonly created_at: FieldRef<"Profile", 'DateTime'>
    readonly updated_at: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile.user
   */
  export type Profile$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Profile.organization
   */
  export type Profile$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberMinAggregateOutputType = {
    user_id: string | null
    role: $Enums.Role | null
    organization_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    user_id: string | null
    role: $Enums.Role | null
    organization_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MemberCountAggregateOutputType = {
    user_id: number
    role: number
    organization_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MemberMinAggregateInputType = {
    user_id?: true
    role?: true
    organization_id?: true
    created_at?: true
    updated_at?: true
  }

  export type MemberMaxAggregateInputType = {
    user_id?: true
    role?: true
    organization_id?: true
    created_at?: true
    updated_at?: true
  }

  export type MemberCountAggregateInputType = {
    user_id?: true
    role?: true
    organization_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    user_id: string
    role: $Enums.Role
    organization_id: string
    created_at: Date
    updated_at: Date
    _count: MemberCountAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    user_id?: boolean
    role?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      role: $Enums.Role
      organization_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const memberWithUser_idOnly = await prisma.member.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `user_id`
     * const memberWithUser_idOnly = await prisma.member.createManyAndReturn({ 
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */ 
  interface MemberFieldRefs {
    readonly user_id: FieldRef<"Member", 'String'>
    readonly role: FieldRef<"Member", 'Role'>
    readonly organization_id: FieldRef<"Member", 'String'>
    readonly created_at: FieldRef<"Member", 'DateTime'>
    readonly updated_at: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    second_name: string | null
    whatsapp: string | null
    shop_name: string | null
    address_line_one: string | null
    address_line_two: string | null
    email: string | null
    second_phone: string | null
    vat_rate_id: string | null
    currency_id: string | null
    agent_id: string | null
    active: boolean | null
    organization_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    second_name: string | null
    whatsapp: string | null
    shop_name: string | null
    address_line_one: string | null
    address_line_two: string | null
    email: string | null
    second_phone: string | null
    vat_rate_id: string | null
    currency_id: string | null
    agent_id: string | null
    active: boolean | null
    organization_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    second_name: number
    whatsapp: number
    shop_name: number
    address_line_one: number
    address_line_two: number
    email: number
    second_phone: number
    vat_rate_id: number
    currency_id: number
    agent_id: number
    active: number
    organization_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    second_name?: true
    whatsapp?: true
    shop_name?: true
    address_line_one?: true
    address_line_two?: true
    email?: true
    second_phone?: true
    vat_rate_id?: true
    currency_id?: true
    agent_id?: true
    active?: true
    organization_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    second_name?: true
    whatsapp?: true
    shop_name?: true
    address_line_one?: true
    address_line_two?: true
    email?: true
    second_phone?: true
    vat_rate_id?: true
    currency_id?: true
    agent_id?: true
    active?: true
    organization_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    second_name?: true
    whatsapp?: true
    shop_name?: true
    address_line_one?: true
    address_line_two?: true
    email?: true
    second_phone?: true
    vat_rate_id?: true
    currency_id?: true
    agent_id?: true
    active?: true
    organization_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string | null
    second_name: string | null
    whatsapp: string | null
    shop_name: string
    address_line_one: string | null
    address_line_two: string | null
    email: string
    second_phone: string | null
    vat_rate_id: string
    currency_id: string
    agent_id: string
    active: boolean
    organization_id: string
    created_at: Date
    updated_at: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    second_name?: boolean
    whatsapp?: boolean
    shop_name?: boolean
    address_line_one?: boolean
    address_line_two?: boolean
    email?: boolean
    second_phone?: boolean
    vat_rate_id?: boolean
    currency_id?: boolean
    agent_id?: boolean
    active?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    second_name?: boolean
    whatsapp?: boolean
    shop_name?: boolean
    address_line_one?: boolean
    address_line_two?: boolean
    email?: boolean
    second_phone?: boolean
    vat_rate_id?: boolean
    currency_id?: boolean
    agent_id?: boolean
    active?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    second_name?: boolean
    whatsapp?: boolean
    shop_name?: boolean
    address_line_one?: boolean
    address_line_two?: boolean
    email?: boolean
    second_phone?: boolean
    vat_rate_id?: boolean
    currency_id?: boolean
    agent_id?: boolean
    active?: boolean
    organization_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      second_name: string | null
      whatsapp: string | null
      shop_name: string
      address_line_one: string | null
      address_line_two: string | null
      email: string
      second_phone: string | null
      vat_rate_id: string
      currency_id: string
      agent_id: string
      active: boolean
      organization_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly second_name: FieldRef<"Customer", 'String'>
    readonly whatsapp: FieldRef<"Customer", 'String'>
    readonly shop_name: FieldRef<"Customer", 'String'>
    readonly address_line_one: FieldRef<"Customer", 'String'>
    readonly address_line_two: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly second_phone: FieldRef<"Customer", 'String'>
    readonly vat_rate_id: FieldRef<"Customer", 'String'>
    readonly currency_id: FieldRef<"Customer", 'String'>
    readonly agent_id: FieldRef<"Customer", 'String'>
    readonly active: FieldRef<"Customer", 'Boolean'>
    readonly organization_id: FieldRef<"Customer", 'String'>
    readonly created_at: FieldRef<"Customer", 'DateTime'>
    readonly updated_at: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model OperationMessage
   */

  export type AggregateOperationMessage = {
    _count: OperationMessageCountAggregateOutputType | null
    _min: OperationMessageMinAggregateOutputType | null
    _max: OperationMessageMaxAggregateOutputType | null
  }

  export type OperationMessageMinAggregateOutputType = {
    message: string | null
    type: string | null
    active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    id: string | null
  }

  export type OperationMessageMaxAggregateOutputType = {
    message: string | null
    type: string | null
    active: boolean | null
    created_at: Date | null
    updated_at: Date | null
    id: string | null
  }

  export type OperationMessageCountAggregateOutputType = {
    message: number
    type: number
    active: number
    created_at: number
    updated_at: number
    id: number
    _all: number
  }


  export type OperationMessageMinAggregateInputType = {
    message?: true
    type?: true
    active?: true
    created_at?: true
    updated_at?: true
    id?: true
  }

  export type OperationMessageMaxAggregateInputType = {
    message?: true
    type?: true
    active?: true
    created_at?: true
    updated_at?: true
    id?: true
  }

  export type OperationMessageCountAggregateInputType = {
    message?: true
    type?: true
    active?: true
    created_at?: true
    updated_at?: true
    id?: true
    _all?: true
  }

  export type OperationMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationMessage to aggregate.
     */
    where?: OperationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationMessages to fetch.
     */
    orderBy?: OperationMessageOrderByWithRelationInput | OperationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationMessages
    **/
    _count?: true | OperationMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationMessageMaxAggregateInputType
  }

  export type GetOperationMessageAggregateType<T extends OperationMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationMessage[P]>
      : GetScalarType<T[P], AggregateOperationMessage[P]>
  }




  export type OperationMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationMessageWhereInput
    orderBy?: OperationMessageOrderByWithAggregationInput | OperationMessageOrderByWithAggregationInput[]
    by: OperationMessageScalarFieldEnum[] | OperationMessageScalarFieldEnum
    having?: OperationMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationMessageCountAggregateInputType | true
    _min?: OperationMessageMinAggregateInputType
    _max?: OperationMessageMaxAggregateInputType
  }

  export type OperationMessageGroupByOutputType = {
    message: string
    type: string
    active: boolean
    created_at: Date
    updated_at: Date
    id: string
    _count: OperationMessageCountAggregateOutputType | null
    _min: OperationMessageMinAggregateOutputType | null
    _max: OperationMessageMaxAggregateOutputType | null
  }

  type GetOperationMessageGroupByPayload<T extends OperationMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationMessageGroupByOutputType[P]>
            : GetScalarType<T[P], OperationMessageGroupByOutputType[P]>
        }
      >
    >


  export type OperationMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    message?: boolean
    type?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
    operation_message_translations?: boolean | OperationMessage$operation_message_translationsArgs<ExtArgs>
    _count?: boolean | OperationMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationMessage"]>

  export type OperationMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    message?: boolean
    type?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
  }, ExtArgs["result"]["operationMessage"]>

  export type OperationMessageSelectScalar = {
    message?: boolean
    type?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
    id?: boolean
  }

  export type OperationMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operation_message_translations?: boolean | OperationMessage$operation_message_translationsArgs<ExtArgs>
    _count?: boolean | OperationMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OperationMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OperationMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationMessage"
    objects: {
      operation_message_translations: Prisma.$OperationMessageTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      message: string
      type: string
      active: boolean
      created_at: Date
      updated_at: Date
      id: string
    }, ExtArgs["result"]["operationMessage"]>
    composites: {}
  }

  type OperationMessageGetPayload<S extends boolean | null | undefined | OperationMessageDefaultArgs> = $Result.GetResult<Prisma.$OperationMessagePayload, S>

  type OperationMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationMessageCountAggregateInputType | true
    }

  export interface OperationMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationMessage'], meta: { name: 'OperationMessage' } }
    /**
     * Find zero or one OperationMessage that matches the filter.
     * @param {OperationMessageFindUniqueArgs} args - Arguments to find a OperationMessage
     * @example
     * // Get one OperationMessage
     * const operationMessage = await prisma.operationMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationMessageFindUniqueArgs>(args: SelectSubset<T, OperationMessageFindUniqueArgs<ExtArgs>>): Prisma__OperationMessageClient<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperationMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationMessageFindUniqueOrThrowArgs} args - Arguments to find a OperationMessage
     * @example
     * // Get one OperationMessage
     * const operationMessage = await prisma.operationMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationMessageClient<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperationMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageFindFirstArgs} args - Arguments to find a OperationMessage
     * @example
     * // Get one OperationMessage
     * const operationMessage = await prisma.operationMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationMessageFindFirstArgs>(args?: SelectSubset<T, OperationMessageFindFirstArgs<ExtArgs>>): Prisma__OperationMessageClient<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperationMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageFindFirstOrThrowArgs} args - Arguments to find a OperationMessage
     * @example
     * // Get one OperationMessage
     * const operationMessage = await prisma.operationMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationMessageClient<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperationMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationMessages
     * const operationMessages = await prisma.operationMessage.findMany()
     * 
     * // Get first 10 OperationMessages
     * const operationMessages = await prisma.operationMessage.findMany({ take: 10 })
     * 
     * // Only select the `message`
     * const operationMessageWithMessageOnly = await prisma.operationMessage.findMany({ select: { message: true } })
     * 
     */
    findMany<T extends OperationMessageFindManyArgs>(args?: SelectSubset<T, OperationMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperationMessage.
     * @param {OperationMessageCreateArgs} args - Arguments to create a OperationMessage.
     * @example
     * // Create one OperationMessage
     * const OperationMessage = await prisma.operationMessage.create({
     *   data: {
     *     // ... data to create a OperationMessage
     *   }
     * })
     * 
     */
    create<T extends OperationMessageCreateArgs>(args: SelectSubset<T, OperationMessageCreateArgs<ExtArgs>>): Prisma__OperationMessageClient<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperationMessages.
     * @param {OperationMessageCreateManyArgs} args - Arguments to create many OperationMessages.
     * @example
     * // Create many OperationMessages
     * const operationMessage = await prisma.operationMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationMessageCreateManyArgs>(args?: SelectSubset<T, OperationMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperationMessages and returns the data saved in the database.
     * @param {OperationMessageCreateManyAndReturnArgs} args - Arguments to create many OperationMessages.
     * @example
     * // Create many OperationMessages
     * const operationMessage = await prisma.operationMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperationMessages and only return the `message`
     * const operationMessageWithMessageOnly = await prisma.operationMessage.createManyAndReturn({ 
     *   select: { message: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperationMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, OperationMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OperationMessage.
     * @param {OperationMessageDeleteArgs} args - Arguments to delete one OperationMessage.
     * @example
     * // Delete one OperationMessage
     * const OperationMessage = await prisma.operationMessage.delete({
     *   where: {
     *     // ... filter to delete one OperationMessage
     *   }
     * })
     * 
     */
    delete<T extends OperationMessageDeleteArgs>(args: SelectSubset<T, OperationMessageDeleteArgs<ExtArgs>>): Prisma__OperationMessageClient<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperationMessage.
     * @param {OperationMessageUpdateArgs} args - Arguments to update one OperationMessage.
     * @example
     * // Update one OperationMessage
     * const operationMessage = await prisma.operationMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationMessageUpdateArgs>(args: SelectSubset<T, OperationMessageUpdateArgs<ExtArgs>>): Prisma__OperationMessageClient<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperationMessages.
     * @param {OperationMessageDeleteManyArgs} args - Arguments to filter OperationMessages to delete.
     * @example
     * // Delete a few OperationMessages
     * const { count } = await prisma.operationMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationMessageDeleteManyArgs>(args?: SelectSubset<T, OperationMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationMessages
     * const operationMessage = await prisma.operationMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationMessageUpdateManyArgs>(args: SelectSubset<T, OperationMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationMessage.
     * @param {OperationMessageUpsertArgs} args - Arguments to update or create a OperationMessage.
     * @example
     * // Update or create a OperationMessage
     * const operationMessage = await prisma.operationMessage.upsert({
     *   create: {
     *     // ... data to create a OperationMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationMessage we want to update
     *   }
     * })
     */
    upsert<T extends OperationMessageUpsertArgs>(args: SelectSubset<T, OperationMessageUpsertArgs<ExtArgs>>): Prisma__OperationMessageClient<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OperationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageCountArgs} args - Arguments to filter OperationMessages to count.
     * @example
     * // Count the number of OperationMessages
     * const count = await prisma.operationMessage.count({
     *   where: {
     *     // ... the filter for the OperationMessages we want to count
     *   }
     * })
    **/
    count<T extends OperationMessageCountArgs>(
      args?: Subset<T, OperationMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationMessageAggregateArgs>(args: Subset<T, OperationMessageAggregateArgs>): Prisma.PrismaPromise<GetOperationMessageAggregateType<T>>

    /**
     * Group by OperationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationMessageGroupByArgs['orderBy'] }
        : { orderBy?: OperationMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationMessage model
   */
  readonly fields: OperationMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operation_message_translations<T extends OperationMessage$operation_message_translationsArgs<ExtArgs> = {}>(args?: Subset<T, OperationMessage$operation_message_translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationMessage model
   */ 
  interface OperationMessageFieldRefs {
    readonly message: FieldRef<"OperationMessage", 'String'>
    readonly type: FieldRef<"OperationMessage", 'String'>
    readonly active: FieldRef<"OperationMessage", 'Boolean'>
    readonly created_at: FieldRef<"OperationMessage", 'DateTime'>
    readonly updated_at: FieldRef<"OperationMessage", 'DateTime'>
    readonly id: FieldRef<"OperationMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OperationMessage findUnique
   */
  export type OperationMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessage to fetch.
     */
    where: OperationMessageWhereUniqueInput
  }

  /**
   * OperationMessage findUniqueOrThrow
   */
  export type OperationMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessage to fetch.
     */
    where: OperationMessageWhereUniqueInput
  }

  /**
   * OperationMessage findFirst
   */
  export type OperationMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessage to fetch.
     */
    where?: OperationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationMessages to fetch.
     */
    orderBy?: OperationMessageOrderByWithRelationInput | OperationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationMessages.
     */
    cursor?: OperationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationMessages.
     */
    distinct?: OperationMessageScalarFieldEnum | OperationMessageScalarFieldEnum[]
  }

  /**
   * OperationMessage findFirstOrThrow
   */
  export type OperationMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessage to fetch.
     */
    where?: OperationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationMessages to fetch.
     */
    orderBy?: OperationMessageOrderByWithRelationInput | OperationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationMessages.
     */
    cursor?: OperationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationMessages.
     */
    distinct?: OperationMessageScalarFieldEnum | OperationMessageScalarFieldEnum[]
  }

  /**
   * OperationMessage findMany
   */
  export type OperationMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessages to fetch.
     */
    where?: OperationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationMessages to fetch.
     */
    orderBy?: OperationMessageOrderByWithRelationInput | OperationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationMessages.
     */
    cursor?: OperationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationMessages.
     */
    skip?: number
    distinct?: OperationMessageScalarFieldEnum | OperationMessageScalarFieldEnum[]
  }

  /**
   * OperationMessage create
   */
  export type OperationMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationMessage.
     */
    data: XOR<OperationMessageCreateInput, OperationMessageUncheckedCreateInput>
  }

  /**
   * OperationMessage createMany
   */
  export type OperationMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationMessages.
     */
    data: OperationMessageCreateManyInput | OperationMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationMessage createManyAndReturn
   */
  export type OperationMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OperationMessages.
     */
    data: OperationMessageCreateManyInput | OperationMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationMessage update
   */
  export type OperationMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationMessage.
     */
    data: XOR<OperationMessageUpdateInput, OperationMessageUncheckedUpdateInput>
    /**
     * Choose, which OperationMessage to update.
     */
    where: OperationMessageWhereUniqueInput
  }

  /**
   * OperationMessage updateMany
   */
  export type OperationMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationMessages.
     */
    data: XOR<OperationMessageUpdateManyMutationInput, OperationMessageUncheckedUpdateManyInput>
    /**
     * Filter which OperationMessages to update
     */
    where?: OperationMessageWhereInput
  }

  /**
   * OperationMessage upsert
   */
  export type OperationMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationMessage to update in case it exists.
     */
    where: OperationMessageWhereUniqueInput
    /**
     * In case the OperationMessage found by the `where` argument doesn't exist, create a new OperationMessage with this data.
     */
    create: XOR<OperationMessageCreateInput, OperationMessageUncheckedCreateInput>
    /**
     * In case the OperationMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationMessageUpdateInput, OperationMessageUncheckedUpdateInput>
  }

  /**
   * OperationMessage delete
   */
  export type OperationMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
    /**
     * Filter which OperationMessage to delete.
     */
    where: OperationMessageWhereUniqueInput
  }

  /**
   * OperationMessage deleteMany
   */
  export type OperationMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationMessages to delete
     */
    where?: OperationMessageWhereInput
  }

  /**
   * OperationMessage.operation_message_translations
   */
  export type OperationMessage$operation_message_translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    where?: OperationMessageTranslationWhereInput
    orderBy?: OperationMessageTranslationOrderByWithRelationInput | OperationMessageTranslationOrderByWithRelationInput[]
    cursor?: OperationMessageTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationMessageTranslationScalarFieldEnum | OperationMessageTranslationScalarFieldEnum[]
  }

  /**
   * OperationMessage without action
   */
  export type OperationMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessage
     */
    select?: OperationMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageInclude<ExtArgs> | null
  }


  /**
   * Model OperationMessageTranslation
   */

  export type AggregateOperationMessageTranslation = {
    _count: OperationMessageTranslationCountAggregateOutputType | null
    _min: OperationMessageTranslationMinAggregateOutputType | null
    _max: OperationMessageTranslationMaxAggregateOutputType | null
  }

  export type OperationMessageTranslationMinAggregateOutputType = {
    language_code: string | null
    message: string | null
    created_at: Date | null
    updated_at: Date | null
    operation_message_id: string | null
  }

  export type OperationMessageTranslationMaxAggregateOutputType = {
    language_code: string | null
    message: string | null
    created_at: Date | null
    updated_at: Date | null
    operation_message_id: string | null
  }

  export type OperationMessageTranslationCountAggregateOutputType = {
    language_code: number
    message: number
    created_at: number
    updated_at: number
    operation_message_id: number
    _all: number
  }


  export type OperationMessageTranslationMinAggregateInputType = {
    language_code?: true
    message?: true
    created_at?: true
    updated_at?: true
    operation_message_id?: true
  }

  export type OperationMessageTranslationMaxAggregateInputType = {
    language_code?: true
    message?: true
    created_at?: true
    updated_at?: true
    operation_message_id?: true
  }

  export type OperationMessageTranslationCountAggregateInputType = {
    language_code?: true
    message?: true
    created_at?: true
    updated_at?: true
    operation_message_id?: true
    _all?: true
  }

  export type OperationMessageTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationMessageTranslation to aggregate.
     */
    where?: OperationMessageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationMessageTranslations to fetch.
     */
    orderBy?: OperationMessageTranslationOrderByWithRelationInput | OperationMessageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationMessageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationMessageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationMessageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationMessageTranslations
    **/
    _count?: true | OperationMessageTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationMessageTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationMessageTranslationMaxAggregateInputType
  }

  export type GetOperationMessageTranslationAggregateType<T extends OperationMessageTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationMessageTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationMessageTranslation[P]>
      : GetScalarType<T[P], AggregateOperationMessageTranslation[P]>
  }




  export type OperationMessageTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationMessageTranslationWhereInput
    orderBy?: OperationMessageTranslationOrderByWithAggregationInput | OperationMessageTranslationOrderByWithAggregationInput[]
    by: OperationMessageTranslationScalarFieldEnum[] | OperationMessageTranslationScalarFieldEnum
    having?: OperationMessageTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationMessageTranslationCountAggregateInputType | true
    _min?: OperationMessageTranslationMinAggregateInputType
    _max?: OperationMessageTranslationMaxAggregateInputType
  }

  export type OperationMessageTranslationGroupByOutputType = {
    language_code: string
    message: string
    created_at: Date
    updated_at: Date
    operation_message_id: string
    _count: OperationMessageTranslationCountAggregateOutputType | null
    _min: OperationMessageTranslationMinAggregateOutputType | null
    _max: OperationMessageTranslationMaxAggregateOutputType | null
  }

  type GetOperationMessageTranslationGroupByPayload<T extends OperationMessageTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationMessageTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationMessageTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationMessageTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], OperationMessageTranslationGroupByOutputType[P]>
        }
      >
    >


  export type OperationMessageTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    language_code?: boolean
    message?: boolean
    created_at?: boolean
    updated_at?: boolean
    operation_message_id?: boolean
    operation_message?: boolean | OperationMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationMessageTranslation"]>

  export type OperationMessageTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    language_code?: boolean
    message?: boolean
    created_at?: boolean
    updated_at?: boolean
    operation_message_id?: boolean
    operation_message?: boolean | OperationMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationMessageTranslation"]>

  export type OperationMessageTranslationSelectScalar = {
    language_code?: boolean
    message?: boolean
    created_at?: boolean
    updated_at?: boolean
    operation_message_id?: boolean
  }

  export type OperationMessageTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operation_message?: boolean | OperationMessageDefaultArgs<ExtArgs>
  }
  export type OperationMessageTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operation_message?: boolean | OperationMessageDefaultArgs<ExtArgs>
  }

  export type $OperationMessageTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationMessageTranslation"
    objects: {
      operation_message: Prisma.$OperationMessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      language_code: string
      message: string
      created_at: Date
      updated_at: Date
      operation_message_id: string
    }, ExtArgs["result"]["operationMessageTranslation"]>
    composites: {}
  }

  type OperationMessageTranslationGetPayload<S extends boolean | null | undefined | OperationMessageTranslationDefaultArgs> = $Result.GetResult<Prisma.$OperationMessageTranslationPayload, S>

  type OperationMessageTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OperationMessageTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OperationMessageTranslationCountAggregateInputType | true
    }

  export interface OperationMessageTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationMessageTranslation'], meta: { name: 'OperationMessageTranslation' } }
    /**
     * Find zero or one OperationMessageTranslation that matches the filter.
     * @param {OperationMessageTranslationFindUniqueArgs} args - Arguments to find a OperationMessageTranslation
     * @example
     * // Get one OperationMessageTranslation
     * const operationMessageTranslation = await prisma.operationMessageTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationMessageTranslationFindUniqueArgs>(args: SelectSubset<T, OperationMessageTranslationFindUniqueArgs<ExtArgs>>): Prisma__OperationMessageTranslationClient<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OperationMessageTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OperationMessageTranslationFindUniqueOrThrowArgs} args - Arguments to find a OperationMessageTranslation
     * @example
     * // Get one OperationMessageTranslation
     * const operationMessageTranslation = await prisma.operationMessageTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationMessageTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationMessageTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationMessageTranslationClient<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OperationMessageTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageTranslationFindFirstArgs} args - Arguments to find a OperationMessageTranslation
     * @example
     * // Get one OperationMessageTranslation
     * const operationMessageTranslation = await prisma.operationMessageTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationMessageTranslationFindFirstArgs>(args?: SelectSubset<T, OperationMessageTranslationFindFirstArgs<ExtArgs>>): Prisma__OperationMessageTranslationClient<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OperationMessageTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageTranslationFindFirstOrThrowArgs} args - Arguments to find a OperationMessageTranslation
     * @example
     * // Get one OperationMessageTranslation
     * const operationMessageTranslation = await prisma.operationMessageTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationMessageTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationMessageTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationMessageTranslationClient<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OperationMessageTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationMessageTranslations
     * const operationMessageTranslations = await prisma.operationMessageTranslation.findMany()
     * 
     * // Get first 10 OperationMessageTranslations
     * const operationMessageTranslations = await prisma.operationMessageTranslation.findMany({ take: 10 })
     * 
     * // Only select the `language_code`
     * const operationMessageTranslationWithLanguage_codeOnly = await prisma.operationMessageTranslation.findMany({ select: { language_code: true } })
     * 
     */
    findMany<T extends OperationMessageTranslationFindManyArgs>(args?: SelectSubset<T, OperationMessageTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OperationMessageTranslation.
     * @param {OperationMessageTranslationCreateArgs} args - Arguments to create a OperationMessageTranslation.
     * @example
     * // Create one OperationMessageTranslation
     * const OperationMessageTranslation = await prisma.operationMessageTranslation.create({
     *   data: {
     *     // ... data to create a OperationMessageTranslation
     *   }
     * })
     * 
     */
    create<T extends OperationMessageTranslationCreateArgs>(args: SelectSubset<T, OperationMessageTranslationCreateArgs<ExtArgs>>): Prisma__OperationMessageTranslationClient<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OperationMessageTranslations.
     * @param {OperationMessageTranslationCreateManyArgs} args - Arguments to create many OperationMessageTranslations.
     * @example
     * // Create many OperationMessageTranslations
     * const operationMessageTranslation = await prisma.operationMessageTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationMessageTranslationCreateManyArgs>(args?: SelectSubset<T, OperationMessageTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperationMessageTranslations and returns the data saved in the database.
     * @param {OperationMessageTranslationCreateManyAndReturnArgs} args - Arguments to create many OperationMessageTranslations.
     * @example
     * // Create many OperationMessageTranslations
     * const operationMessageTranslation = await prisma.operationMessageTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperationMessageTranslations and only return the `language_code`
     * const operationMessageTranslationWithLanguage_codeOnly = await prisma.operationMessageTranslation.createManyAndReturn({ 
     *   select: { language_code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperationMessageTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, OperationMessageTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OperationMessageTranslation.
     * @param {OperationMessageTranslationDeleteArgs} args - Arguments to delete one OperationMessageTranslation.
     * @example
     * // Delete one OperationMessageTranslation
     * const OperationMessageTranslation = await prisma.operationMessageTranslation.delete({
     *   where: {
     *     // ... filter to delete one OperationMessageTranslation
     *   }
     * })
     * 
     */
    delete<T extends OperationMessageTranslationDeleteArgs>(args: SelectSubset<T, OperationMessageTranslationDeleteArgs<ExtArgs>>): Prisma__OperationMessageTranslationClient<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OperationMessageTranslation.
     * @param {OperationMessageTranslationUpdateArgs} args - Arguments to update one OperationMessageTranslation.
     * @example
     * // Update one OperationMessageTranslation
     * const operationMessageTranslation = await prisma.operationMessageTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationMessageTranslationUpdateArgs>(args: SelectSubset<T, OperationMessageTranslationUpdateArgs<ExtArgs>>): Prisma__OperationMessageTranslationClient<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OperationMessageTranslations.
     * @param {OperationMessageTranslationDeleteManyArgs} args - Arguments to filter OperationMessageTranslations to delete.
     * @example
     * // Delete a few OperationMessageTranslations
     * const { count } = await prisma.operationMessageTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationMessageTranslationDeleteManyArgs>(args?: SelectSubset<T, OperationMessageTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationMessageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationMessageTranslations
     * const operationMessageTranslation = await prisma.operationMessageTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationMessageTranslationUpdateManyArgs>(args: SelectSubset<T, OperationMessageTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OperationMessageTranslation.
     * @param {OperationMessageTranslationUpsertArgs} args - Arguments to update or create a OperationMessageTranslation.
     * @example
     * // Update or create a OperationMessageTranslation
     * const operationMessageTranslation = await prisma.operationMessageTranslation.upsert({
     *   create: {
     *     // ... data to create a OperationMessageTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationMessageTranslation we want to update
     *   }
     * })
     */
    upsert<T extends OperationMessageTranslationUpsertArgs>(args: SelectSubset<T, OperationMessageTranslationUpsertArgs<ExtArgs>>): Prisma__OperationMessageTranslationClient<$Result.GetResult<Prisma.$OperationMessageTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OperationMessageTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageTranslationCountArgs} args - Arguments to filter OperationMessageTranslations to count.
     * @example
     * // Count the number of OperationMessageTranslations
     * const count = await prisma.operationMessageTranslation.count({
     *   where: {
     *     // ... the filter for the OperationMessageTranslations we want to count
     *   }
     * })
    **/
    count<T extends OperationMessageTranslationCountArgs>(
      args?: Subset<T, OperationMessageTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationMessageTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationMessageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationMessageTranslationAggregateArgs>(args: Subset<T, OperationMessageTranslationAggregateArgs>): Prisma.PrismaPromise<GetOperationMessageTranslationAggregateType<T>>

    /**
     * Group by OperationMessageTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationMessageTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationMessageTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationMessageTranslationGroupByArgs['orderBy'] }
        : { orderBy?: OperationMessageTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationMessageTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationMessageTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationMessageTranslation model
   */
  readonly fields: OperationMessageTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationMessageTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationMessageTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operation_message<T extends OperationMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OperationMessageDefaultArgs<ExtArgs>>): Prisma__OperationMessageClient<$Result.GetResult<Prisma.$OperationMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationMessageTranslation model
   */ 
  interface OperationMessageTranslationFieldRefs {
    readonly language_code: FieldRef<"OperationMessageTranslation", 'String'>
    readonly message: FieldRef<"OperationMessageTranslation", 'String'>
    readonly created_at: FieldRef<"OperationMessageTranslation", 'DateTime'>
    readonly updated_at: FieldRef<"OperationMessageTranslation", 'DateTime'>
    readonly operation_message_id: FieldRef<"OperationMessageTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OperationMessageTranslation findUnique
   */
  export type OperationMessageTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessageTranslation to fetch.
     */
    where: OperationMessageTranslationWhereUniqueInput
  }

  /**
   * OperationMessageTranslation findUniqueOrThrow
   */
  export type OperationMessageTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessageTranslation to fetch.
     */
    where: OperationMessageTranslationWhereUniqueInput
  }

  /**
   * OperationMessageTranslation findFirst
   */
  export type OperationMessageTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessageTranslation to fetch.
     */
    where?: OperationMessageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationMessageTranslations to fetch.
     */
    orderBy?: OperationMessageTranslationOrderByWithRelationInput | OperationMessageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationMessageTranslations.
     */
    cursor?: OperationMessageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationMessageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationMessageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationMessageTranslations.
     */
    distinct?: OperationMessageTranslationScalarFieldEnum | OperationMessageTranslationScalarFieldEnum[]
  }

  /**
   * OperationMessageTranslation findFirstOrThrow
   */
  export type OperationMessageTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessageTranslation to fetch.
     */
    where?: OperationMessageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationMessageTranslations to fetch.
     */
    orderBy?: OperationMessageTranslationOrderByWithRelationInput | OperationMessageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationMessageTranslations.
     */
    cursor?: OperationMessageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationMessageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationMessageTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationMessageTranslations.
     */
    distinct?: OperationMessageTranslationScalarFieldEnum | OperationMessageTranslationScalarFieldEnum[]
  }

  /**
   * OperationMessageTranslation findMany
   */
  export type OperationMessageTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    /**
     * Filter, which OperationMessageTranslations to fetch.
     */
    where?: OperationMessageTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationMessageTranslations to fetch.
     */
    orderBy?: OperationMessageTranslationOrderByWithRelationInput | OperationMessageTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationMessageTranslations.
     */
    cursor?: OperationMessageTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationMessageTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationMessageTranslations.
     */
    skip?: number
    distinct?: OperationMessageTranslationScalarFieldEnum | OperationMessageTranslationScalarFieldEnum[]
  }

  /**
   * OperationMessageTranslation create
   */
  export type OperationMessageTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationMessageTranslation.
     */
    data: XOR<OperationMessageTranslationCreateInput, OperationMessageTranslationUncheckedCreateInput>
  }

  /**
   * OperationMessageTranslation createMany
   */
  export type OperationMessageTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationMessageTranslations.
     */
    data: OperationMessageTranslationCreateManyInput | OperationMessageTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperationMessageTranslation createManyAndReturn
   */
  export type OperationMessageTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OperationMessageTranslations.
     */
    data: OperationMessageTranslationCreateManyInput | OperationMessageTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperationMessageTranslation update
   */
  export type OperationMessageTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationMessageTranslation.
     */
    data: XOR<OperationMessageTranslationUpdateInput, OperationMessageTranslationUncheckedUpdateInput>
    /**
     * Choose, which OperationMessageTranslation to update.
     */
    where: OperationMessageTranslationWhereUniqueInput
  }

  /**
   * OperationMessageTranslation updateMany
   */
  export type OperationMessageTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationMessageTranslations.
     */
    data: XOR<OperationMessageTranslationUpdateManyMutationInput, OperationMessageTranslationUncheckedUpdateManyInput>
    /**
     * Filter which OperationMessageTranslations to update
     */
    where?: OperationMessageTranslationWhereInput
  }

  /**
   * OperationMessageTranslation upsert
   */
  export type OperationMessageTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationMessageTranslation to update in case it exists.
     */
    where: OperationMessageTranslationWhereUniqueInput
    /**
     * In case the OperationMessageTranslation found by the `where` argument doesn't exist, create a new OperationMessageTranslation with this data.
     */
    create: XOR<OperationMessageTranslationCreateInput, OperationMessageTranslationUncheckedCreateInput>
    /**
     * In case the OperationMessageTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationMessageTranslationUpdateInput, OperationMessageTranslationUncheckedUpdateInput>
  }

  /**
   * OperationMessageTranslation delete
   */
  export type OperationMessageTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
    /**
     * Filter which OperationMessageTranslation to delete.
     */
    where: OperationMessageTranslationWhereUniqueInput
  }

  /**
   * OperationMessageTranslation deleteMany
   */
  export type OperationMessageTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationMessageTranslations to delete
     */
    where?: OperationMessageTranslationWhereInput
  }

  /**
   * OperationMessageTranslation without action
   */
  export type OperationMessageTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMessageTranslation
     */
    select?: OperationMessageTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationMessageTranslationInclude<ExtArgs> | null
  }


  /**
   * Model InviteCode
   */

  export type AggregateInviteCode = {
    _count: InviteCodeCountAggregateOutputType | null
    _min: InviteCodeMinAggregateOutputType | null
    _max: InviteCodeMaxAggregateOutputType | null
  }

  export type InviteCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    used: boolean | null
    organization_id: string | null
  }

  export type InviteCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    used: boolean | null
    organization_id: string | null
  }

  export type InviteCodeCountAggregateOutputType = {
    id: number
    code: number
    expires_at: number
    created_at: number
    updated_at: number
    used: number
    organization_id: number
    _all: number
  }


  export type InviteCodeMinAggregateInputType = {
    id?: true
    code?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    used?: true
    organization_id?: true
  }

  export type InviteCodeMaxAggregateInputType = {
    id?: true
    code?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    used?: true
    organization_id?: true
  }

  export type InviteCodeCountAggregateInputType = {
    id?: true
    code?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    used?: true
    organization_id?: true
    _all?: true
  }

  export type InviteCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteCode to aggregate.
     */
    where?: InviteCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteCodes to fetch.
     */
    orderBy?: InviteCodeOrderByWithRelationInput | InviteCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InviteCodes
    **/
    _count?: true | InviteCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteCodeMaxAggregateInputType
  }

  export type GetInviteCodeAggregateType<T extends InviteCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateInviteCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInviteCode[P]>
      : GetScalarType<T[P], AggregateInviteCode[P]>
  }




  export type InviteCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteCodeWhereInput
    orderBy?: InviteCodeOrderByWithAggregationInput | InviteCodeOrderByWithAggregationInput[]
    by: InviteCodeScalarFieldEnum[] | InviteCodeScalarFieldEnum
    having?: InviteCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteCodeCountAggregateInputType | true
    _min?: InviteCodeMinAggregateInputType
    _max?: InviteCodeMaxAggregateInputType
  }

  export type InviteCodeGroupByOutputType = {
    id: string
    code: string
    expires_at: Date | null
    created_at: Date
    updated_at: Date
    used: boolean
    organization_id: string
    _count: InviteCodeCountAggregateOutputType | null
    _min: InviteCodeMinAggregateOutputType | null
    _max: InviteCodeMaxAggregateOutputType | null
  }

  type GetInviteCodeGroupByPayload<T extends InviteCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteCodeGroupByOutputType[P]>
            : GetScalarType<T[P], InviteCodeGroupByOutputType[P]>
        }
      >
    >


  export type InviteCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    used?: boolean
    organization_id?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inviteCode"]>

  export type InviteCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    used?: boolean
    organization_id?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inviteCode"]>

  export type InviteCodeSelectScalar = {
    id?: boolean
    code?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    used?: boolean
    organization_id?: boolean
  }

  export type InviteCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type InviteCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $InviteCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InviteCode"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      expires_at: Date | null
      created_at: Date
      updated_at: Date
      used: boolean
      organization_id: string
    }, ExtArgs["result"]["inviteCode"]>
    composites: {}
  }

  type InviteCodeGetPayload<S extends boolean | null | undefined | InviteCodeDefaultArgs> = $Result.GetResult<Prisma.$InviteCodePayload, S>

  type InviteCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InviteCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InviteCodeCountAggregateInputType | true
    }

  export interface InviteCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InviteCode'], meta: { name: 'InviteCode' } }
    /**
     * Find zero or one InviteCode that matches the filter.
     * @param {InviteCodeFindUniqueArgs} args - Arguments to find a InviteCode
     * @example
     * // Get one InviteCode
     * const inviteCode = await prisma.inviteCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteCodeFindUniqueArgs>(args: SelectSubset<T, InviteCodeFindUniqueArgs<ExtArgs>>): Prisma__InviteCodeClient<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InviteCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InviteCodeFindUniqueOrThrowArgs} args - Arguments to find a InviteCode
     * @example
     * // Get one InviteCode
     * const inviteCode = await prisma.inviteCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteCodeClient<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InviteCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCodeFindFirstArgs} args - Arguments to find a InviteCode
     * @example
     * // Get one InviteCode
     * const inviteCode = await prisma.inviteCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteCodeFindFirstArgs>(args?: SelectSubset<T, InviteCodeFindFirstArgs<ExtArgs>>): Prisma__InviteCodeClient<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InviteCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCodeFindFirstOrThrowArgs} args - Arguments to find a InviteCode
     * @example
     * // Get one InviteCode
     * const inviteCode = await prisma.inviteCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteCodeClient<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InviteCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InviteCodes
     * const inviteCodes = await prisma.inviteCode.findMany()
     * 
     * // Get first 10 InviteCodes
     * const inviteCodes = await prisma.inviteCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteCodeWithIdOnly = await prisma.inviteCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteCodeFindManyArgs>(args?: SelectSubset<T, InviteCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InviteCode.
     * @param {InviteCodeCreateArgs} args - Arguments to create a InviteCode.
     * @example
     * // Create one InviteCode
     * const InviteCode = await prisma.inviteCode.create({
     *   data: {
     *     // ... data to create a InviteCode
     *   }
     * })
     * 
     */
    create<T extends InviteCodeCreateArgs>(args: SelectSubset<T, InviteCodeCreateArgs<ExtArgs>>): Prisma__InviteCodeClient<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InviteCodes.
     * @param {InviteCodeCreateManyArgs} args - Arguments to create many InviteCodes.
     * @example
     * // Create many InviteCodes
     * const inviteCode = await prisma.inviteCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteCodeCreateManyArgs>(args?: SelectSubset<T, InviteCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InviteCodes and returns the data saved in the database.
     * @param {InviteCodeCreateManyAndReturnArgs} args - Arguments to create many InviteCodes.
     * @example
     * // Create many InviteCodes
     * const inviteCode = await prisma.inviteCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InviteCodes and only return the `id`
     * const inviteCodeWithIdOnly = await prisma.inviteCode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InviteCode.
     * @param {InviteCodeDeleteArgs} args - Arguments to delete one InviteCode.
     * @example
     * // Delete one InviteCode
     * const InviteCode = await prisma.inviteCode.delete({
     *   where: {
     *     // ... filter to delete one InviteCode
     *   }
     * })
     * 
     */
    delete<T extends InviteCodeDeleteArgs>(args: SelectSubset<T, InviteCodeDeleteArgs<ExtArgs>>): Prisma__InviteCodeClient<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InviteCode.
     * @param {InviteCodeUpdateArgs} args - Arguments to update one InviteCode.
     * @example
     * // Update one InviteCode
     * const inviteCode = await prisma.inviteCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteCodeUpdateArgs>(args: SelectSubset<T, InviteCodeUpdateArgs<ExtArgs>>): Prisma__InviteCodeClient<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InviteCodes.
     * @param {InviteCodeDeleteManyArgs} args - Arguments to filter InviteCodes to delete.
     * @example
     * // Delete a few InviteCodes
     * const { count } = await prisma.inviteCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteCodeDeleteManyArgs>(args?: SelectSubset<T, InviteCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InviteCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InviteCodes
     * const inviteCode = await prisma.inviteCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteCodeUpdateManyArgs>(args: SelectSubset<T, InviteCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InviteCode.
     * @param {InviteCodeUpsertArgs} args - Arguments to update or create a InviteCode.
     * @example
     * // Update or create a InviteCode
     * const inviteCode = await prisma.inviteCode.upsert({
     *   create: {
     *     // ... data to create a InviteCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InviteCode we want to update
     *   }
     * })
     */
    upsert<T extends InviteCodeUpsertArgs>(args: SelectSubset<T, InviteCodeUpsertArgs<ExtArgs>>): Prisma__InviteCodeClient<$Result.GetResult<Prisma.$InviteCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InviteCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCodeCountArgs} args - Arguments to filter InviteCodes to count.
     * @example
     * // Count the number of InviteCodes
     * const count = await prisma.inviteCode.count({
     *   where: {
     *     // ... the filter for the InviteCodes we want to count
     *   }
     * })
    **/
    count<T extends InviteCodeCountArgs>(
      args?: Subset<T, InviteCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InviteCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteCodeAggregateArgs>(args: Subset<T, InviteCodeAggregateArgs>): Prisma.PrismaPromise<GetInviteCodeAggregateType<T>>

    /**
     * Group by InviteCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteCodeGroupByArgs['orderBy'] }
        : { orderBy?: InviteCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InviteCode model
   */
  readonly fields: InviteCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InviteCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InviteCode model
   */ 
  interface InviteCodeFieldRefs {
    readonly id: FieldRef<"InviteCode", 'String'>
    readonly code: FieldRef<"InviteCode", 'String'>
    readonly expires_at: FieldRef<"InviteCode", 'DateTime'>
    readonly created_at: FieldRef<"InviteCode", 'DateTime'>
    readonly updated_at: FieldRef<"InviteCode", 'DateTime'>
    readonly used: FieldRef<"InviteCode", 'Boolean'>
    readonly organization_id: FieldRef<"InviteCode", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InviteCode findUnique
   */
  export type InviteCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    /**
     * Filter, which InviteCode to fetch.
     */
    where: InviteCodeWhereUniqueInput
  }

  /**
   * InviteCode findUniqueOrThrow
   */
  export type InviteCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    /**
     * Filter, which InviteCode to fetch.
     */
    where: InviteCodeWhereUniqueInput
  }

  /**
   * InviteCode findFirst
   */
  export type InviteCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    /**
     * Filter, which InviteCode to fetch.
     */
    where?: InviteCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteCodes to fetch.
     */
    orderBy?: InviteCodeOrderByWithRelationInput | InviteCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteCodes.
     */
    cursor?: InviteCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteCodes.
     */
    distinct?: InviteCodeScalarFieldEnum | InviteCodeScalarFieldEnum[]
  }

  /**
   * InviteCode findFirstOrThrow
   */
  export type InviteCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    /**
     * Filter, which InviteCode to fetch.
     */
    where?: InviteCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteCodes to fetch.
     */
    orderBy?: InviteCodeOrderByWithRelationInput | InviteCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InviteCodes.
     */
    cursor?: InviteCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InviteCodes.
     */
    distinct?: InviteCodeScalarFieldEnum | InviteCodeScalarFieldEnum[]
  }

  /**
   * InviteCode findMany
   */
  export type InviteCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    /**
     * Filter, which InviteCodes to fetch.
     */
    where?: InviteCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InviteCodes to fetch.
     */
    orderBy?: InviteCodeOrderByWithRelationInput | InviteCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InviteCodes.
     */
    cursor?: InviteCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InviteCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InviteCodes.
     */
    skip?: number
    distinct?: InviteCodeScalarFieldEnum | InviteCodeScalarFieldEnum[]
  }

  /**
   * InviteCode create
   */
  export type InviteCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a InviteCode.
     */
    data: XOR<InviteCodeCreateInput, InviteCodeUncheckedCreateInput>
  }

  /**
   * InviteCode createMany
   */
  export type InviteCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InviteCodes.
     */
    data: InviteCodeCreateManyInput | InviteCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InviteCode createManyAndReturn
   */
  export type InviteCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InviteCodes.
     */
    data: InviteCodeCreateManyInput | InviteCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InviteCode update
   */
  export type InviteCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a InviteCode.
     */
    data: XOR<InviteCodeUpdateInput, InviteCodeUncheckedUpdateInput>
    /**
     * Choose, which InviteCode to update.
     */
    where: InviteCodeWhereUniqueInput
  }

  /**
   * InviteCode updateMany
   */
  export type InviteCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InviteCodes.
     */
    data: XOR<InviteCodeUpdateManyMutationInput, InviteCodeUncheckedUpdateManyInput>
    /**
     * Filter which InviteCodes to update
     */
    where?: InviteCodeWhereInput
  }

  /**
   * InviteCode upsert
   */
  export type InviteCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the InviteCode to update in case it exists.
     */
    where: InviteCodeWhereUniqueInput
    /**
     * In case the InviteCode found by the `where` argument doesn't exist, create a new InviteCode with this data.
     */
    create: XOR<InviteCodeCreateInput, InviteCodeUncheckedCreateInput>
    /**
     * In case the InviteCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteCodeUpdateInput, InviteCodeUncheckedUpdateInput>
  }

  /**
   * InviteCode delete
   */
  export type InviteCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
    /**
     * Filter which InviteCode to delete.
     */
    where: InviteCodeWhereUniqueInput
  }

  /**
   * InviteCode deleteMany
   */
  export type InviteCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InviteCodes to delete
     */
    where?: InviteCodeWhereInput
  }

  /**
   * InviteCode without action
   */
  export type InviteCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InviteCode
     */
    select?: InviteCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteCodeInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    full_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    full_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    name: number
    full_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    id?: true
    name?: true
    full_name?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    full_name?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    name?: true
    full_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    name: string
    full_name: string
    created_at: Date
    updated_at: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    full_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | ProductCategory$productArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    full_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    name?: boolean
    full_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductCategory$productArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      full_name: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductCategory$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */ 
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly full_name: FieldRef<"ProductCategory", 'String'>
    readonly created_at: FieldRef<"ProductCategory", 'DateTime'>
    readonly updated_at: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory.product
   */
  export type ProductCategory$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductColor
   */

  export type AggregateProductColor = {
    _count: ProductColorCountAggregateOutputType | null
    _min: ProductColorMinAggregateOutputType | null
    _max: ProductColorMaxAggregateOutputType | null
  }

  export type ProductColorMinAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductColorMaxAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductColorCountAggregateOutputType = {
    id: number
    attribute_name: number
    attribute_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductColorMinAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductColorMaxAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductColorCountAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductColorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductColor to aggregate.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: ProductColorOrderByWithRelationInput | ProductColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductColors
    **/
    _count?: true | ProductColorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductColorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductColorMaxAggregateInputType
  }

  export type GetProductColorAggregateType<T extends ProductColorAggregateArgs> = {
        [P in keyof T & keyof AggregateProductColor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductColor[P]>
      : GetScalarType<T[P], AggregateProductColor[P]>
  }




  export type ProductColorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductColorWhereInput
    orderBy?: ProductColorOrderByWithAggregationInput | ProductColorOrderByWithAggregationInput[]
    by: ProductColorScalarFieldEnum[] | ProductColorScalarFieldEnum
    having?: ProductColorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductColorCountAggregateInputType | true
    _min?: ProductColorMinAggregateInputType
    _max?: ProductColorMaxAggregateInputType
  }

  export type ProductColorGroupByOutputType = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at: Date
    updated_at: Date
    _count: ProductColorCountAggregateOutputType | null
    _min: ProductColorMinAggregateOutputType | null
    _max: ProductColorMaxAggregateOutputType | null
  }

  type GetProductColorGroupByPayload<T extends ProductColorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductColorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductColorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductColorGroupByOutputType[P]>
            : GetScalarType<T[P], ProductColorGroupByOutputType[P]>
        }
      >
    >


  export type ProductColorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | ProductColor$productArgs<ExtArgs>
    _count?: boolean | ProductColorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productColor"]>

  export type ProductColorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["productColor"]>

  export type ProductColorSelectScalar = {
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductColorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductColor$productArgs<ExtArgs>
    _count?: boolean | ProductColorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductColorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductColorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductColor"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attribute_name: string
      attribute_type: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productColor"]>
    composites: {}
  }

  type ProductColorGetPayload<S extends boolean | null | undefined | ProductColorDefaultArgs> = $Result.GetResult<Prisma.$ProductColorPayload, S>

  type ProductColorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductColorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductColorCountAggregateInputType | true
    }

  export interface ProductColorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductColor'], meta: { name: 'ProductColor' } }
    /**
     * Find zero or one ProductColor that matches the filter.
     * @param {ProductColorFindUniqueArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductColorFindUniqueArgs>(args: SelectSubset<T, ProductColorFindUniqueArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductColor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductColorFindUniqueOrThrowArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductColorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductColorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductColor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorFindFirstArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductColorFindFirstArgs>(args?: SelectSubset<T, ProductColorFindFirstArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductColor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorFindFirstOrThrowArgs} args - Arguments to find a ProductColor
     * @example
     * // Get one ProductColor
     * const productColor = await prisma.productColor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductColorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductColorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductColors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductColors
     * const productColors = await prisma.productColor.findMany()
     * 
     * // Get first 10 ProductColors
     * const productColors = await prisma.productColor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productColorWithIdOnly = await prisma.productColor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductColorFindManyArgs>(args?: SelectSubset<T, ProductColorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductColor.
     * @param {ProductColorCreateArgs} args - Arguments to create a ProductColor.
     * @example
     * // Create one ProductColor
     * const ProductColor = await prisma.productColor.create({
     *   data: {
     *     // ... data to create a ProductColor
     *   }
     * })
     * 
     */
    create<T extends ProductColorCreateArgs>(args: SelectSubset<T, ProductColorCreateArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductColors.
     * @param {ProductColorCreateManyArgs} args - Arguments to create many ProductColors.
     * @example
     * // Create many ProductColors
     * const productColor = await prisma.productColor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductColorCreateManyArgs>(args?: SelectSubset<T, ProductColorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductColors and returns the data saved in the database.
     * @param {ProductColorCreateManyAndReturnArgs} args - Arguments to create many ProductColors.
     * @example
     * // Create many ProductColors
     * const productColor = await prisma.productColor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductColors and only return the `id`
     * const productColorWithIdOnly = await prisma.productColor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductColorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductColorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductColor.
     * @param {ProductColorDeleteArgs} args - Arguments to delete one ProductColor.
     * @example
     * // Delete one ProductColor
     * const ProductColor = await prisma.productColor.delete({
     *   where: {
     *     // ... filter to delete one ProductColor
     *   }
     * })
     * 
     */
    delete<T extends ProductColorDeleteArgs>(args: SelectSubset<T, ProductColorDeleteArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductColor.
     * @param {ProductColorUpdateArgs} args - Arguments to update one ProductColor.
     * @example
     * // Update one ProductColor
     * const productColor = await prisma.productColor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductColorUpdateArgs>(args: SelectSubset<T, ProductColorUpdateArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductColors.
     * @param {ProductColorDeleteManyArgs} args - Arguments to filter ProductColors to delete.
     * @example
     * // Delete a few ProductColors
     * const { count } = await prisma.productColor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductColorDeleteManyArgs>(args?: SelectSubset<T, ProductColorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductColors
     * const productColor = await prisma.productColor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductColorUpdateManyArgs>(args: SelectSubset<T, ProductColorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductColor.
     * @param {ProductColorUpsertArgs} args - Arguments to update or create a ProductColor.
     * @example
     * // Update or create a ProductColor
     * const productColor = await prisma.productColor.upsert({
     *   create: {
     *     // ... data to create a ProductColor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductColor we want to update
     *   }
     * })
     */
    upsert<T extends ProductColorUpsertArgs>(args: SelectSubset<T, ProductColorUpsertArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductColors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorCountArgs} args - Arguments to filter ProductColors to count.
     * @example
     * // Count the number of ProductColors
     * const count = await prisma.productColor.count({
     *   where: {
     *     // ... the filter for the ProductColors we want to count
     *   }
     * })
    **/
    count<T extends ProductColorCountArgs>(
      args?: Subset<T, ProductColorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductColorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductColor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductColorAggregateArgs>(args: Subset<T, ProductColorAggregateArgs>): Prisma.PrismaPromise<GetProductColorAggregateType<T>>

    /**
     * Group by ProductColor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductColorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductColorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductColorGroupByArgs['orderBy'] }
        : { orderBy?: ProductColorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductColorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductColorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductColor model
   */
  readonly fields: ProductColorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductColor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductColorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductColor$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductColor$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductColor model
   */ 
  interface ProductColorFieldRefs {
    readonly id: FieldRef<"ProductColor", 'String'>
    readonly attribute_name: FieldRef<"ProductColor", 'String'>
    readonly attribute_type: FieldRef<"ProductColor", 'String'>
    readonly created_at: FieldRef<"ProductColor", 'DateTime'>
    readonly updated_at: FieldRef<"ProductColor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductColor findUnique
   */
  export type ProductColorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where: ProductColorWhereUniqueInput
  }

  /**
   * ProductColor findUniqueOrThrow
   */
  export type ProductColorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where: ProductColorWhereUniqueInput
  }

  /**
   * ProductColor findFirst
   */
  export type ProductColorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: ProductColorOrderByWithRelationInput | ProductColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductColors.
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductColors.
     */
    distinct?: ProductColorScalarFieldEnum | ProductColorScalarFieldEnum[]
  }

  /**
   * ProductColor findFirstOrThrow
   */
  export type ProductColorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColor to fetch.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: ProductColorOrderByWithRelationInput | ProductColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductColors.
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductColors.
     */
    distinct?: ProductColorScalarFieldEnum | ProductColorScalarFieldEnum[]
  }

  /**
   * ProductColor findMany
   */
  export type ProductColorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter, which ProductColors to fetch.
     */
    where?: ProductColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductColors to fetch.
     */
    orderBy?: ProductColorOrderByWithRelationInput | ProductColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductColors.
     */
    cursor?: ProductColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductColors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductColors.
     */
    skip?: number
    distinct?: ProductColorScalarFieldEnum | ProductColorScalarFieldEnum[]
  }

  /**
   * ProductColor create
   */
  export type ProductColorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductColor.
     */
    data: XOR<ProductColorCreateInput, ProductColorUncheckedCreateInput>
  }

  /**
   * ProductColor createMany
   */
  export type ProductColorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductColors.
     */
    data: ProductColorCreateManyInput | ProductColorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductColor createManyAndReturn
   */
  export type ProductColorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductColors.
     */
    data: ProductColorCreateManyInput | ProductColorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductColor update
   */
  export type ProductColorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductColor.
     */
    data: XOR<ProductColorUpdateInput, ProductColorUncheckedUpdateInput>
    /**
     * Choose, which ProductColor to update.
     */
    where: ProductColorWhereUniqueInput
  }

  /**
   * ProductColor updateMany
   */
  export type ProductColorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductColors.
     */
    data: XOR<ProductColorUpdateManyMutationInput, ProductColorUncheckedUpdateManyInput>
    /**
     * Filter which ProductColors to update
     */
    where?: ProductColorWhereInput
  }

  /**
   * ProductColor upsert
   */
  export type ProductColorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductColor to update in case it exists.
     */
    where: ProductColorWhereUniqueInput
    /**
     * In case the ProductColor found by the `where` argument doesn't exist, create a new ProductColor with this data.
     */
    create: XOR<ProductColorCreateInput, ProductColorUncheckedCreateInput>
    /**
     * In case the ProductColor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductColorUpdateInput, ProductColorUncheckedUpdateInput>
  }

  /**
   * ProductColor delete
   */
  export type ProductColorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    /**
     * Filter which ProductColor to delete.
     */
    where: ProductColorWhereUniqueInput
  }

  /**
   * ProductColor deleteMany
   */
  export type ProductColorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductColors to delete
     */
    where?: ProductColorWhereInput
  }

  /**
   * ProductColor.product
   */
  export type ProductColor$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductColor without action
   */
  export type ProductColorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
  }


  /**
   * Model ProductSize
   */

  export type AggregateProductSize = {
    _count: ProductSizeCountAggregateOutputType | null
    _min: ProductSizeMinAggregateOutputType | null
    _max: ProductSizeMaxAggregateOutputType | null
  }

  export type ProductSizeMinAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductSizeMaxAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductSizeCountAggregateOutputType = {
    id: number
    attribute_name: number
    attribute_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductSizeMinAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductSizeMaxAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductSizeCountAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSize to aggregate.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductSizes
    **/
    _count?: true | ProductSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductSizeMaxAggregateInputType
  }

  export type GetProductSizeAggregateType<T extends ProductSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductSize[P]>
      : GetScalarType<T[P], AggregateProductSize[P]>
  }




  export type ProductSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSizeWhereInput
    orderBy?: ProductSizeOrderByWithAggregationInput | ProductSizeOrderByWithAggregationInput[]
    by: ProductSizeScalarFieldEnum[] | ProductSizeScalarFieldEnum
    having?: ProductSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductSizeCountAggregateInputType | true
    _min?: ProductSizeMinAggregateInputType
    _max?: ProductSizeMaxAggregateInputType
  }

  export type ProductSizeGroupByOutputType = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at: Date
    updated_at: Date
    _count: ProductSizeCountAggregateOutputType | null
    _min: ProductSizeMinAggregateOutputType | null
    _max: ProductSizeMaxAggregateOutputType | null
  }

  type GetProductSizeGroupByPayload<T extends ProductSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
        }
      >
    >


  export type ProductSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | ProductSize$productArgs<ExtArgs>
    _count?: boolean | ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSize"]>

  export type ProductSizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["productSize"]>

  export type ProductSizeSelectScalar = {
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductSize$productArgs<ExtArgs>
    _count?: boolean | ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductSizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductSize"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attribute_name: string
      attribute_type: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productSize"]>
    composites: {}
  }

  type ProductSizeGetPayload<S extends boolean | null | undefined | ProductSizeDefaultArgs> = $Result.GetResult<Prisma.$ProductSizePayload, S>

  type ProductSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductSizeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductSizeCountAggregateInputType | true
    }

  export interface ProductSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSize'], meta: { name: 'ProductSize' } }
    /**
     * Find zero or one ProductSize that matches the filter.
     * @param {ProductSizeFindUniqueArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductSizeFindUniqueArgs>(args: SelectSubset<T, ProductSizeFindUniqueArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductSize that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductSizeFindUniqueOrThrowArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindFirstArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductSizeFindFirstArgs>(args?: SelectSubset<T, ProductSizeFindFirstArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindFirstOrThrowArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductSizes
     * const productSizes = await prisma.productSize.findMany()
     * 
     * // Get first 10 ProductSizes
     * const productSizes = await prisma.productSize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productSizeWithIdOnly = await prisma.productSize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductSizeFindManyArgs>(args?: SelectSubset<T, ProductSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductSize.
     * @param {ProductSizeCreateArgs} args - Arguments to create a ProductSize.
     * @example
     * // Create one ProductSize
     * const ProductSize = await prisma.productSize.create({
     *   data: {
     *     // ... data to create a ProductSize
     *   }
     * })
     * 
     */
    create<T extends ProductSizeCreateArgs>(args: SelectSubset<T, ProductSizeCreateArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductSizes.
     * @param {ProductSizeCreateManyArgs} args - Arguments to create many ProductSizes.
     * @example
     * // Create many ProductSizes
     * const productSize = await prisma.productSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductSizeCreateManyArgs>(args?: SelectSubset<T, ProductSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductSizes and returns the data saved in the database.
     * @param {ProductSizeCreateManyAndReturnArgs} args - Arguments to create many ProductSizes.
     * @example
     * // Create many ProductSizes
     * const productSize = await prisma.productSize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductSizes and only return the `id`
     * const productSizeWithIdOnly = await prisma.productSize.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductSizeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductSize.
     * @param {ProductSizeDeleteArgs} args - Arguments to delete one ProductSize.
     * @example
     * // Delete one ProductSize
     * const ProductSize = await prisma.productSize.delete({
     *   where: {
     *     // ... filter to delete one ProductSize
     *   }
     * })
     * 
     */
    delete<T extends ProductSizeDeleteArgs>(args: SelectSubset<T, ProductSizeDeleteArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductSize.
     * @param {ProductSizeUpdateArgs} args - Arguments to update one ProductSize.
     * @example
     * // Update one ProductSize
     * const productSize = await prisma.productSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductSizeUpdateArgs>(args: SelectSubset<T, ProductSizeUpdateArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductSizes.
     * @param {ProductSizeDeleteManyArgs} args - Arguments to filter ProductSizes to delete.
     * @example
     * // Delete a few ProductSizes
     * const { count } = await prisma.productSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductSizeDeleteManyArgs>(args?: SelectSubset<T, ProductSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductSizes
     * const productSize = await prisma.productSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductSizeUpdateManyArgs>(args: SelectSubset<T, ProductSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductSize.
     * @param {ProductSizeUpsertArgs} args - Arguments to update or create a ProductSize.
     * @example
     * // Update or create a ProductSize
     * const productSize = await prisma.productSize.upsert({
     *   create: {
     *     // ... data to create a ProductSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductSize we want to update
     *   }
     * })
     */
    upsert<T extends ProductSizeUpsertArgs>(args: SelectSubset<T, ProductSizeUpsertArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeCountArgs} args - Arguments to filter ProductSizes to count.
     * @example
     * // Count the number of ProductSizes
     * const count = await prisma.productSize.count({
     *   where: {
     *     // ... the filter for the ProductSizes we want to count
     *   }
     * })
    **/
    count<T extends ProductSizeCountArgs>(
      args?: Subset<T, ProductSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductSizeAggregateArgs>(args: Subset<T, ProductSizeAggregateArgs>): Prisma.PrismaPromise<GetProductSizeAggregateType<T>>

    /**
     * Group by ProductSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductSizeGroupByArgs['orderBy'] }
        : { orderBy?: ProductSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductSize model
   */
  readonly fields: ProductSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductSize$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductSize$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductSize model
   */ 
  interface ProductSizeFieldRefs {
    readonly id: FieldRef<"ProductSize", 'String'>
    readonly attribute_name: FieldRef<"ProductSize", 'String'>
    readonly attribute_type: FieldRef<"ProductSize", 'String'>
    readonly created_at: FieldRef<"ProductSize", 'DateTime'>
    readonly updated_at: FieldRef<"ProductSize", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductSize findUnique
   */
  export type ProductSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize findUniqueOrThrow
   */
  export type ProductSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize findFirst
   */
  export type ProductSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSizes.
     */
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * ProductSize findFirstOrThrow
   */
  export type ProductSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSizes.
     */
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * ProductSize findMany
   */
  export type ProductSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSizes to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }

  /**
   * ProductSize create
   */
  export type ProductSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductSize.
     */
    data: XOR<ProductSizeCreateInput, ProductSizeUncheckedCreateInput>
  }

  /**
   * ProductSize createMany
   */
  export type ProductSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductSizes.
     */
    data: ProductSizeCreateManyInput | ProductSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductSize createManyAndReturn
   */
  export type ProductSizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductSizes.
     */
    data: ProductSizeCreateManyInput | ProductSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductSize update
   */
  export type ProductSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductSize.
     */
    data: XOR<ProductSizeUpdateInput, ProductSizeUncheckedUpdateInput>
    /**
     * Choose, which ProductSize to update.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize updateMany
   */
  export type ProductSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductSizes.
     */
    data: XOR<ProductSizeUpdateManyMutationInput, ProductSizeUncheckedUpdateManyInput>
    /**
     * Filter which ProductSizes to update
     */
    where?: ProductSizeWhereInput
  }

  /**
   * ProductSize upsert
   */
  export type ProductSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductSize to update in case it exists.
     */
    where: ProductSizeWhereUniqueInput
    /**
     * In case the ProductSize found by the `where` argument doesn't exist, create a new ProductSize with this data.
     */
    create: XOR<ProductSizeCreateInput, ProductSizeUncheckedCreateInput>
    /**
     * In case the ProductSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductSizeUpdateInput, ProductSizeUncheckedUpdateInput>
  }

  /**
   * ProductSize delete
   */
  export type ProductSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter which ProductSize to delete.
     */
    where: ProductSizeWhereUniqueInput
  }

  /**
   * ProductSize deleteMany
   */
  export type ProductSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSizes to delete
     */
    where?: ProductSizeWhereInput
  }

  /**
   * ProductSize.product
   */
  export type ProductSize$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductSize without action
   */
  export type ProductSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
  }


  /**
   * Model ProductVoltage
   */

  export type AggregateProductVoltage = {
    _count: ProductVoltageCountAggregateOutputType | null
    _min: ProductVoltageMinAggregateOutputType | null
    _max: ProductVoltageMaxAggregateOutputType | null
  }

  export type ProductVoltageMinAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductVoltageMaxAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductVoltageCountAggregateOutputType = {
    id: number
    attribute_name: number
    attribute_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductVoltageMinAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductVoltageMaxAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductVoltageCountAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductVoltageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVoltage to aggregate.
     */
    where?: ProductVoltageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVoltages to fetch.
     */
    orderBy?: ProductVoltageOrderByWithRelationInput | ProductVoltageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVoltageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVoltages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVoltages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVoltages
    **/
    _count?: true | ProductVoltageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVoltageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVoltageMaxAggregateInputType
  }

  export type GetProductVoltageAggregateType<T extends ProductVoltageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVoltage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVoltage[P]>
      : GetScalarType<T[P], AggregateProductVoltage[P]>
  }




  export type ProductVoltageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVoltageWhereInput
    orderBy?: ProductVoltageOrderByWithAggregationInput | ProductVoltageOrderByWithAggregationInput[]
    by: ProductVoltageScalarFieldEnum[] | ProductVoltageScalarFieldEnum
    having?: ProductVoltageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVoltageCountAggregateInputType | true
    _min?: ProductVoltageMinAggregateInputType
    _max?: ProductVoltageMaxAggregateInputType
  }

  export type ProductVoltageGroupByOutputType = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at: Date
    updated_at: Date
    _count: ProductVoltageCountAggregateOutputType | null
    _min: ProductVoltageMinAggregateOutputType | null
    _max: ProductVoltageMaxAggregateOutputType | null
  }

  type GetProductVoltageGroupByPayload<T extends ProductVoltageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVoltageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVoltageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVoltageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVoltageGroupByOutputType[P]>
        }
      >
    >


  export type ProductVoltageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | ProductVoltage$productArgs<ExtArgs>
    _count?: boolean | ProductVoltageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVoltage"]>

  export type ProductVoltageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["productVoltage"]>

  export type ProductVoltageSelectScalar = {
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductVoltageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductVoltage$productArgs<ExtArgs>
    _count?: boolean | ProductVoltageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductVoltageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductVoltagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVoltage"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attribute_name: string
      attribute_type: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productVoltage"]>
    composites: {}
  }

  type ProductVoltageGetPayload<S extends boolean | null | undefined | ProductVoltageDefaultArgs> = $Result.GetResult<Prisma.$ProductVoltagePayload, S>

  type ProductVoltageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductVoltageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductVoltageCountAggregateInputType | true
    }

  export interface ProductVoltageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVoltage'], meta: { name: 'ProductVoltage' } }
    /**
     * Find zero or one ProductVoltage that matches the filter.
     * @param {ProductVoltageFindUniqueArgs} args - Arguments to find a ProductVoltage
     * @example
     * // Get one ProductVoltage
     * const productVoltage = await prisma.productVoltage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVoltageFindUniqueArgs>(args: SelectSubset<T, ProductVoltageFindUniqueArgs<ExtArgs>>): Prisma__ProductVoltageClient<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductVoltage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductVoltageFindUniqueOrThrowArgs} args - Arguments to find a ProductVoltage
     * @example
     * // Get one ProductVoltage
     * const productVoltage = await prisma.productVoltage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVoltageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVoltageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVoltageClient<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductVoltage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVoltageFindFirstArgs} args - Arguments to find a ProductVoltage
     * @example
     * // Get one ProductVoltage
     * const productVoltage = await prisma.productVoltage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVoltageFindFirstArgs>(args?: SelectSubset<T, ProductVoltageFindFirstArgs<ExtArgs>>): Prisma__ProductVoltageClient<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductVoltage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVoltageFindFirstOrThrowArgs} args - Arguments to find a ProductVoltage
     * @example
     * // Get one ProductVoltage
     * const productVoltage = await prisma.productVoltage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVoltageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVoltageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVoltageClient<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductVoltages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVoltageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVoltages
     * const productVoltages = await prisma.productVoltage.findMany()
     * 
     * // Get first 10 ProductVoltages
     * const productVoltages = await prisma.productVoltage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVoltageWithIdOnly = await prisma.productVoltage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVoltageFindManyArgs>(args?: SelectSubset<T, ProductVoltageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductVoltage.
     * @param {ProductVoltageCreateArgs} args - Arguments to create a ProductVoltage.
     * @example
     * // Create one ProductVoltage
     * const ProductVoltage = await prisma.productVoltage.create({
     *   data: {
     *     // ... data to create a ProductVoltage
     *   }
     * })
     * 
     */
    create<T extends ProductVoltageCreateArgs>(args: SelectSubset<T, ProductVoltageCreateArgs<ExtArgs>>): Prisma__ProductVoltageClient<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductVoltages.
     * @param {ProductVoltageCreateManyArgs} args - Arguments to create many ProductVoltages.
     * @example
     * // Create many ProductVoltages
     * const productVoltage = await prisma.productVoltage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVoltageCreateManyArgs>(args?: SelectSubset<T, ProductVoltageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVoltages and returns the data saved in the database.
     * @param {ProductVoltageCreateManyAndReturnArgs} args - Arguments to create many ProductVoltages.
     * @example
     * // Create many ProductVoltages
     * const productVoltage = await prisma.productVoltage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVoltages and only return the `id`
     * const productVoltageWithIdOnly = await prisma.productVoltage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVoltageCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVoltageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductVoltage.
     * @param {ProductVoltageDeleteArgs} args - Arguments to delete one ProductVoltage.
     * @example
     * // Delete one ProductVoltage
     * const ProductVoltage = await prisma.productVoltage.delete({
     *   where: {
     *     // ... filter to delete one ProductVoltage
     *   }
     * })
     * 
     */
    delete<T extends ProductVoltageDeleteArgs>(args: SelectSubset<T, ProductVoltageDeleteArgs<ExtArgs>>): Prisma__ProductVoltageClient<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductVoltage.
     * @param {ProductVoltageUpdateArgs} args - Arguments to update one ProductVoltage.
     * @example
     * // Update one ProductVoltage
     * const productVoltage = await prisma.productVoltage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVoltageUpdateArgs>(args: SelectSubset<T, ProductVoltageUpdateArgs<ExtArgs>>): Prisma__ProductVoltageClient<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductVoltages.
     * @param {ProductVoltageDeleteManyArgs} args - Arguments to filter ProductVoltages to delete.
     * @example
     * // Delete a few ProductVoltages
     * const { count } = await prisma.productVoltage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVoltageDeleteManyArgs>(args?: SelectSubset<T, ProductVoltageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVoltages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVoltageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVoltages
     * const productVoltage = await prisma.productVoltage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVoltageUpdateManyArgs>(args: SelectSubset<T, ProductVoltageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductVoltage.
     * @param {ProductVoltageUpsertArgs} args - Arguments to update or create a ProductVoltage.
     * @example
     * // Update or create a ProductVoltage
     * const productVoltage = await prisma.productVoltage.upsert({
     *   create: {
     *     // ... data to create a ProductVoltage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVoltage we want to update
     *   }
     * })
     */
    upsert<T extends ProductVoltageUpsertArgs>(args: SelectSubset<T, ProductVoltageUpsertArgs<ExtArgs>>): Prisma__ProductVoltageClient<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductVoltages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVoltageCountArgs} args - Arguments to filter ProductVoltages to count.
     * @example
     * // Count the number of ProductVoltages
     * const count = await prisma.productVoltage.count({
     *   where: {
     *     // ... the filter for the ProductVoltages we want to count
     *   }
     * })
    **/
    count<T extends ProductVoltageCountArgs>(
      args?: Subset<T, ProductVoltageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVoltageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVoltage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVoltageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVoltageAggregateArgs>(args: Subset<T, ProductVoltageAggregateArgs>): Prisma.PrismaPromise<GetProductVoltageAggregateType<T>>

    /**
     * Group by ProductVoltage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVoltageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVoltageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVoltageGroupByArgs['orderBy'] }
        : { orderBy?: ProductVoltageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVoltageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVoltageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVoltage model
   */
  readonly fields: ProductVoltageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVoltage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVoltageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductVoltage$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductVoltage$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVoltage model
   */ 
  interface ProductVoltageFieldRefs {
    readonly id: FieldRef<"ProductVoltage", 'String'>
    readonly attribute_name: FieldRef<"ProductVoltage", 'String'>
    readonly attribute_type: FieldRef<"ProductVoltage", 'String'>
    readonly created_at: FieldRef<"ProductVoltage", 'DateTime'>
    readonly updated_at: FieldRef<"ProductVoltage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVoltage findUnique
   */
  export type ProductVoltageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    /**
     * Filter, which ProductVoltage to fetch.
     */
    where: ProductVoltageWhereUniqueInput
  }

  /**
   * ProductVoltage findUniqueOrThrow
   */
  export type ProductVoltageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    /**
     * Filter, which ProductVoltage to fetch.
     */
    where: ProductVoltageWhereUniqueInput
  }

  /**
   * ProductVoltage findFirst
   */
  export type ProductVoltageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    /**
     * Filter, which ProductVoltage to fetch.
     */
    where?: ProductVoltageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVoltages to fetch.
     */
    orderBy?: ProductVoltageOrderByWithRelationInput | ProductVoltageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVoltages.
     */
    cursor?: ProductVoltageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVoltages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVoltages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVoltages.
     */
    distinct?: ProductVoltageScalarFieldEnum | ProductVoltageScalarFieldEnum[]
  }

  /**
   * ProductVoltage findFirstOrThrow
   */
  export type ProductVoltageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    /**
     * Filter, which ProductVoltage to fetch.
     */
    where?: ProductVoltageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVoltages to fetch.
     */
    orderBy?: ProductVoltageOrderByWithRelationInput | ProductVoltageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVoltages.
     */
    cursor?: ProductVoltageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVoltages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVoltages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVoltages.
     */
    distinct?: ProductVoltageScalarFieldEnum | ProductVoltageScalarFieldEnum[]
  }

  /**
   * ProductVoltage findMany
   */
  export type ProductVoltageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    /**
     * Filter, which ProductVoltages to fetch.
     */
    where?: ProductVoltageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVoltages to fetch.
     */
    orderBy?: ProductVoltageOrderByWithRelationInput | ProductVoltageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVoltages.
     */
    cursor?: ProductVoltageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVoltages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVoltages.
     */
    skip?: number
    distinct?: ProductVoltageScalarFieldEnum | ProductVoltageScalarFieldEnum[]
  }

  /**
   * ProductVoltage create
   */
  export type ProductVoltageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVoltage.
     */
    data: XOR<ProductVoltageCreateInput, ProductVoltageUncheckedCreateInput>
  }

  /**
   * ProductVoltage createMany
   */
  export type ProductVoltageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVoltages.
     */
    data: ProductVoltageCreateManyInput | ProductVoltageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVoltage createManyAndReturn
   */
  export type ProductVoltageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductVoltages.
     */
    data: ProductVoltageCreateManyInput | ProductVoltageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductVoltage update
   */
  export type ProductVoltageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVoltage.
     */
    data: XOR<ProductVoltageUpdateInput, ProductVoltageUncheckedUpdateInput>
    /**
     * Choose, which ProductVoltage to update.
     */
    where: ProductVoltageWhereUniqueInput
  }

  /**
   * ProductVoltage updateMany
   */
  export type ProductVoltageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVoltages.
     */
    data: XOR<ProductVoltageUpdateManyMutationInput, ProductVoltageUncheckedUpdateManyInput>
    /**
     * Filter which ProductVoltages to update
     */
    where?: ProductVoltageWhereInput
  }

  /**
   * ProductVoltage upsert
   */
  export type ProductVoltageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVoltage to update in case it exists.
     */
    where: ProductVoltageWhereUniqueInput
    /**
     * In case the ProductVoltage found by the `where` argument doesn't exist, create a new ProductVoltage with this data.
     */
    create: XOR<ProductVoltageCreateInput, ProductVoltageUncheckedCreateInput>
    /**
     * In case the ProductVoltage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVoltageUpdateInput, ProductVoltageUncheckedUpdateInput>
  }

  /**
   * ProductVoltage delete
   */
  export type ProductVoltageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    /**
     * Filter which ProductVoltage to delete.
     */
    where: ProductVoltageWhereUniqueInput
  }

  /**
   * ProductVoltage deleteMany
   */
  export type ProductVoltageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVoltages to delete
     */
    where?: ProductVoltageWhereInput
  }

  /**
   * ProductVoltage.product
   */
  export type ProductVoltage$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductVoltage without action
   */
  export type ProductVoltageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
  }


  /**
   * Model ProductFlavor
   */

  export type AggregateProductFlavor = {
    _count: ProductFlavorCountAggregateOutputType | null
    _min: ProductFlavorMinAggregateOutputType | null
    _max: ProductFlavorMaxAggregateOutputType | null
  }

  export type ProductFlavorMinAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductFlavorMaxAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductFlavorCountAggregateOutputType = {
    id: number
    attribute_name: number
    attribute_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductFlavorMinAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductFlavorMaxAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductFlavorCountAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductFlavorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductFlavor to aggregate.
     */
    where?: ProductFlavorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFlavors to fetch.
     */
    orderBy?: ProductFlavorOrderByWithRelationInput | ProductFlavorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductFlavorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFlavors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFlavors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductFlavors
    **/
    _count?: true | ProductFlavorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductFlavorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductFlavorMaxAggregateInputType
  }

  export type GetProductFlavorAggregateType<T extends ProductFlavorAggregateArgs> = {
        [P in keyof T & keyof AggregateProductFlavor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductFlavor[P]>
      : GetScalarType<T[P], AggregateProductFlavor[P]>
  }




  export type ProductFlavorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductFlavorWhereInput
    orderBy?: ProductFlavorOrderByWithAggregationInput | ProductFlavorOrderByWithAggregationInput[]
    by: ProductFlavorScalarFieldEnum[] | ProductFlavorScalarFieldEnum
    having?: ProductFlavorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductFlavorCountAggregateInputType | true
    _min?: ProductFlavorMinAggregateInputType
    _max?: ProductFlavorMaxAggregateInputType
  }

  export type ProductFlavorGroupByOutputType = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at: Date
    updated_at: Date
    _count: ProductFlavorCountAggregateOutputType | null
    _min: ProductFlavorMinAggregateOutputType | null
    _max: ProductFlavorMaxAggregateOutputType | null
  }

  type GetProductFlavorGroupByPayload<T extends ProductFlavorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductFlavorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductFlavorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductFlavorGroupByOutputType[P]>
            : GetScalarType<T[P], ProductFlavorGroupByOutputType[P]>
        }
      >
    >


  export type ProductFlavorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | ProductFlavor$productArgs<ExtArgs>
    _count?: boolean | ProductFlavorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productFlavor"]>

  export type ProductFlavorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["productFlavor"]>

  export type ProductFlavorSelectScalar = {
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductFlavorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductFlavor$productArgs<ExtArgs>
    _count?: boolean | ProductFlavorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductFlavorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductFlavorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductFlavor"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attribute_name: string
      attribute_type: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productFlavor"]>
    composites: {}
  }

  type ProductFlavorGetPayload<S extends boolean | null | undefined | ProductFlavorDefaultArgs> = $Result.GetResult<Prisma.$ProductFlavorPayload, S>

  type ProductFlavorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFlavorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductFlavorCountAggregateInputType | true
    }

  export interface ProductFlavorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductFlavor'], meta: { name: 'ProductFlavor' } }
    /**
     * Find zero or one ProductFlavor that matches the filter.
     * @param {ProductFlavorFindUniqueArgs} args - Arguments to find a ProductFlavor
     * @example
     * // Get one ProductFlavor
     * const productFlavor = await prisma.productFlavor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFlavorFindUniqueArgs>(args: SelectSubset<T, ProductFlavorFindUniqueArgs<ExtArgs>>): Prisma__ProductFlavorClient<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductFlavor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFlavorFindUniqueOrThrowArgs} args - Arguments to find a ProductFlavor
     * @example
     * // Get one ProductFlavor
     * const productFlavor = await prisma.productFlavor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFlavorFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFlavorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductFlavorClient<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductFlavor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorFindFirstArgs} args - Arguments to find a ProductFlavor
     * @example
     * // Get one ProductFlavor
     * const productFlavor = await prisma.productFlavor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFlavorFindFirstArgs>(args?: SelectSubset<T, ProductFlavorFindFirstArgs<ExtArgs>>): Prisma__ProductFlavorClient<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductFlavor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorFindFirstOrThrowArgs} args - Arguments to find a ProductFlavor
     * @example
     * // Get one ProductFlavor
     * const productFlavor = await prisma.productFlavor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFlavorFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFlavorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductFlavorClient<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductFlavors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductFlavors
     * const productFlavors = await prisma.productFlavor.findMany()
     * 
     * // Get first 10 ProductFlavors
     * const productFlavors = await prisma.productFlavor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productFlavorWithIdOnly = await prisma.productFlavor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFlavorFindManyArgs>(args?: SelectSubset<T, ProductFlavorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductFlavor.
     * @param {ProductFlavorCreateArgs} args - Arguments to create a ProductFlavor.
     * @example
     * // Create one ProductFlavor
     * const ProductFlavor = await prisma.productFlavor.create({
     *   data: {
     *     // ... data to create a ProductFlavor
     *   }
     * })
     * 
     */
    create<T extends ProductFlavorCreateArgs>(args: SelectSubset<T, ProductFlavorCreateArgs<ExtArgs>>): Prisma__ProductFlavorClient<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductFlavors.
     * @param {ProductFlavorCreateManyArgs} args - Arguments to create many ProductFlavors.
     * @example
     * // Create many ProductFlavors
     * const productFlavor = await prisma.productFlavor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductFlavorCreateManyArgs>(args?: SelectSubset<T, ProductFlavorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductFlavors and returns the data saved in the database.
     * @param {ProductFlavorCreateManyAndReturnArgs} args - Arguments to create many ProductFlavors.
     * @example
     * // Create many ProductFlavors
     * const productFlavor = await prisma.productFlavor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductFlavors and only return the `id`
     * const productFlavorWithIdOnly = await prisma.productFlavor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductFlavorCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductFlavorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductFlavor.
     * @param {ProductFlavorDeleteArgs} args - Arguments to delete one ProductFlavor.
     * @example
     * // Delete one ProductFlavor
     * const ProductFlavor = await prisma.productFlavor.delete({
     *   where: {
     *     // ... filter to delete one ProductFlavor
     *   }
     * })
     * 
     */
    delete<T extends ProductFlavorDeleteArgs>(args: SelectSubset<T, ProductFlavorDeleteArgs<ExtArgs>>): Prisma__ProductFlavorClient<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductFlavor.
     * @param {ProductFlavorUpdateArgs} args - Arguments to update one ProductFlavor.
     * @example
     * // Update one ProductFlavor
     * const productFlavor = await prisma.productFlavor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductFlavorUpdateArgs>(args: SelectSubset<T, ProductFlavorUpdateArgs<ExtArgs>>): Prisma__ProductFlavorClient<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductFlavors.
     * @param {ProductFlavorDeleteManyArgs} args - Arguments to filter ProductFlavors to delete.
     * @example
     * // Delete a few ProductFlavors
     * const { count } = await prisma.productFlavor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductFlavorDeleteManyArgs>(args?: SelectSubset<T, ProductFlavorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductFlavors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductFlavors
     * const productFlavor = await prisma.productFlavor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductFlavorUpdateManyArgs>(args: SelectSubset<T, ProductFlavorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductFlavor.
     * @param {ProductFlavorUpsertArgs} args - Arguments to update or create a ProductFlavor.
     * @example
     * // Update or create a ProductFlavor
     * const productFlavor = await prisma.productFlavor.upsert({
     *   create: {
     *     // ... data to create a ProductFlavor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductFlavor we want to update
     *   }
     * })
     */
    upsert<T extends ProductFlavorUpsertArgs>(args: SelectSubset<T, ProductFlavorUpsertArgs<ExtArgs>>): Prisma__ProductFlavorClient<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductFlavors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorCountArgs} args - Arguments to filter ProductFlavors to count.
     * @example
     * // Count the number of ProductFlavors
     * const count = await prisma.productFlavor.count({
     *   where: {
     *     // ... the filter for the ProductFlavors we want to count
     *   }
     * })
    **/
    count<T extends ProductFlavorCountArgs>(
      args?: Subset<T, ProductFlavorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductFlavorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductFlavor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductFlavorAggregateArgs>(args: Subset<T, ProductFlavorAggregateArgs>): Prisma.PrismaPromise<GetProductFlavorAggregateType<T>>

    /**
     * Group by ProductFlavor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFlavorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductFlavorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductFlavorGroupByArgs['orderBy'] }
        : { orderBy?: ProductFlavorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductFlavorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductFlavorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductFlavor model
   */
  readonly fields: ProductFlavorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductFlavor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductFlavorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductFlavor$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductFlavor$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductFlavor model
   */ 
  interface ProductFlavorFieldRefs {
    readonly id: FieldRef<"ProductFlavor", 'String'>
    readonly attribute_name: FieldRef<"ProductFlavor", 'String'>
    readonly attribute_type: FieldRef<"ProductFlavor", 'String'>
    readonly created_at: FieldRef<"ProductFlavor", 'DateTime'>
    readonly updated_at: FieldRef<"ProductFlavor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductFlavor findUnique
   */
  export type ProductFlavorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    /**
     * Filter, which ProductFlavor to fetch.
     */
    where: ProductFlavorWhereUniqueInput
  }

  /**
   * ProductFlavor findUniqueOrThrow
   */
  export type ProductFlavorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    /**
     * Filter, which ProductFlavor to fetch.
     */
    where: ProductFlavorWhereUniqueInput
  }

  /**
   * ProductFlavor findFirst
   */
  export type ProductFlavorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    /**
     * Filter, which ProductFlavor to fetch.
     */
    where?: ProductFlavorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFlavors to fetch.
     */
    orderBy?: ProductFlavorOrderByWithRelationInput | ProductFlavorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFlavors.
     */
    cursor?: ProductFlavorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFlavors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFlavors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFlavors.
     */
    distinct?: ProductFlavorScalarFieldEnum | ProductFlavorScalarFieldEnum[]
  }

  /**
   * ProductFlavor findFirstOrThrow
   */
  export type ProductFlavorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    /**
     * Filter, which ProductFlavor to fetch.
     */
    where?: ProductFlavorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFlavors to fetch.
     */
    orderBy?: ProductFlavorOrderByWithRelationInput | ProductFlavorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductFlavors.
     */
    cursor?: ProductFlavorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFlavors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFlavors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductFlavors.
     */
    distinct?: ProductFlavorScalarFieldEnum | ProductFlavorScalarFieldEnum[]
  }

  /**
   * ProductFlavor findMany
   */
  export type ProductFlavorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    /**
     * Filter, which ProductFlavors to fetch.
     */
    where?: ProductFlavorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductFlavors to fetch.
     */
    orderBy?: ProductFlavorOrderByWithRelationInput | ProductFlavorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductFlavors.
     */
    cursor?: ProductFlavorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductFlavors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductFlavors.
     */
    skip?: number
    distinct?: ProductFlavorScalarFieldEnum | ProductFlavorScalarFieldEnum[]
  }

  /**
   * ProductFlavor create
   */
  export type ProductFlavorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductFlavor.
     */
    data: XOR<ProductFlavorCreateInput, ProductFlavorUncheckedCreateInput>
  }

  /**
   * ProductFlavor createMany
   */
  export type ProductFlavorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductFlavors.
     */
    data: ProductFlavorCreateManyInput | ProductFlavorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductFlavor createManyAndReturn
   */
  export type ProductFlavorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductFlavors.
     */
    data: ProductFlavorCreateManyInput | ProductFlavorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductFlavor update
   */
  export type ProductFlavorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductFlavor.
     */
    data: XOR<ProductFlavorUpdateInput, ProductFlavorUncheckedUpdateInput>
    /**
     * Choose, which ProductFlavor to update.
     */
    where: ProductFlavorWhereUniqueInput
  }

  /**
   * ProductFlavor updateMany
   */
  export type ProductFlavorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductFlavors.
     */
    data: XOR<ProductFlavorUpdateManyMutationInput, ProductFlavorUncheckedUpdateManyInput>
    /**
     * Filter which ProductFlavors to update
     */
    where?: ProductFlavorWhereInput
  }

  /**
   * ProductFlavor upsert
   */
  export type ProductFlavorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductFlavor to update in case it exists.
     */
    where: ProductFlavorWhereUniqueInput
    /**
     * In case the ProductFlavor found by the `where` argument doesn't exist, create a new ProductFlavor with this data.
     */
    create: XOR<ProductFlavorCreateInput, ProductFlavorUncheckedCreateInput>
    /**
     * In case the ProductFlavor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductFlavorUpdateInput, ProductFlavorUncheckedUpdateInput>
  }

  /**
   * ProductFlavor delete
   */
  export type ProductFlavorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    /**
     * Filter which ProductFlavor to delete.
     */
    where: ProductFlavorWhereUniqueInput
  }

  /**
   * ProductFlavor deleteMany
   */
  export type ProductFlavorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductFlavors to delete
     */
    where?: ProductFlavorWhereInput
  }

  /**
   * ProductFlavor.product
   */
  export type ProductFlavor$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductFlavor without action
   */
  export type ProductFlavorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
  }


  /**
   * Model ProductPower
   */

  export type AggregateProductPower = {
    _count: ProductPowerCountAggregateOutputType | null
    _min: ProductPowerMinAggregateOutputType | null
    _max: ProductPowerMaxAggregateOutputType | null
  }

  export type ProductPowerMinAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductPowerMaxAggregateOutputType = {
    id: string | null
    attribute_name: string | null
    attribute_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductPowerCountAggregateOutputType = {
    id: number
    attribute_name: number
    attribute_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductPowerMinAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductPowerMaxAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductPowerCountAggregateInputType = {
    id?: true
    attribute_name?: true
    attribute_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductPowerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPower to aggregate.
     */
    where?: ProductPowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPowers to fetch.
     */
    orderBy?: ProductPowerOrderByWithRelationInput | ProductPowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductPowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductPowers
    **/
    _count?: true | ProductPowerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductPowerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductPowerMaxAggregateInputType
  }

  export type GetProductPowerAggregateType<T extends ProductPowerAggregateArgs> = {
        [P in keyof T & keyof AggregateProductPower]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductPower[P]>
      : GetScalarType<T[P], AggregateProductPower[P]>
  }




  export type ProductPowerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductPowerWhereInput
    orderBy?: ProductPowerOrderByWithAggregationInput | ProductPowerOrderByWithAggregationInput[]
    by: ProductPowerScalarFieldEnum[] | ProductPowerScalarFieldEnum
    having?: ProductPowerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductPowerCountAggregateInputType | true
    _min?: ProductPowerMinAggregateInputType
    _max?: ProductPowerMaxAggregateInputType
  }

  export type ProductPowerGroupByOutputType = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at: Date
    updated_at: Date
    _count: ProductPowerCountAggregateOutputType | null
    _min: ProductPowerMinAggregateOutputType | null
    _max: ProductPowerMaxAggregateOutputType | null
  }

  type GetProductPowerGroupByPayload<T extends ProductPowerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductPowerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductPowerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductPowerGroupByOutputType[P]>
            : GetScalarType<T[P], ProductPowerGroupByOutputType[P]>
        }
      >
    >


  export type ProductPowerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | ProductPower$productArgs<ExtArgs>
    _count?: boolean | ProductPowerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productPower"]>

  export type ProductPowerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["productPower"]>

  export type ProductPowerSelectScalar = {
    id?: boolean
    attribute_name?: boolean
    attribute_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductPowerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductPower$productArgs<ExtArgs>
    _count?: boolean | ProductPowerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductPowerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPowerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductPower"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attribute_name: string
      attribute_type: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productPower"]>
    composites: {}
  }

  type ProductPowerGetPayload<S extends boolean | null | undefined | ProductPowerDefaultArgs> = $Result.GetResult<Prisma.$ProductPowerPayload, S>

  type ProductPowerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductPowerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductPowerCountAggregateInputType | true
    }

  export interface ProductPowerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductPower'], meta: { name: 'ProductPower' } }
    /**
     * Find zero or one ProductPower that matches the filter.
     * @param {ProductPowerFindUniqueArgs} args - Arguments to find a ProductPower
     * @example
     * // Get one ProductPower
     * const productPower = await prisma.productPower.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductPowerFindUniqueArgs>(args: SelectSubset<T, ProductPowerFindUniqueArgs<ExtArgs>>): Prisma__ProductPowerClient<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductPower that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductPowerFindUniqueOrThrowArgs} args - Arguments to find a ProductPower
     * @example
     * // Get one ProductPower
     * const productPower = await prisma.productPower.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductPowerFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductPowerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductPowerClient<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductPower that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPowerFindFirstArgs} args - Arguments to find a ProductPower
     * @example
     * // Get one ProductPower
     * const productPower = await prisma.productPower.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductPowerFindFirstArgs>(args?: SelectSubset<T, ProductPowerFindFirstArgs<ExtArgs>>): Prisma__ProductPowerClient<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductPower that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPowerFindFirstOrThrowArgs} args - Arguments to find a ProductPower
     * @example
     * // Get one ProductPower
     * const productPower = await prisma.productPower.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductPowerFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductPowerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductPowerClient<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductPowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPowerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductPowers
     * const productPowers = await prisma.productPower.findMany()
     * 
     * // Get first 10 ProductPowers
     * const productPowers = await prisma.productPower.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productPowerWithIdOnly = await prisma.productPower.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductPowerFindManyArgs>(args?: SelectSubset<T, ProductPowerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductPower.
     * @param {ProductPowerCreateArgs} args - Arguments to create a ProductPower.
     * @example
     * // Create one ProductPower
     * const ProductPower = await prisma.productPower.create({
     *   data: {
     *     // ... data to create a ProductPower
     *   }
     * })
     * 
     */
    create<T extends ProductPowerCreateArgs>(args: SelectSubset<T, ProductPowerCreateArgs<ExtArgs>>): Prisma__ProductPowerClient<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductPowers.
     * @param {ProductPowerCreateManyArgs} args - Arguments to create many ProductPowers.
     * @example
     * // Create many ProductPowers
     * const productPower = await prisma.productPower.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductPowerCreateManyArgs>(args?: SelectSubset<T, ProductPowerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductPowers and returns the data saved in the database.
     * @param {ProductPowerCreateManyAndReturnArgs} args - Arguments to create many ProductPowers.
     * @example
     * // Create many ProductPowers
     * const productPower = await prisma.productPower.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductPowers and only return the `id`
     * const productPowerWithIdOnly = await prisma.productPower.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductPowerCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductPowerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductPower.
     * @param {ProductPowerDeleteArgs} args - Arguments to delete one ProductPower.
     * @example
     * // Delete one ProductPower
     * const ProductPower = await prisma.productPower.delete({
     *   where: {
     *     // ... filter to delete one ProductPower
     *   }
     * })
     * 
     */
    delete<T extends ProductPowerDeleteArgs>(args: SelectSubset<T, ProductPowerDeleteArgs<ExtArgs>>): Prisma__ProductPowerClient<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductPower.
     * @param {ProductPowerUpdateArgs} args - Arguments to update one ProductPower.
     * @example
     * // Update one ProductPower
     * const productPower = await prisma.productPower.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductPowerUpdateArgs>(args: SelectSubset<T, ProductPowerUpdateArgs<ExtArgs>>): Prisma__ProductPowerClient<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductPowers.
     * @param {ProductPowerDeleteManyArgs} args - Arguments to filter ProductPowers to delete.
     * @example
     * // Delete a few ProductPowers
     * const { count } = await prisma.productPower.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductPowerDeleteManyArgs>(args?: SelectSubset<T, ProductPowerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductPowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPowerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductPowers
     * const productPower = await prisma.productPower.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductPowerUpdateManyArgs>(args: SelectSubset<T, ProductPowerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductPower.
     * @param {ProductPowerUpsertArgs} args - Arguments to update or create a ProductPower.
     * @example
     * // Update or create a ProductPower
     * const productPower = await prisma.productPower.upsert({
     *   create: {
     *     // ... data to create a ProductPower
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductPower we want to update
     *   }
     * })
     */
    upsert<T extends ProductPowerUpsertArgs>(args: SelectSubset<T, ProductPowerUpsertArgs<ExtArgs>>): Prisma__ProductPowerClient<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductPowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPowerCountArgs} args - Arguments to filter ProductPowers to count.
     * @example
     * // Count the number of ProductPowers
     * const count = await prisma.productPower.count({
     *   where: {
     *     // ... the filter for the ProductPowers we want to count
     *   }
     * })
    **/
    count<T extends ProductPowerCountArgs>(
      args?: Subset<T, ProductPowerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductPowerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductPower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPowerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductPowerAggregateArgs>(args: Subset<T, ProductPowerAggregateArgs>): Prisma.PrismaPromise<GetProductPowerAggregateType<T>>

    /**
     * Group by ProductPower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductPowerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductPowerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductPowerGroupByArgs['orderBy'] }
        : { orderBy?: ProductPowerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductPowerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductPowerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductPower model
   */
  readonly fields: ProductPowerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductPower.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductPowerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductPower$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductPower$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductPower model
   */ 
  interface ProductPowerFieldRefs {
    readonly id: FieldRef<"ProductPower", 'String'>
    readonly attribute_name: FieldRef<"ProductPower", 'String'>
    readonly attribute_type: FieldRef<"ProductPower", 'String'>
    readonly created_at: FieldRef<"ProductPower", 'DateTime'>
    readonly updated_at: FieldRef<"ProductPower", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductPower findUnique
   */
  export type ProductPowerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    /**
     * Filter, which ProductPower to fetch.
     */
    where: ProductPowerWhereUniqueInput
  }

  /**
   * ProductPower findUniqueOrThrow
   */
  export type ProductPowerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    /**
     * Filter, which ProductPower to fetch.
     */
    where: ProductPowerWhereUniqueInput
  }

  /**
   * ProductPower findFirst
   */
  export type ProductPowerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    /**
     * Filter, which ProductPower to fetch.
     */
    where?: ProductPowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPowers to fetch.
     */
    orderBy?: ProductPowerOrderByWithRelationInput | ProductPowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPowers.
     */
    cursor?: ProductPowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPowers.
     */
    distinct?: ProductPowerScalarFieldEnum | ProductPowerScalarFieldEnum[]
  }

  /**
   * ProductPower findFirstOrThrow
   */
  export type ProductPowerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    /**
     * Filter, which ProductPower to fetch.
     */
    where?: ProductPowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPowers to fetch.
     */
    orderBy?: ProductPowerOrderByWithRelationInput | ProductPowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductPowers.
     */
    cursor?: ProductPowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductPowers.
     */
    distinct?: ProductPowerScalarFieldEnum | ProductPowerScalarFieldEnum[]
  }

  /**
   * ProductPower findMany
   */
  export type ProductPowerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    /**
     * Filter, which ProductPowers to fetch.
     */
    where?: ProductPowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductPowers to fetch.
     */
    orderBy?: ProductPowerOrderByWithRelationInput | ProductPowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductPowers.
     */
    cursor?: ProductPowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductPowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductPowers.
     */
    skip?: number
    distinct?: ProductPowerScalarFieldEnum | ProductPowerScalarFieldEnum[]
  }

  /**
   * ProductPower create
   */
  export type ProductPowerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductPower.
     */
    data: XOR<ProductPowerCreateInput, ProductPowerUncheckedCreateInput>
  }

  /**
   * ProductPower createMany
   */
  export type ProductPowerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductPowers.
     */
    data: ProductPowerCreateManyInput | ProductPowerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductPower createManyAndReturn
   */
  export type ProductPowerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductPowers.
     */
    data: ProductPowerCreateManyInput | ProductPowerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductPower update
   */
  export type ProductPowerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductPower.
     */
    data: XOR<ProductPowerUpdateInput, ProductPowerUncheckedUpdateInput>
    /**
     * Choose, which ProductPower to update.
     */
    where: ProductPowerWhereUniqueInput
  }

  /**
   * ProductPower updateMany
   */
  export type ProductPowerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductPowers.
     */
    data: XOR<ProductPowerUpdateManyMutationInput, ProductPowerUncheckedUpdateManyInput>
    /**
     * Filter which ProductPowers to update
     */
    where?: ProductPowerWhereInput
  }

  /**
   * ProductPower upsert
   */
  export type ProductPowerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductPower to update in case it exists.
     */
    where: ProductPowerWhereUniqueInput
    /**
     * In case the ProductPower found by the `where` argument doesn't exist, create a new ProductPower with this data.
     */
    create: XOR<ProductPowerCreateInput, ProductPowerUncheckedCreateInput>
    /**
     * In case the ProductPower was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductPowerUpdateInput, ProductPowerUncheckedUpdateInput>
  }

  /**
   * ProductPower delete
   */
  export type ProductPowerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    /**
     * Filter which ProductPower to delete.
     */
    where: ProductPowerWhereUniqueInput
  }

  /**
   * ProductPower deleteMany
   */
  export type ProductPowerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductPowers to delete
     */
    where?: ProductPowerWhereInput
  }

  /**
   * ProductPower.product
   */
  export type ProductPower$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductPower without action
   */
  export type ProductPowerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
  }


  /**
   * Model SaleChannel
   */

  export type AggregateSaleChannel = {
    _count: SaleChannelCountAggregateOutputType | null
    _avg: SaleChannelAvgAggregateOutputType | null
    _sum: SaleChannelSumAggregateOutputType | null
    _min: SaleChannelMinAggregateOutputType | null
    _max: SaleChannelMaxAggregateOutputType | null
  }

  export type SaleChannelAvgAggregateOutputType = {
    code: number | null
    sale_price: number | null
  }

  export type SaleChannelSumAggregateOutputType = {
    code: number | null
    sale_price: number | null
  }

  export type SaleChannelMinAggregateOutputType = {
    id: string | null
    sale_channel: string | null
    code: number | null
    channel_type: string | null
    product_id: string | null
    sale_price: number | null
    sale_date_start: Date | null
    sale_date_end: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SaleChannelMaxAggregateOutputType = {
    id: string | null
    sale_channel: string | null
    code: number | null
    channel_type: string | null
    product_id: string | null
    sale_price: number | null
    sale_date_start: Date | null
    sale_date_end: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SaleChannelCountAggregateOutputType = {
    id: number
    sale_channel: number
    code: number
    channel_type: number
    product_id: number
    sale_price: number
    sale_date_start: number
    sale_date_end: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SaleChannelAvgAggregateInputType = {
    code?: true
    sale_price?: true
  }

  export type SaleChannelSumAggregateInputType = {
    code?: true
    sale_price?: true
  }

  export type SaleChannelMinAggregateInputType = {
    id?: true
    sale_channel?: true
    code?: true
    channel_type?: true
    product_id?: true
    sale_price?: true
    sale_date_start?: true
    sale_date_end?: true
    created_at?: true
    updated_at?: true
  }

  export type SaleChannelMaxAggregateInputType = {
    id?: true
    sale_channel?: true
    code?: true
    channel_type?: true
    product_id?: true
    sale_price?: true
    sale_date_start?: true
    sale_date_end?: true
    created_at?: true
    updated_at?: true
  }

  export type SaleChannelCountAggregateInputType = {
    id?: true
    sale_channel?: true
    code?: true
    channel_type?: true
    product_id?: true
    sale_price?: true
    sale_date_start?: true
    sale_date_end?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SaleChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleChannel to aggregate.
     */
    where?: SaleChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleChannels to fetch.
     */
    orderBy?: SaleChannelOrderByWithRelationInput | SaleChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleChannels
    **/
    _count?: true | SaleChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleChannelMaxAggregateInputType
  }

  export type GetSaleChannelAggregateType<T extends SaleChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleChannel[P]>
      : GetScalarType<T[P], AggregateSaleChannel[P]>
  }




  export type SaleChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleChannelWhereInput
    orderBy?: SaleChannelOrderByWithAggregationInput | SaleChannelOrderByWithAggregationInput[]
    by: SaleChannelScalarFieldEnum[] | SaleChannelScalarFieldEnum
    having?: SaleChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleChannelCountAggregateInputType | true
    _avg?: SaleChannelAvgAggregateInputType
    _sum?: SaleChannelSumAggregateInputType
    _min?: SaleChannelMinAggregateInputType
    _max?: SaleChannelMaxAggregateInputType
  }

  export type SaleChannelGroupByOutputType = {
    id: string
    sale_channel: string
    code: number
    channel_type: string
    product_id: string | null
    sale_price: number | null
    sale_date_start: Date | null
    sale_date_end: Date | null
    created_at: Date
    updated_at: Date
    _count: SaleChannelCountAggregateOutputType | null
    _avg: SaleChannelAvgAggregateOutputType | null
    _sum: SaleChannelSumAggregateOutputType | null
    _min: SaleChannelMinAggregateOutputType | null
    _max: SaleChannelMaxAggregateOutputType | null
  }

  type GetSaleChannelGroupByPayload<T extends SaleChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleChannelGroupByOutputType[P]>
            : GetScalarType<T[P], SaleChannelGroupByOutputType[P]>
        }
      >
    >


  export type SaleChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_channel?: boolean
    code?: boolean
    channel_type?: boolean
    product_id?: boolean
    sale_price?: boolean
    sale_date_start?: boolean
    sale_date_end?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | SaleChannel$productArgs<ExtArgs>
  }, ExtArgs["result"]["saleChannel"]>

  export type SaleChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_channel?: boolean
    code?: boolean
    channel_type?: boolean
    product_id?: boolean
    sale_price?: boolean
    sale_date_start?: boolean
    sale_date_end?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | SaleChannel$productArgs<ExtArgs>
  }, ExtArgs["result"]["saleChannel"]>

  export type SaleChannelSelectScalar = {
    id?: boolean
    sale_channel?: boolean
    code?: boolean
    channel_type?: boolean
    product_id?: boolean
    sale_price?: boolean
    sale_date_start?: boolean
    sale_date_end?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SaleChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | SaleChannel$productArgs<ExtArgs>
  }
  export type SaleChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | SaleChannel$productArgs<ExtArgs>
  }

  export type $SaleChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleChannel"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sale_channel: string
      code: number
      channel_type: string
      product_id: string | null
      sale_price: number | null
      sale_date_start: Date | null
      sale_date_end: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["saleChannel"]>
    composites: {}
  }

  type SaleChannelGetPayload<S extends boolean | null | undefined | SaleChannelDefaultArgs> = $Result.GetResult<Prisma.$SaleChannelPayload, S>

  type SaleChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SaleChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SaleChannelCountAggregateInputType | true
    }

  export interface SaleChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleChannel'], meta: { name: 'SaleChannel' } }
    /**
     * Find zero or one SaleChannel that matches the filter.
     * @param {SaleChannelFindUniqueArgs} args - Arguments to find a SaleChannel
     * @example
     * // Get one SaleChannel
     * const saleChannel = await prisma.saleChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleChannelFindUniqueArgs>(args: SelectSubset<T, SaleChannelFindUniqueArgs<ExtArgs>>): Prisma__SaleChannelClient<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SaleChannel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SaleChannelFindUniqueOrThrowArgs} args - Arguments to find a SaleChannel
     * @example
     * // Get one SaleChannel
     * const saleChannel = await prisma.saleChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleChannelClient<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SaleChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleChannelFindFirstArgs} args - Arguments to find a SaleChannel
     * @example
     * // Get one SaleChannel
     * const saleChannel = await prisma.saleChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleChannelFindFirstArgs>(args?: SelectSubset<T, SaleChannelFindFirstArgs<ExtArgs>>): Prisma__SaleChannelClient<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SaleChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleChannelFindFirstOrThrowArgs} args - Arguments to find a SaleChannel
     * @example
     * // Get one SaleChannel
     * const saleChannel = await prisma.saleChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleChannelClient<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SaleChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleChannels
     * const saleChannels = await prisma.saleChannel.findMany()
     * 
     * // Get first 10 SaleChannels
     * const saleChannels = await prisma.saleChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleChannelWithIdOnly = await prisma.saleChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleChannelFindManyArgs>(args?: SelectSubset<T, SaleChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SaleChannel.
     * @param {SaleChannelCreateArgs} args - Arguments to create a SaleChannel.
     * @example
     * // Create one SaleChannel
     * const SaleChannel = await prisma.saleChannel.create({
     *   data: {
     *     // ... data to create a SaleChannel
     *   }
     * })
     * 
     */
    create<T extends SaleChannelCreateArgs>(args: SelectSubset<T, SaleChannelCreateArgs<ExtArgs>>): Prisma__SaleChannelClient<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SaleChannels.
     * @param {SaleChannelCreateManyArgs} args - Arguments to create many SaleChannels.
     * @example
     * // Create many SaleChannels
     * const saleChannel = await prisma.saleChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleChannelCreateManyArgs>(args?: SelectSubset<T, SaleChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleChannels and returns the data saved in the database.
     * @param {SaleChannelCreateManyAndReturnArgs} args - Arguments to create many SaleChannels.
     * @example
     * // Create many SaleChannels
     * const saleChannel = await prisma.saleChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleChannels and only return the `id`
     * const saleChannelWithIdOnly = await prisma.saleChannel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SaleChannel.
     * @param {SaleChannelDeleteArgs} args - Arguments to delete one SaleChannel.
     * @example
     * // Delete one SaleChannel
     * const SaleChannel = await prisma.saleChannel.delete({
     *   where: {
     *     // ... filter to delete one SaleChannel
     *   }
     * })
     * 
     */
    delete<T extends SaleChannelDeleteArgs>(args: SelectSubset<T, SaleChannelDeleteArgs<ExtArgs>>): Prisma__SaleChannelClient<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SaleChannel.
     * @param {SaleChannelUpdateArgs} args - Arguments to update one SaleChannel.
     * @example
     * // Update one SaleChannel
     * const saleChannel = await prisma.saleChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleChannelUpdateArgs>(args: SelectSubset<T, SaleChannelUpdateArgs<ExtArgs>>): Prisma__SaleChannelClient<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SaleChannels.
     * @param {SaleChannelDeleteManyArgs} args - Arguments to filter SaleChannels to delete.
     * @example
     * // Delete a few SaleChannels
     * const { count } = await prisma.saleChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleChannelDeleteManyArgs>(args?: SelectSubset<T, SaleChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleChannels
     * const saleChannel = await prisma.saleChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleChannelUpdateManyArgs>(args: SelectSubset<T, SaleChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SaleChannel.
     * @param {SaleChannelUpsertArgs} args - Arguments to update or create a SaleChannel.
     * @example
     * // Update or create a SaleChannel
     * const saleChannel = await prisma.saleChannel.upsert({
     *   create: {
     *     // ... data to create a SaleChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleChannel we want to update
     *   }
     * })
     */
    upsert<T extends SaleChannelUpsertArgs>(args: SelectSubset<T, SaleChannelUpsertArgs<ExtArgs>>): Prisma__SaleChannelClient<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SaleChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleChannelCountArgs} args - Arguments to filter SaleChannels to count.
     * @example
     * // Count the number of SaleChannels
     * const count = await prisma.saleChannel.count({
     *   where: {
     *     // ... the filter for the SaleChannels we want to count
     *   }
     * })
    **/
    count<T extends SaleChannelCountArgs>(
      args?: Subset<T, SaleChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleChannelAggregateArgs>(args: Subset<T, SaleChannelAggregateArgs>): Prisma.PrismaPromise<GetSaleChannelAggregateType<T>>

    /**
     * Group by SaleChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleChannelGroupByArgs['orderBy'] }
        : { orderBy?: SaleChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleChannel model
   */
  readonly fields: SaleChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends SaleChannel$productArgs<ExtArgs> = {}>(args?: Subset<T, SaleChannel$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleChannel model
   */ 
  interface SaleChannelFieldRefs {
    readonly id: FieldRef<"SaleChannel", 'String'>
    readonly sale_channel: FieldRef<"SaleChannel", 'String'>
    readonly code: FieldRef<"SaleChannel", 'Int'>
    readonly channel_type: FieldRef<"SaleChannel", 'String'>
    readonly product_id: FieldRef<"SaleChannel", 'String'>
    readonly sale_price: FieldRef<"SaleChannel", 'Float'>
    readonly sale_date_start: FieldRef<"SaleChannel", 'DateTime'>
    readonly sale_date_end: FieldRef<"SaleChannel", 'DateTime'>
    readonly created_at: FieldRef<"SaleChannel", 'DateTime'>
    readonly updated_at: FieldRef<"SaleChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleChannel findUnique
   */
  export type SaleChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    /**
     * Filter, which SaleChannel to fetch.
     */
    where: SaleChannelWhereUniqueInput
  }

  /**
   * SaleChannel findUniqueOrThrow
   */
  export type SaleChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    /**
     * Filter, which SaleChannel to fetch.
     */
    where: SaleChannelWhereUniqueInput
  }

  /**
   * SaleChannel findFirst
   */
  export type SaleChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    /**
     * Filter, which SaleChannel to fetch.
     */
    where?: SaleChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleChannels to fetch.
     */
    orderBy?: SaleChannelOrderByWithRelationInput | SaleChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleChannels.
     */
    cursor?: SaleChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleChannels.
     */
    distinct?: SaleChannelScalarFieldEnum | SaleChannelScalarFieldEnum[]
  }

  /**
   * SaleChannel findFirstOrThrow
   */
  export type SaleChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    /**
     * Filter, which SaleChannel to fetch.
     */
    where?: SaleChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleChannels to fetch.
     */
    orderBy?: SaleChannelOrderByWithRelationInput | SaleChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleChannels.
     */
    cursor?: SaleChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleChannels.
     */
    distinct?: SaleChannelScalarFieldEnum | SaleChannelScalarFieldEnum[]
  }

  /**
   * SaleChannel findMany
   */
  export type SaleChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    /**
     * Filter, which SaleChannels to fetch.
     */
    where?: SaleChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleChannels to fetch.
     */
    orderBy?: SaleChannelOrderByWithRelationInput | SaleChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleChannels.
     */
    cursor?: SaleChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleChannels.
     */
    skip?: number
    distinct?: SaleChannelScalarFieldEnum | SaleChannelScalarFieldEnum[]
  }

  /**
   * SaleChannel create
   */
  export type SaleChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleChannel.
     */
    data: XOR<SaleChannelCreateInput, SaleChannelUncheckedCreateInput>
  }

  /**
   * SaleChannel createMany
   */
  export type SaleChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleChannels.
     */
    data: SaleChannelCreateManyInput | SaleChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleChannel createManyAndReturn
   */
  export type SaleChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SaleChannels.
     */
    data: SaleChannelCreateManyInput | SaleChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleChannel update
   */
  export type SaleChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleChannel.
     */
    data: XOR<SaleChannelUpdateInput, SaleChannelUncheckedUpdateInput>
    /**
     * Choose, which SaleChannel to update.
     */
    where: SaleChannelWhereUniqueInput
  }

  /**
   * SaleChannel updateMany
   */
  export type SaleChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleChannels.
     */
    data: XOR<SaleChannelUpdateManyMutationInput, SaleChannelUncheckedUpdateManyInput>
    /**
     * Filter which SaleChannels to update
     */
    where?: SaleChannelWhereInput
  }

  /**
   * SaleChannel upsert
   */
  export type SaleChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleChannel to update in case it exists.
     */
    where: SaleChannelWhereUniqueInput
    /**
     * In case the SaleChannel found by the `where` argument doesn't exist, create a new SaleChannel with this data.
     */
    create: XOR<SaleChannelCreateInput, SaleChannelUncheckedCreateInput>
    /**
     * In case the SaleChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleChannelUpdateInput, SaleChannelUncheckedUpdateInput>
  }

  /**
   * SaleChannel delete
   */
  export type SaleChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    /**
     * Filter which SaleChannel to delete.
     */
    where: SaleChannelWhereUniqueInput
  }

  /**
   * SaleChannel deleteMany
   */
  export type SaleChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleChannels to delete
     */
    where?: SaleChannelWhereInput
  }

  /**
   * SaleChannel.product
   */
  export type SaleChannel$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * SaleChannel without action
   */
  export type SaleChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
  }


  /**
   * Model ProductCustomCategory
   */

  export type AggregateProductCustomCategory = {
    _count: ProductCustomCategoryCountAggregateOutputType | null
    _min: ProductCustomCategoryMinAggregateOutputType | null
    _max: ProductCustomCategoryMaxAggregateOutputType | null
  }

  export type ProductCustomCategoryMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductCustomCategoryMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductCustomCategoryCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductCustomCategoryMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductCustomCategoryMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductCustomCategoryCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductCustomCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCustomCategory to aggregate.
     */
    where?: ProductCustomCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCustomCategories to fetch.
     */
    orderBy?: ProductCustomCategoryOrderByWithRelationInput | ProductCustomCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCustomCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCustomCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCustomCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCustomCategories
    **/
    _count?: true | ProductCustomCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCustomCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCustomCategoryMaxAggregateInputType
  }

  export type GetProductCustomCategoryAggregateType<T extends ProductCustomCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCustomCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCustomCategory[P]>
      : GetScalarType<T[P], AggregateProductCustomCategory[P]>
  }




  export type ProductCustomCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCustomCategoryWhereInput
    orderBy?: ProductCustomCategoryOrderByWithAggregationInput | ProductCustomCategoryOrderByWithAggregationInput[]
    by: ProductCustomCategoryScalarFieldEnum[] | ProductCustomCategoryScalarFieldEnum
    having?: ProductCustomCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCustomCategoryCountAggregateInputType | true
    _min?: ProductCustomCategoryMinAggregateInputType
    _max?: ProductCustomCategoryMaxAggregateInputType
  }

  export type ProductCustomCategoryGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    _count: ProductCustomCategoryCountAggregateOutputType | null
    _min: ProductCustomCategoryMinAggregateOutputType | null
    _max: ProductCustomCategoryMaxAggregateOutputType | null
  }

  type GetProductCustomCategoryGroupByPayload<T extends ProductCustomCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCustomCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCustomCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCustomCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCustomCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCustomCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | ProductCustomCategory$productArgs<ExtArgs>
    _count?: boolean | ProductCustomCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCustomCategory"]>

  export type ProductCustomCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["productCustomCategory"]>

  export type ProductCustomCategorySelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductCustomCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductCustomCategory$productArgs<ExtArgs>
    _count?: boolean | ProductCustomCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCustomCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductCustomCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCustomCategory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productCustomCategory"]>
    composites: {}
  }

  type ProductCustomCategoryGetPayload<S extends boolean | null | undefined | ProductCustomCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCustomCategoryPayload, S>

  type ProductCustomCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductCustomCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCustomCategoryCountAggregateInputType | true
    }

  export interface ProductCustomCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCustomCategory'], meta: { name: 'ProductCustomCategory' } }
    /**
     * Find zero or one ProductCustomCategory that matches the filter.
     * @param {ProductCustomCategoryFindUniqueArgs} args - Arguments to find a ProductCustomCategory
     * @example
     * // Get one ProductCustomCategory
     * const productCustomCategory = await prisma.productCustomCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCustomCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCustomCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCustomCategoryClient<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductCustomCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductCustomCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCustomCategory
     * @example
     * // Get one ProductCustomCategory
     * const productCustomCategory = await prisma.productCustomCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCustomCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCustomCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCustomCategoryClient<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductCustomCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomCategoryFindFirstArgs} args - Arguments to find a ProductCustomCategory
     * @example
     * // Get one ProductCustomCategory
     * const productCustomCategory = await prisma.productCustomCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCustomCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCustomCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCustomCategoryClient<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductCustomCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCustomCategory
     * @example
     * // Get one ProductCustomCategory
     * const productCustomCategory = await prisma.productCustomCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCustomCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCustomCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCustomCategoryClient<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductCustomCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCustomCategories
     * const productCustomCategories = await prisma.productCustomCategory.findMany()
     * 
     * // Get first 10 ProductCustomCategories
     * const productCustomCategories = await prisma.productCustomCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCustomCategoryWithIdOnly = await prisma.productCustomCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCustomCategoryFindManyArgs>(args?: SelectSubset<T, ProductCustomCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductCustomCategory.
     * @param {ProductCustomCategoryCreateArgs} args - Arguments to create a ProductCustomCategory.
     * @example
     * // Create one ProductCustomCategory
     * const ProductCustomCategory = await prisma.productCustomCategory.create({
     *   data: {
     *     // ... data to create a ProductCustomCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCustomCategoryCreateArgs>(args: SelectSubset<T, ProductCustomCategoryCreateArgs<ExtArgs>>): Prisma__ProductCustomCategoryClient<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductCustomCategories.
     * @param {ProductCustomCategoryCreateManyArgs} args - Arguments to create many ProductCustomCategories.
     * @example
     * // Create many ProductCustomCategories
     * const productCustomCategory = await prisma.productCustomCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCustomCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCustomCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCustomCategories and returns the data saved in the database.
     * @param {ProductCustomCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCustomCategories.
     * @example
     * // Create many ProductCustomCategories
     * const productCustomCategory = await prisma.productCustomCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCustomCategories and only return the `id`
     * const productCustomCategoryWithIdOnly = await prisma.productCustomCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCustomCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCustomCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductCustomCategory.
     * @param {ProductCustomCategoryDeleteArgs} args - Arguments to delete one ProductCustomCategory.
     * @example
     * // Delete one ProductCustomCategory
     * const ProductCustomCategory = await prisma.productCustomCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCustomCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCustomCategoryDeleteArgs>(args: SelectSubset<T, ProductCustomCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCustomCategoryClient<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductCustomCategory.
     * @param {ProductCustomCategoryUpdateArgs} args - Arguments to update one ProductCustomCategory.
     * @example
     * // Update one ProductCustomCategory
     * const productCustomCategory = await prisma.productCustomCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCustomCategoryUpdateArgs>(args: SelectSubset<T, ProductCustomCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCustomCategoryClient<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductCustomCategories.
     * @param {ProductCustomCategoryDeleteManyArgs} args - Arguments to filter ProductCustomCategories to delete.
     * @example
     * // Delete a few ProductCustomCategories
     * const { count } = await prisma.productCustomCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCustomCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCustomCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCustomCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCustomCategories
     * const productCustomCategory = await prisma.productCustomCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCustomCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCustomCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCustomCategory.
     * @param {ProductCustomCategoryUpsertArgs} args - Arguments to update or create a ProductCustomCategory.
     * @example
     * // Update or create a ProductCustomCategory
     * const productCustomCategory = await prisma.productCustomCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCustomCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCustomCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCustomCategoryUpsertArgs>(args: SelectSubset<T, ProductCustomCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCustomCategoryClient<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductCustomCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomCategoryCountArgs} args - Arguments to filter ProductCustomCategories to count.
     * @example
     * // Count the number of ProductCustomCategories
     * const count = await prisma.productCustomCategory.count({
     *   where: {
     *     // ... the filter for the ProductCustomCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCustomCategoryCountArgs>(
      args?: Subset<T, ProductCustomCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCustomCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCustomCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCustomCategoryAggregateArgs>(args: Subset<T, ProductCustomCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCustomCategoryAggregateType<T>>

    /**
     * Group by ProductCustomCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCustomCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCustomCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCustomCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCustomCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCustomCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCustomCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCustomCategory model
   */
  readonly fields: ProductCustomCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCustomCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCustomCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductCustomCategory$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductCustomCategory$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCustomCategory model
   */ 
  interface ProductCustomCategoryFieldRefs {
    readonly id: FieldRef<"ProductCustomCategory", 'String'>
    readonly created_at: FieldRef<"ProductCustomCategory", 'DateTime'>
    readonly updated_at: FieldRef<"ProductCustomCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCustomCategory findUnique
   */
  export type ProductCustomCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomCategory to fetch.
     */
    where: ProductCustomCategoryWhereUniqueInput
  }

  /**
   * ProductCustomCategory findUniqueOrThrow
   */
  export type ProductCustomCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomCategory to fetch.
     */
    where: ProductCustomCategoryWhereUniqueInput
  }

  /**
   * ProductCustomCategory findFirst
   */
  export type ProductCustomCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomCategory to fetch.
     */
    where?: ProductCustomCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCustomCategories to fetch.
     */
    orderBy?: ProductCustomCategoryOrderByWithRelationInput | ProductCustomCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCustomCategories.
     */
    cursor?: ProductCustomCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCustomCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCustomCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCustomCategories.
     */
    distinct?: ProductCustomCategoryScalarFieldEnum | ProductCustomCategoryScalarFieldEnum[]
  }

  /**
   * ProductCustomCategory findFirstOrThrow
   */
  export type ProductCustomCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomCategory to fetch.
     */
    where?: ProductCustomCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCustomCategories to fetch.
     */
    orderBy?: ProductCustomCategoryOrderByWithRelationInput | ProductCustomCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCustomCategories.
     */
    cursor?: ProductCustomCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCustomCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCustomCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCustomCategories.
     */
    distinct?: ProductCustomCategoryScalarFieldEnum | ProductCustomCategoryScalarFieldEnum[]
  }

  /**
   * ProductCustomCategory findMany
   */
  export type ProductCustomCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCustomCategories to fetch.
     */
    where?: ProductCustomCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCustomCategories to fetch.
     */
    orderBy?: ProductCustomCategoryOrderByWithRelationInput | ProductCustomCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCustomCategories.
     */
    cursor?: ProductCustomCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCustomCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCustomCategories.
     */
    skip?: number
    distinct?: ProductCustomCategoryScalarFieldEnum | ProductCustomCategoryScalarFieldEnum[]
  }

  /**
   * ProductCustomCategory create
   */
  export type ProductCustomCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCustomCategory.
     */
    data?: XOR<ProductCustomCategoryCreateInput, ProductCustomCategoryUncheckedCreateInput>
  }

  /**
   * ProductCustomCategory createMany
   */
  export type ProductCustomCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCustomCategories.
     */
    data: ProductCustomCategoryCreateManyInput | ProductCustomCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCustomCategory createManyAndReturn
   */
  export type ProductCustomCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductCustomCategories.
     */
    data: ProductCustomCategoryCreateManyInput | ProductCustomCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCustomCategory update
   */
  export type ProductCustomCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCustomCategory.
     */
    data: XOR<ProductCustomCategoryUpdateInput, ProductCustomCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCustomCategory to update.
     */
    where: ProductCustomCategoryWhereUniqueInput
  }

  /**
   * ProductCustomCategory updateMany
   */
  export type ProductCustomCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCustomCategories.
     */
    data: XOR<ProductCustomCategoryUpdateManyMutationInput, ProductCustomCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCustomCategories to update
     */
    where?: ProductCustomCategoryWhereInput
  }

  /**
   * ProductCustomCategory upsert
   */
  export type ProductCustomCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCustomCategory to update in case it exists.
     */
    where: ProductCustomCategoryWhereUniqueInput
    /**
     * In case the ProductCustomCategory found by the `where` argument doesn't exist, create a new ProductCustomCategory with this data.
     */
    create: XOR<ProductCustomCategoryCreateInput, ProductCustomCategoryUncheckedCreateInput>
    /**
     * In case the ProductCustomCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCustomCategoryUpdateInput, ProductCustomCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCustomCategory delete
   */
  export type ProductCustomCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCustomCategory to delete.
     */
    where: ProductCustomCategoryWhereUniqueInput
  }

  /**
   * ProductCustomCategory deleteMany
   */
  export type ProductCustomCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCustomCategories to delete
     */
    where?: ProductCustomCategoryWhereInput
  }

  /**
   * ProductCustomCategory.product
   */
  export type ProductCustomCategory$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCustomCategory without action
   */
  export type ProductCustomCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    cross_docking_days: number | null
    height: number | null
    length: number | null
    cost_price: number | null
    manufacturer_part_number: number | null
    price: number | null
    stock: number | null
    warranty: number | null
    weight: number | null
    width: number | null
    unit_multiplier: number | null
    sale_price: number | null
  }

  export type ProductSumAggregateOutputType = {
    cross_docking_days: number | null
    height: number | null
    length: number | null
    cost_price: number | null
    manufacturer_part_number: number | null
    price: number | null
    stock: number | null
    warranty: number | null
    weight: number | null
    width: number | null
    unit_multiplier: number | null
    sale_price: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sku: string | null
    active: boolean | null
    brand: string | null
    category_id: string | null
    color_id: string | null
    cross_docking_days: number | null
    description: string | null
    gender: string | null
    height: number | null
    length: number | null
    ean: string | null
    cost_price: number | null
    manufacturer_part_number: number | null
    model: string | null
    name: string | null
    origin: string | null
    ncm: string | null
    price: number | null
    product_name: string | null
    size_id: string | null
    stock: number | null
    warranty: number | null
    weight: number | null
    width: number | null
    custom_category_id: string | null
    flavor_id: string | null
    measurement_unit: string | null
    unit_multiplier: number | null
    power_id: string | null
    sale_price: number | null
    sale_date_start: Date | null
    sale_date_end: Date | null
    voltage_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sku: string | null
    active: boolean | null
    brand: string | null
    category_id: string | null
    color_id: string | null
    cross_docking_days: number | null
    description: string | null
    gender: string | null
    height: number | null
    length: number | null
    ean: string | null
    cost_price: number | null
    manufacturer_part_number: number | null
    model: string | null
    name: string | null
    origin: string | null
    ncm: string | null
    price: number | null
    product_name: string | null
    size_id: string | null
    stock: number | null
    warranty: number | null
    weight: number | null
    width: number | null
    custom_category_id: string | null
    flavor_id: string | null
    measurement_unit: string | null
    unit_multiplier: number | null
    power_id: string | null
    sale_price: number | null
    sale_date_start: Date | null
    sale_date_end: Date | null
    voltage_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sku: number
    active: number
    brand: number
    category_id: number
    color_id: number
    cross_docking_days: number
    description: number
    gender: number
    height: number
    length: number
    images: number
    ean: number
    cost_price: number
    manufacturer_part_number: number
    model: number
    name: number
    origin: number
    ncm: number
    price: number
    product_name: number
    size_id: number
    stock: number
    warranty: number
    weight: number
    width: number
    custom_category_id: number
    flavor_id: number
    measurement_unit: number
    unit_multiplier: number
    meta_fields: number
    power_id: number
    sale_price: number
    sale_date_start: number
    sale_date_end: number
    voltage_id: number
    videos: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    cross_docking_days?: true
    height?: true
    length?: true
    cost_price?: true
    manufacturer_part_number?: true
    price?: true
    stock?: true
    warranty?: true
    weight?: true
    width?: true
    unit_multiplier?: true
    sale_price?: true
  }

  export type ProductSumAggregateInputType = {
    cross_docking_days?: true
    height?: true
    length?: true
    cost_price?: true
    manufacturer_part_number?: true
    price?: true
    stock?: true
    warranty?: true
    weight?: true
    width?: true
    unit_multiplier?: true
    sale_price?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sku?: true
    active?: true
    brand?: true
    category_id?: true
    color_id?: true
    cross_docking_days?: true
    description?: true
    gender?: true
    height?: true
    length?: true
    ean?: true
    cost_price?: true
    manufacturer_part_number?: true
    model?: true
    name?: true
    origin?: true
    ncm?: true
    price?: true
    product_name?: true
    size_id?: true
    stock?: true
    warranty?: true
    weight?: true
    width?: true
    custom_category_id?: true
    flavor_id?: true
    measurement_unit?: true
    unit_multiplier?: true
    power_id?: true
    sale_price?: true
    sale_date_start?: true
    sale_date_end?: true
    voltage_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sku?: true
    active?: true
    brand?: true
    category_id?: true
    color_id?: true
    cross_docking_days?: true
    description?: true
    gender?: true
    height?: true
    length?: true
    ean?: true
    cost_price?: true
    manufacturer_part_number?: true
    model?: true
    name?: true
    origin?: true
    ncm?: true
    price?: true
    product_name?: true
    size_id?: true
    stock?: true
    warranty?: true
    weight?: true
    width?: true
    custom_category_id?: true
    flavor_id?: true
    measurement_unit?: true
    unit_multiplier?: true
    power_id?: true
    sale_price?: true
    sale_date_start?: true
    sale_date_end?: true
    voltage_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sku?: true
    active?: true
    brand?: true
    category_id?: true
    color_id?: true
    cross_docking_days?: true
    description?: true
    gender?: true
    height?: true
    length?: true
    images?: true
    ean?: true
    cost_price?: true
    manufacturer_part_number?: true
    model?: true
    name?: true
    origin?: true
    ncm?: true
    price?: true
    product_name?: true
    size_id?: true
    stock?: true
    warranty?: true
    weight?: true
    width?: true
    custom_category_id?: true
    flavor_id?: true
    measurement_unit?: true
    unit_multiplier?: true
    meta_fields?: true
    power_id?: true
    sale_price?: true
    sale_date_start?: true
    sale_date_end?: true
    voltage_id?: true
    videos?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sku: string
    active: boolean | null
    brand: string | null
    category_id: string
    color_id: string | null
    cross_docking_days: number | null
    description: string
    gender: string | null
    height: number
    length: number
    images: string[]
    ean: string | null
    cost_price: number | null
    manufacturer_part_number: number | null
    model: string | null
    name: string
    origin: string | null
    ncm: string | null
    price: number
    product_name: string | null
    size_id: string | null
    stock: number
    warranty: number | null
    weight: number
    width: number
    custom_category_id: string | null
    flavor_id: string | null
    measurement_unit: string | null
    unit_multiplier: number | null
    meta_fields: JsonValue[]
    power_id: string | null
    sale_price: number | null
    sale_date_start: Date | null
    sale_date_end: Date | null
    voltage_id: string | null
    videos: string[]
    created_at: Date
    updated_at: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    active?: boolean
    brand?: boolean
    category_id?: boolean
    color_id?: boolean
    cross_docking_days?: boolean
    description?: boolean
    gender?: boolean
    height?: boolean
    length?: boolean
    images?: boolean
    ean?: boolean
    cost_price?: boolean
    manufacturer_part_number?: boolean
    model?: boolean
    name?: boolean
    origin?: boolean
    ncm?: boolean
    price?: boolean
    product_name?: boolean
    size_id?: boolean
    stock?: boolean
    warranty?: boolean
    weight?: boolean
    width?: boolean
    custom_category_id?: boolean
    flavor_id?: boolean
    measurement_unit?: boolean
    unit_multiplier?: boolean
    meta_fields?: boolean
    power_id?: boolean
    sale_price?: boolean
    sale_date_start?: boolean
    sale_date_end?: boolean
    voltage_id?: boolean
    videos?: boolean
    created_at?: boolean
    updated_at?: boolean
    sales_channels?: boolean | Product$sales_channelsArgs<ExtArgs>
    product_color?: boolean | Product$product_colorArgs<ExtArgs>
    product_category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    product_size?: boolean | Product$product_sizeArgs<ExtArgs>
    product_custom_category?: boolean | Product$product_custom_categoryArgs<ExtArgs>
    product_flavor?: boolean | Product$product_flavorArgs<ExtArgs>
    product_power?: boolean | Product$product_powerArgs<ExtArgs>
    produt_voltage?: boolean | Product$produt_voltageArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sku?: boolean
    active?: boolean
    brand?: boolean
    category_id?: boolean
    color_id?: boolean
    cross_docking_days?: boolean
    description?: boolean
    gender?: boolean
    height?: boolean
    length?: boolean
    images?: boolean
    ean?: boolean
    cost_price?: boolean
    manufacturer_part_number?: boolean
    model?: boolean
    name?: boolean
    origin?: boolean
    ncm?: boolean
    price?: boolean
    product_name?: boolean
    size_id?: boolean
    stock?: boolean
    warranty?: boolean
    weight?: boolean
    width?: boolean
    custom_category_id?: boolean
    flavor_id?: boolean
    measurement_unit?: boolean
    unit_multiplier?: boolean
    meta_fields?: boolean
    power_id?: boolean
    sale_price?: boolean
    sale_date_start?: boolean
    sale_date_end?: boolean
    voltage_id?: boolean
    videos?: boolean
    created_at?: boolean
    updated_at?: boolean
    product_color?: boolean | Product$product_colorArgs<ExtArgs>
    product_category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    product_size?: boolean | Product$product_sizeArgs<ExtArgs>
    product_custom_category?: boolean | Product$product_custom_categoryArgs<ExtArgs>
    product_flavor?: boolean | Product$product_flavorArgs<ExtArgs>
    product_power?: boolean | Product$product_powerArgs<ExtArgs>
    produt_voltage?: boolean | Product$produt_voltageArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sku?: boolean
    active?: boolean
    brand?: boolean
    category_id?: boolean
    color_id?: boolean
    cross_docking_days?: boolean
    description?: boolean
    gender?: boolean
    height?: boolean
    length?: boolean
    images?: boolean
    ean?: boolean
    cost_price?: boolean
    manufacturer_part_number?: boolean
    model?: boolean
    name?: boolean
    origin?: boolean
    ncm?: boolean
    price?: boolean
    product_name?: boolean
    size_id?: boolean
    stock?: boolean
    warranty?: boolean
    weight?: boolean
    width?: boolean
    custom_category_id?: boolean
    flavor_id?: boolean
    measurement_unit?: boolean
    unit_multiplier?: boolean
    meta_fields?: boolean
    power_id?: boolean
    sale_price?: boolean
    sale_date_start?: boolean
    sale_date_end?: boolean
    voltage_id?: boolean
    videos?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales_channels?: boolean | Product$sales_channelsArgs<ExtArgs>
    product_color?: boolean | Product$product_colorArgs<ExtArgs>
    product_category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    product_size?: boolean | Product$product_sizeArgs<ExtArgs>
    product_custom_category?: boolean | Product$product_custom_categoryArgs<ExtArgs>
    product_flavor?: boolean | Product$product_flavorArgs<ExtArgs>
    product_power?: boolean | Product$product_powerArgs<ExtArgs>
    produt_voltage?: boolean | Product$produt_voltageArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_color?: boolean | Product$product_colorArgs<ExtArgs>
    product_category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    product_size?: boolean | Product$product_sizeArgs<ExtArgs>
    product_custom_category?: boolean | Product$product_custom_categoryArgs<ExtArgs>
    product_flavor?: boolean | Product$product_flavorArgs<ExtArgs>
    product_power?: boolean | Product$product_powerArgs<ExtArgs>
    produt_voltage?: boolean | Product$produt_voltageArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      sales_channels: Prisma.$SaleChannelPayload<ExtArgs>[]
      product_color: Prisma.$ProductColorPayload<ExtArgs> | null
      product_category: Prisma.$ProductCategoryPayload<ExtArgs>
      product_size: Prisma.$ProductSizePayload<ExtArgs> | null
      product_custom_category: Prisma.$ProductCustomCategoryPayload<ExtArgs> | null
      product_flavor: Prisma.$ProductFlavorPayload<ExtArgs> | null
      product_power: Prisma.$ProductPowerPayload<ExtArgs> | null
      produt_voltage: Prisma.$ProductVoltagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sku: string
      active: boolean | null
      brand: string | null
      category_id: string
      color_id: string | null
      cross_docking_days: number | null
      description: string
      gender: string | null
      height: number
      length: number
      images: string[]
      ean: string | null
      cost_price: number | null
      manufacturer_part_number: number | null
      model: string | null
      name: string
      origin: string | null
      ncm: string | null
      price: number
      product_name: string | null
      size_id: string | null
      stock: number
      warranty: number | null
      weight: number
      width: number
      custom_category_id: string | null
      flavor_id: string | null
      measurement_unit: string | null
      unit_multiplier: number | null
      meta_fields: Prisma.JsonValue[]
      power_id: string | null
      sale_price: number | null
      sale_date_start: Date | null
      sale_date_end: Date | null
      voltage_id: string | null
      videos: string[]
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sales_channels<T extends Product$sales_channelsArgs<ExtArgs> = {}>(args?: Subset<T, Product$sales_channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleChannelPayload<ExtArgs>, T, "findMany"> | Null>
    product_color<T extends Product$product_colorArgs<ExtArgs> = {}>(args?: Subset<T, Product$product_colorArgs<ExtArgs>>): Prisma__ProductColorClient<$Result.GetResult<Prisma.$ProductColorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    product_category<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product_size<T extends Product$product_sizeArgs<ExtArgs> = {}>(args?: Subset<T, Product$product_sizeArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    product_custom_category<T extends Product$product_custom_categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$product_custom_categoryArgs<ExtArgs>>): Prisma__ProductCustomCategoryClient<$Result.GetResult<Prisma.$ProductCustomCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    product_flavor<T extends Product$product_flavorArgs<ExtArgs> = {}>(args?: Subset<T, Product$product_flavorArgs<ExtArgs>>): Prisma__ProductFlavorClient<$Result.GetResult<Prisma.$ProductFlavorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    product_power<T extends Product$product_powerArgs<ExtArgs> = {}>(args?: Subset<T, Product$product_powerArgs<ExtArgs>>): Prisma__ProductPowerClient<$Result.GetResult<Prisma.$ProductPowerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    produt_voltage<T extends Product$produt_voltageArgs<ExtArgs> = {}>(args?: Subset<T, Product$produt_voltageArgs<ExtArgs>>): Prisma__ProductVoltageClient<$Result.GetResult<Prisma.$ProductVoltagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly active: FieldRef<"Product", 'Boolean'>
    readonly brand: FieldRef<"Product", 'String'>
    readonly category_id: FieldRef<"Product", 'String'>
    readonly color_id: FieldRef<"Product", 'String'>
    readonly cross_docking_days: FieldRef<"Product", 'Int'>
    readonly description: FieldRef<"Product", 'String'>
    readonly gender: FieldRef<"Product", 'String'>
    readonly height: FieldRef<"Product", 'Int'>
    readonly length: FieldRef<"Product", 'Int'>
    readonly images: FieldRef<"Product", 'String[]'>
    readonly ean: FieldRef<"Product", 'String'>
    readonly cost_price: FieldRef<"Product", 'Int'>
    readonly manufacturer_part_number: FieldRef<"Product", 'Int'>
    readonly model: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly origin: FieldRef<"Product", 'String'>
    readonly ncm: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly product_name: FieldRef<"Product", 'String'>
    readonly size_id: FieldRef<"Product", 'String'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly warranty: FieldRef<"Product", 'Int'>
    readonly weight: FieldRef<"Product", 'Int'>
    readonly width: FieldRef<"Product", 'Int'>
    readonly custom_category_id: FieldRef<"Product", 'String'>
    readonly flavor_id: FieldRef<"Product", 'String'>
    readonly measurement_unit: FieldRef<"Product", 'String'>
    readonly unit_multiplier: FieldRef<"Product", 'Int'>
    readonly meta_fields: FieldRef<"Product", 'Json[]'>
    readonly power_id: FieldRef<"Product", 'String'>
    readonly sale_price: FieldRef<"Product", 'Float'>
    readonly sale_date_start: FieldRef<"Product", 'DateTime'>
    readonly sale_date_end: FieldRef<"Product", 'DateTime'>
    readonly voltage_id: FieldRef<"Product", 'String'>
    readonly videos: FieldRef<"Product", 'String[]'>
    readonly created_at: FieldRef<"Product", 'DateTime'>
    readonly updated_at: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.sales_channels
   */
  export type Product$sales_channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleChannel
     */
    select?: SaleChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleChannelInclude<ExtArgs> | null
    where?: SaleChannelWhereInput
    orderBy?: SaleChannelOrderByWithRelationInput | SaleChannelOrderByWithRelationInput[]
    cursor?: SaleChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleChannelScalarFieldEnum | SaleChannelScalarFieldEnum[]
  }

  /**
   * Product.product_color
   */
  export type Product$product_colorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductColor
     */
    select?: ProductColorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductColorInclude<ExtArgs> | null
    where?: ProductColorWhereInput
  }

  /**
   * Product.product_size
   */
  export type Product$product_sizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSizeInclude<ExtArgs> | null
    where?: ProductSizeWhereInput
  }

  /**
   * Product.product_custom_category
   */
  export type Product$product_custom_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCustomCategory
     */
    select?: ProductCustomCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCustomCategoryInclude<ExtArgs> | null
    where?: ProductCustomCategoryWhereInput
  }

  /**
   * Product.product_flavor
   */
  export type Product$product_flavorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductFlavor
     */
    select?: ProductFlavorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductFlavorInclude<ExtArgs> | null
    where?: ProductFlavorWhereInput
  }

  /**
   * Product.product_power
   */
  export type Product$product_powerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductPower
     */
    select?: ProductPowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductPowerInclude<ExtArgs> | null
    where?: ProductPowerWhereInput
  }

  /**
   * Product.produt_voltage
   */
  export type Product$produt_voltageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVoltage
     */
    select?: ProductVoltageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVoltageInclude<ExtArgs> | null
    where?: ProductVoltageWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    gender: 'gender',
    phone: 'phone',
    active: 'active',
    visitor: 'visitor',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    zip_code: 'zip_code',
    active: 'active',
    business_name: 'business_name',
    address_one: 'address_one',
    address_two: 'address_two',
    fantasy_name: 'fantasy_name',
    email: 'email',
    phone_number: 'phone_number',
    website: 'website',
    registration_number: 'registration_number',
    slug: 'slug',
    owner_id: 'owner_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    profile_avatar: 'profile_avatar',
    profile_cover: 'profile_cover',
    user_id: 'user_id',
    organization_id: 'organization_id',
    username: 'username',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    user_id: 'user_id',
    role: 'role',
    organization_id: 'organization_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    second_name: 'second_name',
    whatsapp: 'whatsapp',
    shop_name: 'shop_name',
    address_line_one: 'address_line_one',
    address_line_two: 'address_line_two',
    email: 'email',
    second_phone: 'second_phone',
    vat_rate_id: 'vat_rate_id',
    currency_id: 'currency_id',
    agent_id: 'agent_id',
    active: 'active',
    organization_id: 'organization_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const OperationMessageScalarFieldEnum: {
    message: 'message',
    type: 'type',
    active: 'active',
    created_at: 'created_at',
    updated_at: 'updated_at',
    id: 'id'
  };

  export type OperationMessageScalarFieldEnum = (typeof OperationMessageScalarFieldEnum)[keyof typeof OperationMessageScalarFieldEnum]


  export const OperationMessageTranslationScalarFieldEnum: {
    language_code: 'language_code',
    message: 'message',
    created_at: 'created_at',
    updated_at: 'updated_at',
    operation_message_id: 'operation_message_id'
  };

  export type OperationMessageTranslationScalarFieldEnum = (typeof OperationMessageTranslationScalarFieldEnum)[keyof typeof OperationMessageTranslationScalarFieldEnum]


  export const InviteCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    expires_at: 'expires_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    used: 'used',
    organization_id: 'organization_id'
  };

  export type InviteCodeScalarFieldEnum = (typeof InviteCodeScalarFieldEnum)[keyof typeof InviteCodeScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    full_name: 'full_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductColorScalarFieldEnum: {
    id: 'id',
    attribute_name: 'attribute_name',
    attribute_type: 'attribute_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductColorScalarFieldEnum = (typeof ProductColorScalarFieldEnum)[keyof typeof ProductColorScalarFieldEnum]


  export const ProductSizeScalarFieldEnum: {
    id: 'id',
    attribute_name: 'attribute_name',
    attribute_type: 'attribute_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductSizeScalarFieldEnum = (typeof ProductSizeScalarFieldEnum)[keyof typeof ProductSizeScalarFieldEnum]


  export const ProductVoltageScalarFieldEnum: {
    id: 'id',
    attribute_name: 'attribute_name',
    attribute_type: 'attribute_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductVoltageScalarFieldEnum = (typeof ProductVoltageScalarFieldEnum)[keyof typeof ProductVoltageScalarFieldEnum]


  export const ProductFlavorScalarFieldEnum: {
    id: 'id',
    attribute_name: 'attribute_name',
    attribute_type: 'attribute_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductFlavorScalarFieldEnum = (typeof ProductFlavorScalarFieldEnum)[keyof typeof ProductFlavorScalarFieldEnum]


  export const ProductPowerScalarFieldEnum: {
    id: 'id',
    attribute_name: 'attribute_name',
    attribute_type: 'attribute_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductPowerScalarFieldEnum = (typeof ProductPowerScalarFieldEnum)[keyof typeof ProductPowerScalarFieldEnum]


  export const SaleChannelScalarFieldEnum: {
    id: 'id',
    sale_channel: 'sale_channel',
    code: 'code',
    channel_type: 'channel_type',
    product_id: 'product_id',
    sale_price: 'sale_price',
    sale_date_start: 'sale_date_start',
    sale_date_end: 'sale_date_end',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SaleChannelScalarFieldEnum = (typeof SaleChannelScalarFieldEnum)[keyof typeof SaleChannelScalarFieldEnum]


  export const ProductCustomCategoryScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductCustomCategoryScalarFieldEnum = (typeof ProductCustomCategoryScalarFieldEnum)[keyof typeof ProductCustomCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sku: 'sku',
    active: 'active',
    brand: 'brand',
    category_id: 'category_id',
    color_id: 'color_id',
    cross_docking_days: 'cross_docking_days',
    description: 'description',
    gender: 'gender',
    height: 'height',
    length: 'length',
    images: 'images',
    ean: 'ean',
    cost_price: 'cost_price',
    manufacturer_part_number: 'manufacturer_part_number',
    model: 'model',
    name: 'name',
    origin: 'origin',
    ncm: 'ncm',
    price: 'price',
    product_name: 'product_name',
    size_id: 'size_id',
    stock: 'stock',
    warranty: 'warranty',
    weight: 'weight',
    width: 'width',
    custom_category_id: 'custom_category_id',
    flavor_id: 'flavor_id',
    measurement_unit: 'measurement_unit',
    unit_multiplier: 'unit_multiplier',
    meta_fields: 'meta_fields',
    power_id: 'power_id',
    sale_price: 'sale_price',
    sale_date_start: 'sale_date_start',
    sale_date_end: 'sale_date_end',
    voltage_id: 'voltage_id',
    videos: 'videos',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    gender?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    active?: BoolFilter<"User"> | boolean
    visitor?: BoolNullableFilter<"User"> | boolean | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    user_organizations?: OrganizationListRelationFilter
    teams?: MemberListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    active?: SortOrder
    visitor?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_organizations?: OrganizationOrderByRelationAggregateInput
    teams?: MemberOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    first_name?: string
    last_name?: string
    gender?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    active?: BoolFilter<"User"> | boolean
    visitor?: BoolNullableFilter<"User"> | boolean | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    user_organizations?: OrganizationListRelationFilter
    teams?: MemberListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
  }, "id" | "email" | "first_name" | "last_name" | "gender" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    active?: SortOrder
    visitor?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    first_name?: StringWithAggregatesFilter<"User"> | string
    last_name?: StringWithAggregatesFilter<"User"> | string
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    active?: BoolWithAggregatesFilter<"User"> | boolean
    visitor?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: UuidFilter<"Organization"> | string
    zip_code?: StringNullableFilter<"Organization"> | string | null
    active?: BoolFilter<"Organization"> | boolean
    business_name?: StringFilter<"Organization"> | string
    address_one?: StringNullableFilter<"Organization"> | string | null
    address_two?: StringNullableFilter<"Organization"> | string | null
    fantasy_name?: StringFilter<"Organization"> | string
    email?: StringFilter<"Organization"> | string
    phone_number?: StringFilter<"Organization"> | string
    website?: StringNullableFilter<"Organization"> | string | null
    registration_number?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    owner_id?: UuidFilter<"Organization"> | string
    created_at?: DateTimeFilter<"Organization"> | Date | string
    updated_at?: DateTimeFilter<"Organization"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    members?: MemberListRelationFilter
    customer?: CustomerListRelationFilter
    invite_code?: InviteCodeListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    zip_code?: SortOrderInput | SortOrder
    active?: SortOrder
    business_name?: SortOrder
    address_one?: SortOrderInput | SortOrder
    address_two?: SortOrderInput | SortOrder
    fantasy_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    website?: SortOrderInput | SortOrder
    registration_number?: SortOrder
    slug?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    owner?: UserOrderByWithRelationInput
    members?: MemberOrderByRelationAggregateInput
    customer?: CustomerOrderByRelationAggregateInput
    invite_code?: InviteCodeOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    registration_number?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    zip_code?: StringNullableFilter<"Organization"> | string | null
    active?: BoolFilter<"Organization"> | boolean
    business_name?: StringFilter<"Organization"> | string
    address_one?: StringNullableFilter<"Organization"> | string | null
    address_two?: StringNullableFilter<"Organization"> | string | null
    fantasy_name?: StringFilter<"Organization"> | string
    email?: StringFilter<"Organization"> | string
    phone_number?: StringFilter<"Organization"> | string
    website?: StringNullableFilter<"Organization"> | string | null
    owner_id?: UuidFilter<"Organization"> | string
    created_at?: DateTimeFilter<"Organization"> | Date | string
    updated_at?: DateTimeFilter<"Organization"> | Date | string
    owner?: XOR<UserRelationFilter, UserWhereInput>
    members?: MemberListRelationFilter
    customer?: CustomerListRelationFilter
    invite_code?: InviteCodeListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
  }, "id" | "registration_number" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    zip_code?: SortOrderInput | SortOrder
    active?: SortOrder
    business_name?: SortOrder
    address_one?: SortOrderInput | SortOrder
    address_two?: SortOrderInput | SortOrder
    fantasy_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    website?: SortOrderInput | SortOrder
    registration_number?: SortOrder
    slug?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Organization"> | string
    zip_code?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    active?: BoolWithAggregatesFilter<"Organization"> | boolean
    business_name?: StringWithAggregatesFilter<"Organization"> | string
    address_one?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    address_two?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    fantasy_name?: StringWithAggregatesFilter<"Organization"> | string
    email?: StringWithAggregatesFilter<"Organization"> | string
    phone_number?: StringWithAggregatesFilter<"Organization"> | string
    website?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    registration_number?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    owner_id?: UuidWithAggregatesFilter<"Organization"> | string
    created_at?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: UuidFilter<"Profile"> | string
    profile_avatar?: StringNullableFilter<"Profile"> | string | null
    profile_cover?: StringNullableFilter<"Profile"> | string | null
    user_id?: UuidNullableFilter<"Profile"> | string | null
    organization_id?: UuidNullableFilter<"Profile"> | string | null
    username?: StringFilter<"Profile"> | string
    description?: StringNullableFilter<"Profile"> | string | null
    created_at?: DateTimeFilter<"Profile"> | Date | string
    updated_at?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    profile_avatar?: SortOrderInput | SortOrder
    profile_cover?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    organization_id?: SortOrderInput | SortOrder
    username?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    organization_id?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    profile_avatar?: StringNullableFilter<"Profile"> | string | null
    profile_cover?: StringNullableFilter<"Profile"> | string | null
    username?: StringFilter<"Profile"> | string
    description?: StringNullableFilter<"Profile"> | string | null
    created_at?: DateTimeFilter<"Profile"> | Date | string
    updated_at?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
  }, "id" | "user_id" | "organization_id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    profile_avatar?: SortOrderInput | SortOrder
    profile_cover?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    organization_id?: SortOrderInput | SortOrder
    username?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Profile"> | string
    profile_avatar?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    profile_cover?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    user_id?: UuidNullableWithAggregatesFilter<"Profile"> | string | null
    organization_id?: UuidNullableWithAggregatesFilter<"Profile"> | string | null
    username?: StringWithAggregatesFilter<"Profile"> | string
    description?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    user_id?: UuidFilter<"Member"> | string
    role?: EnumRoleFilter<"Member"> | $Enums.Role
    organization_id?: UuidFilter<"Member"> | string
    created_at?: DateTimeFilter<"Member"> | Date | string
    updated_at?: DateTimeFilter<"Member"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type MemberOrderByWithRelationInput = {
    user_id?: SortOrder
    role?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    organization_id_user_id?: MemberOrganization_idUser_idCompoundUniqueInput
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    user_id?: UuidFilter<"Member"> | string
    role?: EnumRoleFilter<"Member"> | $Enums.Role
    organization_id?: UuidFilter<"Member"> | string
    created_at?: DateTimeFilter<"Member"> | Date | string
    updated_at?: DateTimeFilter<"Member"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "organization_id_user_id">

  export type MemberOrderByWithAggregationInput = {
    user_id?: SortOrder
    role?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    user_id?: UuidWithAggregatesFilter<"Member"> | string
    role?: EnumRoleWithAggregatesFilter<"Member"> | $Enums.Role
    organization_id?: UuidWithAggregatesFilter<"Member"> | string
    created_at?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Member"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: UuidFilter<"Customer"> | string
    name?: StringNullableFilter<"Customer"> | string | null
    second_name?: StringNullableFilter<"Customer"> | string | null
    whatsapp?: StringNullableFilter<"Customer"> | string | null
    shop_name?: StringFilter<"Customer"> | string
    address_line_one?: StringNullableFilter<"Customer"> | string | null
    address_line_two?: StringNullableFilter<"Customer"> | string | null
    email?: StringFilter<"Customer"> | string
    second_phone?: StringNullableFilter<"Customer"> | string | null
    vat_rate_id?: UuidFilter<"Customer"> | string
    currency_id?: UuidFilter<"Customer"> | string
    agent_id?: UuidFilter<"Customer"> | string
    active?: BoolFilter<"Customer"> | boolean
    organization_id?: UuidFilter<"Customer"> | string
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    second_name?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    shop_name?: SortOrder
    address_line_one?: SortOrderInput | SortOrder
    address_line_two?: SortOrderInput | SortOrder
    email?: SortOrder
    second_phone?: SortOrderInput | SortOrder
    vat_rate_id?: SortOrder
    currency_id?: SortOrder
    agent_id?: SortOrder
    active?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringNullableFilter<"Customer"> | string | null
    second_name?: StringNullableFilter<"Customer"> | string | null
    whatsapp?: StringNullableFilter<"Customer"> | string | null
    shop_name?: StringFilter<"Customer"> | string
    address_line_one?: StringNullableFilter<"Customer"> | string | null
    address_line_two?: StringNullableFilter<"Customer"> | string | null
    second_phone?: StringNullableFilter<"Customer"> | string | null
    vat_rate_id?: UuidFilter<"Customer"> | string
    currency_id?: UuidFilter<"Customer"> | string
    agent_id?: UuidFilter<"Customer"> | string
    active?: BoolFilter<"Customer"> | boolean
    organization_id?: UuidFilter<"Customer"> | string
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    second_name?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    shop_name?: SortOrder
    address_line_one?: SortOrderInput | SortOrder
    address_line_two?: SortOrderInput | SortOrder
    email?: SortOrder
    second_phone?: SortOrderInput | SortOrder
    vat_rate_id?: SortOrder
    currency_id?: SortOrder
    agent_id?: SortOrder
    active?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Customer"> | string
    name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    second_name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    whatsapp?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    shop_name?: StringWithAggregatesFilter<"Customer"> | string
    address_line_one?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address_line_two?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringWithAggregatesFilter<"Customer"> | string
    second_phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    vat_rate_id?: UuidWithAggregatesFilter<"Customer"> | string
    currency_id?: UuidWithAggregatesFilter<"Customer"> | string
    agent_id?: UuidWithAggregatesFilter<"Customer"> | string
    active?: BoolWithAggregatesFilter<"Customer"> | boolean
    organization_id?: UuidWithAggregatesFilter<"Customer"> | string
    created_at?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type OperationMessageWhereInput = {
    AND?: OperationMessageWhereInput | OperationMessageWhereInput[]
    OR?: OperationMessageWhereInput[]
    NOT?: OperationMessageWhereInput | OperationMessageWhereInput[]
    message?: StringFilter<"OperationMessage"> | string
    type?: StringFilter<"OperationMessage"> | string
    active?: BoolFilter<"OperationMessage"> | boolean
    created_at?: DateTimeFilter<"OperationMessage"> | Date | string
    updated_at?: DateTimeFilter<"OperationMessage"> | Date | string
    id?: StringFilter<"OperationMessage"> | string
    operation_message_translations?: OperationMessageTranslationListRelationFilter
  }

  export type OperationMessageOrderByWithRelationInput = {
    message?: SortOrder
    type?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    operation_message_translations?: OperationMessageTranslationOrderByRelationAggregateInput
  }

  export type OperationMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OperationMessageWhereInput | OperationMessageWhereInput[]
    OR?: OperationMessageWhereInput[]
    NOT?: OperationMessageWhereInput | OperationMessageWhereInput[]
    message?: StringFilter<"OperationMessage"> | string
    type?: StringFilter<"OperationMessage"> | string
    active?: BoolFilter<"OperationMessage"> | boolean
    created_at?: DateTimeFilter<"OperationMessage"> | Date | string
    updated_at?: DateTimeFilter<"OperationMessage"> | Date | string
    operation_message_translations?: OperationMessageTranslationListRelationFilter
  }, "id">

  export type OperationMessageOrderByWithAggregationInput = {
    message?: SortOrder
    type?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
    _count?: OperationMessageCountOrderByAggregateInput
    _max?: OperationMessageMaxOrderByAggregateInput
    _min?: OperationMessageMinOrderByAggregateInput
  }

  export type OperationMessageScalarWhereWithAggregatesInput = {
    AND?: OperationMessageScalarWhereWithAggregatesInput | OperationMessageScalarWhereWithAggregatesInput[]
    OR?: OperationMessageScalarWhereWithAggregatesInput[]
    NOT?: OperationMessageScalarWhereWithAggregatesInput | OperationMessageScalarWhereWithAggregatesInput[]
    message?: StringWithAggregatesFilter<"OperationMessage"> | string
    type?: StringWithAggregatesFilter<"OperationMessage"> | string
    active?: BoolWithAggregatesFilter<"OperationMessage"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"OperationMessage"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"OperationMessage"> | Date | string
    id?: StringWithAggregatesFilter<"OperationMessage"> | string
  }

  export type OperationMessageTranslationWhereInput = {
    AND?: OperationMessageTranslationWhereInput | OperationMessageTranslationWhereInput[]
    OR?: OperationMessageTranslationWhereInput[]
    NOT?: OperationMessageTranslationWhereInput | OperationMessageTranslationWhereInput[]
    language_code?: StringFilter<"OperationMessageTranslation"> | string
    message?: StringFilter<"OperationMessageTranslation"> | string
    created_at?: DateTimeFilter<"OperationMessageTranslation"> | Date | string
    updated_at?: DateTimeFilter<"OperationMessageTranslation"> | Date | string
    operation_message_id?: StringFilter<"OperationMessageTranslation"> | string
    operation_message?: XOR<OperationMessageRelationFilter, OperationMessageWhereInput>
  }

  export type OperationMessageTranslationOrderByWithRelationInput = {
    language_code?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    operation_message_id?: SortOrder
    operation_message?: OperationMessageOrderByWithRelationInput
  }

  export type OperationMessageTranslationWhereUniqueInput = Prisma.AtLeast<{
    language_code_operation_message_id?: OperationMessageTranslationLanguage_codeOperation_message_idCompoundUniqueInput
    AND?: OperationMessageTranslationWhereInput | OperationMessageTranslationWhereInput[]
    OR?: OperationMessageTranslationWhereInput[]
    NOT?: OperationMessageTranslationWhereInput | OperationMessageTranslationWhereInput[]
    language_code?: StringFilter<"OperationMessageTranslation"> | string
    message?: StringFilter<"OperationMessageTranslation"> | string
    created_at?: DateTimeFilter<"OperationMessageTranslation"> | Date | string
    updated_at?: DateTimeFilter<"OperationMessageTranslation"> | Date | string
    operation_message_id?: StringFilter<"OperationMessageTranslation"> | string
    operation_message?: XOR<OperationMessageRelationFilter, OperationMessageWhereInput>
  }, "language_code_operation_message_id">

  export type OperationMessageTranslationOrderByWithAggregationInput = {
    language_code?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    operation_message_id?: SortOrder
    _count?: OperationMessageTranslationCountOrderByAggregateInput
    _max?: OperationMessageTranslationMaxOrderByAggregateInput
    _min?: OperationMessageTranslationMinOrderByAggregateInput
  }

  export type OperationMessageTranslationScalarWhereWithAggregatesInput = {
    AND?: OperationMessageTranslationScalarWhereWithAggregatesInput | OperationMessageTranslationScalarWhereWithAggregatesInput[]
    OR?: OperationMessageTranslationScalarWhereWithAggregatesInput[]
    NOT?: OperationMessageTranslationScalarWhereWithAggregatesInput | OperationMessageTranslationScalarWhereWithAggregatesInput[]
    language_code?: StringWithAggregatesFilter<"OperationMessageTranslation"> | string
    message?: StringWithAggregatesFilter<"OperationMessageTranslation"> | string
    created_at?: DateTimeWithAggregatesFilter<"OperationMessageTranslation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"OperationMessageTranslation"> | Date | string
    operation_message_id?: StringWithAggregatesFilter<"OperationMessageTranslation"> | string
  }

  export type InviteCodeWhereInput = {
    AND?: InviteCodeWhereInput | InviteCodeWhereInput[]
    OR?: InviteCodeWhereInput[]
    NOT?: InviteCodeWhereInput | InviteCodeWhereInput[]
    id?: UuidFilter<"InviteCode"> | string
    code?: StringFilter<"InviteCode"> | string
    expires_at?: DateTimeNullableFilter<"InviteCode"> | Date | string | null
    created_at?: DateTimeFilter<"InviteCode"> | Date | string
    updated_at?: DateTimeFilter<"InviteCode"> | Date | string
    used?: BoolFilter<"InviteCode"> | boolean
    organization_id?: UuidFilter<"InviteCode"> | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }

  export type InviteCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    used?: SortOrder
    organization_id?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type InviteCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InviteCodeWhereInput | InviteCodeWhereInput[]
    OR?: InviteCodeWhereInput[]
    NOT?: InviteCodeWhereInput | InviteCodeWhereInput[]
    code?: StringFilter<"InviteCode"> | string
    expires_at?: DateTimeNullableFilter<"InviteCode"> | Date | string | null
    created_at?: DateTimeFilter<"InviteCode"> | Date | string
    updated_at?: DateTimeFilter<"InviteCode"> | Date | string
    used?: BoolFilter<"InviteCode"> | boolean
    organization_id?: UuidFilter<"InviteCode"> | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
  }, "id">

  export type InviteCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    used?: SortOrder
    organization_id?: SortOrder
    _count?: InviteCodeCountOrderByAggregateInput
    _max?: InviteCodeMaxOrderByAggregateInput
    _min?: InviteCodeMinOrderByAggregateInput
  }

  export type InviteCodeScalarWhereWithAggregatesInput = {
    AND?: InviteCodeScalarWhereWithAggregatesInput | InviteCodeScalarWhereWithAggregatesInput[]
    OR?: InviteCodeScalarWhereWithAggregatesInput[]
    NOT?: InviteCodeScalarWhereWithAggregatesInput | InviteCodeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"InviteCode"> | string
    code?: StringWithAggregatesFilter<"InviteCode"> | string
    expires_at?: DateTimeNullableWithAggregatesFilter<"InviteCode"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"InviteCode"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"InviteCode"> | Date | string
    used?: BoolWithAggregatesFilter<"InviteCode"> | boolean
    organization_id?: UuidWithAggregatesFilter<"InviteCode"> | string
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    name?: StringFilter<"ProductCategory"> | string
    full_name?: StringFilter<"ProductCategory"> | string
    created_at?: DateTimeFilter<"ProductCategory"> | Date | string
    updated_at?: DateTimeFilter<"ProductCategory"> | Date | string
    product?: ProductListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    full_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    name?: StringFilter<"ProductCategory"> | string
    full_name?: StringFilter<"ProductCategory"> | string
    created_at?: DateTimeFilter<"ProductCategory"> | Date | string
    updated_at?: DateTimeFilter<"ProductCategory"> | Date | string
    product?: ProductListRelationFilter
  }, "id">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    full_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    full_name?: StringWithAggregatesFilter<"ProductCategory"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type ProductColorWhereInput = {
    AND?: ProductColorWhereInput | ProductColorWhereInput[]
    OR?: ProductColorWhereInput[]
    NOT?: ProductColorWhereInput | ProductColorWhereInput[]
    id?: StringFilter<"ProductColor"> | string
    attribute_name?: StringFilter<"ProductColor"> | string
    attribute_type?: StringFilter<"ProductColor"> | string
    created_at?: DateTimeFilter<"ProductColor"> | Date | string
    updated_at?: DateTimeFilter<"ProductColor"> | Date | string
    product?: ProductListRelationFilter
  }

  export type ProductColorOrderByWithRelationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductOrderByRelationAggregateInput
  }

  export type ProductColorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductColorWhereInput | ProductColorWhereInput[]
    OR?: ProductColorWhereInput[]
    NOT?: ProductColorWhereInput | ProductColorWhereInput[]
    attribute_name?: StringFilter<"ProductColor"> | string
    attribute_type?: StringFilter<"ProductColor"> | string
    created_at?: DateTimeFilter<"ProductColor"> | Date | string
    updated_at?: DateTimeFilter<"ProductColor"> | Date | string
    product?: ProductListRelationFilter
  }, "id">

  export type ProductColorOrderByWithAggregationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductColorCountOrderByAggregateInput
    _max?: ProductColorMaxOrderByAggregateInput
    _min?: ProductColorMinOrderByAggregateInput
  }

  export type ProductColorScalarWhereWithAggregatesInput = {
    AND?: ProductColorScalarWhereWithAggregatesInput | ProductColorScalarWhereWithAggregatesInput[]
    OR?: ProductColorScalarWhereWithAggregatesInput[]
    NOT?: ProductColorScalarWhereWithAggregatesInput | ProductColorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductColor"> | string
    attribute_name?: StringWithAggregatesFilter<"ProductColor"> | string
    attribute_type?: StringWithAggregatesFilter<"ProductColor"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProductColor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductColor"> | Date | string
  }

  export type ProductSizeWhereInput = {
    AND?: ProductSizeWhereInput | ProductSizeWhereInput[]
    OR?: ProductSizeWhereInput[]
    NOT?: ProductSizeWhereInput | ProductSizeWhereInput[]
    id?: StringFilter<"ProductSize"> | string
    attribute_name?: StringFilter<"ProductSize"> | string
    attribute_type?: StringFilter<"ProductSize"> | string
    created_at?: DateTimeFilter<"ProductSize"> | Date | string
    updated_at?: DateTimeFilter<"ProductSize"> | Date | string
    product?: ProductListRelationFilter
  }

  export type ProductSizeOrderByWithRelationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductOrderByRelationAggregateInput
  }

  export type ProductSizeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductSizeWhereInput | ProductSizeWhereInput[]
    OR?: ProductSizeWhereInput[]
    NOT?: ProductSizeWhereInput | ProductSizeWhereInput[]
    attribute_name?: StringFilter<"ProductSize"> | string
    attribute_type?: StringFilter<"ProductSize"> | string
    created_at?: DateTimeFilter<"ProductSize"> | Date | string
    updated_at?: DateTimeFilter<"ProductSize"> | Date | string
    product?: ProductListRelationFilter
  }, "id">

  export type ProductSizeOrderByWithAggregationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductSizeCountOrderByAggregateInput
    _max?: ProductSizeMaxOrderByAggregateInput
    _min?: ProductSizeMinOrderByAggregateInput
  }

  export type ProductSizeScalarWhereWithAggregatesInput = {
    AND?: ProductSizeScalarWhereWithAggregatesInput | ProductSizeScalarWhereWithAggregatesInput[]
    OR?: ProductSizeScalarWhereWithAggregatesInput[]
    NOT?: ProductSizeScalarWhereWithAggregatesInput | ProductSizeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductSize"> | string
    attribute_name?: StringWithAggregatesFilter<"ProductSize"> | string
    attribute_type?: StringWithAggregatesFilter<"ProductSize"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProductSize"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductSize"> | Date | string
  }

  export type ProductVoltageWhereInput = {
    AND?: ProductVoltageWhereInput | ProductVoltageWhereInput[]
    OR?: ProductVoltageWhereInput[]
    NOT?: ProductVoltageWhereInput | ProductVoltageWhereInput[]
    id?: StringFilter<"ProductVoltage"> | string
    attribute_name?: StringFilter<"ProductVoltage"> | string
    attribute_type?: StringFilter<"ProductVoltage"> | string
    created_at?: DateTimeFilter<"ProductVoltage"> | Date | string
    updated_at?: DateTimeFilter<"ProductVoltage"> | Date | string
    product?: ProductListRelationFilter
  }

  export type ProductVoltageOrderByWithRelationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductOrderByRelationAggregateInput
  }

  export type ProductVoltageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductVoltageWhereInput | ProductVoltageWhereInput[]
    OR?: ProductVoltageWhereInput[]
    NOT?: ProductVoltageWhereInput | ProductVoltageWhereInput[]
    attribute_name?: StringFilter<"ProductVoltage"> | string
    attribute_type?: StringFilter<"ProductVoltage"> | string
    created_at?: DateTimeFilter<"ProductVoltage"> | Date | string
    updated_at?: DateTimeFilter<"ProductVoltage"> | Date | string
    product?: ProductListRelationFilter
  }, "id">

  export type ProductVoltageOrderByWithAggregationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductVoltageCountOrderByAggregateInput
    _max?: ProductVoltageMaxOrderByAggregateInput
    _min?: ProductVoltageMinOrderByAggregateInput
  }

  export type ProductVoltageScalarWhereWithAggregatesInput = {
    AND?: ProductVoltageScalarWhereWithAggregatesInput | ProductVoltageScalarWhereWithAggregatesInput[]
    OR?: ProductVoltageScalarWhereWithAggregatesInput[]
    NOT?: ProductVoltageScalarWhereWithAggregatesInput | ProductVoltageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVoltage"> | string
    attribute_name?: StringWithAggregatesFilter<"ProductVoltage"> | string
    attribute_type?: StringWithAggregatesFilter<"ProductVoltage"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProductVoltage"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductVoltage"> | Date | string
  }

  export type ProductFlavorWhereInput = {
    AND?: ProductFlavorWhereInput | ProductFlavorWhereInput[]
    OR?: ProductFlavorWhereInput[]
    NOT?: ProductFlavorWhereInput | ProductFlavorWhereInput[]
    id?: StringFilter<"ProductFlavor"> | string
    attribute_name?: StringFilter<"ProductFlavor"> | string
    attribute_type?: StringFilter<"ProductFlavor"> | string
    created_at?: DateTimeFilter<"ProductFlavor"> | Date | string
    updated_at?: DateTimeFilter<"ProductFlavor"> | Date | string
    product?: ProductListRelationFilter
  }

  export type ProductFlavorOrderByWithRelationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductOrderByRelationAggregateInput
  }

  export type ProductFlavorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductFlavorWhereInput | ProductFlavorWhereInput[]
    OR?: ProductFlavorWhereInput[]
    NOT?: ProductFlavorWhereInput | ProductFlavorWhereInput[]
    attribute_name?: StringFilter<"ProductFlavor"> | string
    attribute_type?: StringFilter<"ProductFlavor"> | string
    created_at?: DateTimeFilter<"ProductFlavor"> | Date | string
    updated_at?: DateTimeFilter<"ProductFlavor"> | Date | string
    product?: ProductListRelationFilter
  }, "id">

  export type ProductFlavorOrderByWithAggregationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductFlavorCountOrderByAggregateInput
    _max?: ProductFlavorMaxOrderByAggregateInput
    _min?: ProductFlavorMinOrderByAggregateInput
  }

  export type ProductFlavorScalarWhereWithAggregatesInput = {
    AND?: ProductFlavorScalarWhereWithAggregatesInput | ProductFlavorScalarWhereWithAggregatesInput[]
    OR?: ProductFlavorScalarWhereWithAggregatesInput[]
    NOT?: ProductFlavorScalarWhereWithAggregatesInput | ProductFlavorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductFlavor"> | string
    attribute_name?: StringWithAggregatesFilter<"ProductFlavor"> | string
    attribute_type?: StringWithAggregatesFilter<"ProductFlavor"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProductFlavor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductFlavor"> | Date | string
  }

  export type ProductPowerWhereInput = {
    AND?: ProductPowerWhereInput | ProductPowerWhereInput[]
    OR?: ProductPowerWhereInput[]
    NOT?: ProductPowerWhereInput | ProductPowerWhereInput[]
    id?: StringFilter<"ProductPower"> | string
    attribute_name?: StringFilter<"ProductPower"> | string
    attribute_type?: StringFilter<"ProductPower"> | string
    created_at?: DateTimeFilter<"ProductPower"> | Date | string
    updated_at?: DateTimeFilter<"ProductPower"> | Date | string
    product?: ProductListRelationFilter
  }

  export type ProductPowerOrderByWithRelationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductOrderByRelationAggregateInput
  }

  export type ProductPowerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductPowerWhereInput | ProductPowerWhereInput[]
    OR?: ProductPowerWhereInput[]
    NOT?: ProductPowerWhereInput | ProductPowerWhereInput[]
    attribute_name?: StringFilter<"ProductPower"> | string
    attribute_type?: StringFilter<"ProductPower"> | string
    created_at?: DateTimeFilter<"ProductPower"> | Date | string
    updated_at?: DateTimeFilter<"ProductPower"> | Date | string
    product?: ProductListRelationFilter
  }, "id">

  export type ProductPowerOrderByWithAggregationInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductPowerCountOrderByAggregateInput
    _max?: ProductPowerMaxOrderByAggregateInput
    _min?: ProductPowerMinOrderByAggregateInput
  }

  export type ProductPowerScalarWhereWithAggregatesInput = {
    AND?: ProductPowerScalarWhereWithAggregatesInput | ProductPowerScalarWhereWithAggregatesInput[]
    OR?: ProductPowerScalarWhereWithAggregatesInput[]
    NOT?: ProductPowerScalarWhereWithAggregatesInput | ProductPowerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductPower"> | string
    attribute_name?: StringWithAggregatesFilter<"ProductPower"> | string
    attribute_type?: StringWithAggregatesFilter<"ProductPower"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProductPower"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductPower"> | Date | string
  }

  export type SaleChannelWhereInput = {
    AND?: SaleChannelWhereInput | SaleChannelWhereInput[]
    OR?: SaleChannelWhereInput[]
    NOT?: SaleChannelWhereInput | SaleChannelWhereInput[]
    id?: UuidFilter<"SaleChannel"> | string
    sale_channel?: StringFilter<"SaleChannel"> | string
    code?: IntFilter<"SaleChannel"> | number
    channel_type?: StringFilter<"SaleChannel"> | string
    product_id?: UuidNullableFilter<"SaleChannel"> | string | null
    sale_price?: FloatNullableFilter<"SaleChannel"> | number | null
    sale_date_start?: DateTimeNullableFilter<"SaleChannel"> | Date | string | null
    sale_date_end?: DateTimeNullableFilter<"SaleChannel"> | Date | string | null
    created_at?: DateTimeFilter<"SaleChannel"> | Date | string
    updated_at?: DateTimeFilter<"SaleChannel"> | Date | string
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type SaleChannelOrderByWithRelationInput = {
    id?: SortOrder
    sale_channel?: SortOrder
    code?: SortOrder
    channel_type?: SortOrder
    product_id?: SortOrderInput | SortOrder
    sale_price?: SortOrderInput | SortOrder
    sale_date_start?: SortOrderInput | SortOrder
    sale_date_end?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type SaleChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleChannelWhereInput | SaleChannelWhereInput[]
    OR?: SaleChannelWhereInput[]
    NOT?: SaleChannelWhereInput | SaleChannelWhereInput[]
    sale_channel?: StringFilter<"SaleChannel"> | string
    code?: IntFilter<"SaleChannel"> | number
    channel_type?: StringFilter<"SaleChannel"> | string
    product_id?: UuidNullableFilter<"SaleChannel"> | string | null
    sale_price?: FloatNullableFilter<"SaleChannel"> | number | null
    sale_date_start?: DateTimeNullableFilter<"SaleChannel"> | Date | string | null
    sale_date_end?: DateTimeNullableFilter<"SaleChannel"> | Date | string | null
    created_at?: DateTimeFilter<"SaleChannel"> | Date | string
    updated_at?: DateTimeFilter<"SaleChannel"> | Date | string
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id">

  export type SaleChannelOrderByWithAggregationInput = {
    id?: SortOrder
    sale_channel?: SortOrder
    code?: SortOrder
    channel_type?: SortOrder
    product_id?: SortOrderInput | SortOrder
    sale_price?: SortOrderInput | SortOrder
    sale_date_start?: SortOrderInput | SortOrder
    sale_date_end?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SaleChannelCountOrderByAggregateInput
    _avg?: SaleChannelAvgOrderByAggregateInput
    _max?: SaleChannelMaxOrderByAggregateInput
    _min?: SaleChannelMinOrderByAggregateInput
    _sum?: SaleChannelSumOrderByAggregateInput
  }

  export type SaleChannelScalarWhereWithAggregatesInput = {
    AND?: SaleChannelScalarWhereWithAggregatesInput | SaleChannelScalarWhereWithAggregatesInput[]
    OR?: SaleChannelScalarWhereWithAggregatesInput[]
    NOT?: SaleChannelScalarWhereWithAggregatesInput | SaleChannelScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SaleChannel"> | string
    sale_channel?: StringWithAggregatesFilter<"SaleChannel"> | string
    code?: IntWithAggregatesFilter<"SaleChannel"> | number
    channel_type?: StringWithAggregatesFilter<"SaleChannel"> | string
    product_id?: UuidNullableWithAggregatesFilter<"SaleChannel"> | string | null
    sale_price?: FloatNullableWithAggregatesFilter<"SaleChannel"> | number | null
    sale_date_start?: DateTimeNullableWithAggregatesFilter<"SaleChannel"> | Date | string | null
    sale_date_end?: DateTimeNullableWithAggregatesFilter<"SaleChannel"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"SaleChannel"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SaleChannel"> | Date | string
  }

  export type ProductCustomCategoryWhereInput = {
    AND?: ProductCustomCategoryWhereInput | ProductCustomCategoryWhereInput[]
    OR?: ProductCustomCategoryWhereInput[]
    NOT?: ProductCustomCategoryWhereInput | ProductCustomCategoryWhereInput[]
    id?: UuidFilter<"ProductCustomCategory"> | string
    created_at?: DateTimeFilter<"ProductCustomCategory"> | Date | string
    updated_at?: DateTimeFilter<"ProductCustomCategory"> | Date | string
    product?: ProductListRelationFilter
  }

  export type ProductCustomCategoryOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductOrderByRelationAggregateInput
  }

  export type ProductCustomCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductCustomCategoryWhereInput | ProductCustomCategoryWhereInput[]
    OR?: ProductCustomCategoryWhereInput[]
    NOT?: ProductCustomCategoryWhereInput | ProductCustomCategoryWhereInput[]
    created_at?: DateTimeFilter<"ProductCustomCategory"> | Date | string
    updated_at?: DateTimeFilter<"ProductCustomCategory"> | Date | string
    product?: ProductListRelationFilter
  }, "id">

  export type ProductCustomCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductCustomCategoryCountOrderByAggregateInput
    _max?: ProductCustomCategoryMaxOrderByAggregateInput
    _min?: ProductCustomCategoryMinOrderByAggregateInput
  }

  export type ProductCustomCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCustomCategoryScalarWhereWithAggregatesInput | ProductCustomCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCustomCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCustomCategoryScalarWhereWithAggregatesInput | ProductCustomCategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductCustomCategory"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProductCustomCategory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductCustomCategory"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: UuidFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    active?: BoolNullableFilter<"Product"> | boolean | null
    brand?: StringNullableFilter<"Product"> | string | null
    category_id?: StringFilter<"Product"> | string
    color_id?: StringNullableFilter<"Product"> | string | null
    cross_docking_days?: IntNullableFilter<"Product"> | number | null
    description?: StringFilter<"Product"> | string
    gender?: StringNullableFilter<"Product"> | string | null
    height?: IntFilter<"Product"> | number
    length?: IntFilter<"Product"> | number
    images?: StringNullableListFilter<"Product">
    ean?: StringNullableFilter<"Product"> | string | null
    cost_price?: IntNullableFilter<"Product"> | number | null
    manufacturer_part_number?: IntNullableFilter<"Product"> | number | null
    model?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    origin?: StringNullableFilter<"Product"> | string | null
    ncm?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    product_name?: StringNullableFilter<"Product"> | string | null
    size_id?: StringNullableFilter<"Product"> | string | null
    stock?: IntFilter<"Product"> | number
    warranty?: IntNullableFilter<"Product"> | number | null
    weight?: IntFilter<"Product"> | number
    width?: IntFilter<"Product"> | number
    custom_category_id?: UuidNullableFilter<"Product"> | string | null
    flavor_id?: StringNullableFilter<"Product"> | string | null
    measurement_unit?: StringNullableFilter<"Product"> | string | null
    unit_multiplier?: IntNullableFilter<"Product"> | number | null
    meta_fields?: JsonNullableListFilter<"Product">
    power_id?: StringNullableFilter<"Product"> | string | null
    sale_price?: FloatNullableFilter<"Product"> | number | null
    sale_date_start?: DateTimeNullableFilter<"Product"> | Date | string | null
    sale_date_end?: DateTimeNullableFilter<"Product"> | Date | string | null
    voltage_id?: StringNullableFilter<"Product"> | string | null
    videos?: StringNullableListFilter<"Product">
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    sales_channels?: SaleChannelListRelationFilter
    product_color?: XOR<ProductColorNullableRelationFilter, ProductColorWhereInput> | null
    product_category?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput>
    product_size?: XOR<ProductSizeNullableRelationFilter, ProductSizeWhereInput> | null
    product_custom_category?: XOR<ProductCustomCategoryNullableRelationFilter, ProductCustomCategoryWhereInput> | null
    product_flavor?: XOR<ProductFlavorNullableRelationFilter, ProductFlavorWhereInput> | null
    product_power?: XOR<ProductPowerNullableRelationFilter, ProductPowerWhereInput> | null
    produt_voltage?: XOR<ProductVoltageNullableRelationFilter, ProductVoltageWhereInput> | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sku?: SortOrder
    active?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    category_id?: SortOrder
    color_id?: SortOrderInput | SortOrder
    cross_docking_days?: SortOrderInput | SortOrder
    description?: SortOrder
    gender?: SortOrderInput | SortOrder
    height?: SortOrder
    length?: SortOrder
    images?: SortOrder
    ean?: SortOrderInput | SortOrder
    cost_price?: SortOrderInput | SortOrder
    manufacturer_part_number?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    name?: SortOrder
    origin?: SortOrderInput | SortOrder
    ncm?: SortOrderInput | SortOrder
    price?: SortOrder
    product_name?: SortOrderInput | SortOrder
    size_id?: SortOrderInput | SortOrder
    stock?: SortOrder
    warranty?: SortOrderInput | SortOrder
    weight?: SortOrder
    width?: SortOrder
    custom_category_id?: SortOrderInput | SortOrder
    flavor_id?: SortOrderInput | SortOrder
    measurement_unit?: SortOrderInput | SortOrder
    unit_multiplier?: SortOrderInput | SortOrder
    meta_fields?: SortOrder
    power_id?: SortOrderInput | SortOrder
    sale_price?: SortOrderInput | SortOrder
    sale_date_start?: SortOrderInput | SortOrder
    sale_date_end?: SortOrderInput | SortOrder
    voltage_id?: SortOrderInput | SortOrder
    videos?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sales_channels?: SaleChannelOrderByRelationAggregateInput
    product_color?: ProductColorOrderByWithRelationInput
    product_category?: ProductCategoryOrderByWithRelationInput
    product_size?: ProductSizeOrderByWithRelationInput
    product_custom_category?: ProductCustomCategoryOrderByWithRelationInput
    product_flavor?: ProductFlavorOrderByWithRelationInput
    product_power?: ProductPowerOrderByWithRelationInput
    produt_voltage?: ProductVoltageOrderByWithRelationInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    sku?: StringFilter<"Product"> | string
    active?: BoolNullableFilter<"Product"> | boolean | null
    brand?: StringNullableFilter<"Product"> | string | null
    category_id?: StringFilter<"Product"> | string
    color_id?: StringNullableFilter<"Product"> | string | null
    cross_docking_days?: IntNullableFilter<"Product"> | number | null
    description?: StringFilter<"Product"> | string
    gender?: StringNullableFilter<"Product"> | string | null
    height?: IntFilter<"Product"> | number
    length?: IntFilter<"Product"> | number
    images?: StringNullableListFilter<"Product">
    ean?: StringNullableFilter<"Product"> | string | null
    cost_price?: IntNullableFilter<"Product"> | number | null
    manufacturer_part_number?: IntNullableFilter<"Product"> | number | null
    model?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    origin?: StringNullableFilter<"Product"> | string | null
    ncm?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    product_name?: StringNullableFilter<"Product"> | string | null
    size_id?: StringNullableFilter<"Product"> | string | null
    stock?: IntFilter<"Product"> | number
    warranty?: IntNullableFilter<"Product"> | number | null
    weight?: IntFilter<"Product"> | number
    width?: IntFilter<"Product"> | number
    custom_category_id?: UuidNullableFilter<"Product"> | string | null
    flavor_id?: StringNullableFilter<"Product"> | string | null
    measurement_unit?: StringNullableFilter<"Product"> | string | null
    unit_multiplier?: IntNullableFilter<"Product"> | number | null
    meta_fields?: JsonNullableListFilter<"Product">
    power_id?: StringNullableFilter<"Product"> | string | null
    sale_price?: FloatNullableFilter<"Product"> | number | null
    sale_date_start?: DateTimeNullableFilter<"Product"> | Date | string | null
    sale_date_end?: DateTimeNullableFilter<"Product"> | Date | string | null
    voltage_id?: StringNullableFilter<"Product"> | string | null
    videos?: StringNullableListFilter<"Product">
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
    sales_channels?: SaleChannelListRelationFilter
    product_color?: XOR<ProductColorNullableRelationFilter, ProductColorWhereInput> | null
    product_category?: XOR<ProductCategoryRelationFilter, ProductCategoryWhereInput>
    product_size?: XOR<ProductSizeNullableRelationFilter, ProductSizeWhereInput> | null
    product_custom_category?: XOR<ProductCustomCategoryNullableRelationFilter, ProductCustomCategoryWhereInput> | null
    product_flavor?: XOR<ProductFlavorNullableRelationFilter, ProductFlavorWhereInput> | null
    product_power?: XOR<ProductPowerNullableRelationFilter, ProductPowerWhereInput> | null
    produt_voltage?: XOR<ProductVoltageNullableRelationFilter, ProductVoltageWhereInput> | null
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sku?: SortOrder
    active?: SortOrderInput | SortOrder
    brand?: SortOrderInput | SortOrder
    category_id?: SortOrder
    color_id?: SortOrderInput | SortOrder
    cross_docking_days?: SortOrderInput | SortOrder
    description?: SortOrder
    gender?: SortOrderInput | SortOrder
    height?: SortOrder
    length?: SortOrder
    images?: SortOrder
    ean?: SortOrderInput | SortOrder
    cost_price?: SortOrderInput | SortOrder
    manufacturer_part_number?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    name?: SortOrder
    origin?: SortOrderInput | SortOrder
    ncm?: SortOrderInput | SortOrder
    price?: SortOrder
    product_name?: SortOrderInput | SortOrder
    size_id?: SortOrderInput | SortOrder
    stock?: SortOrder
    warranty?: SortOrderInput | SortOrder
    weight?: SortOrder
    width?: SortOrder
    custom_category_id?: SortOrderInput | SortOrder
    flavor_id?: SortOrderInput | SortOrder
    measurement_unit?: SortOrderInput | SortOrder
    unit_multiplier?: SortOrderInput | SortOrder
    meta_fields?: SortOrder
    power_id?: SortOrderInput | SortOrder
    sale_price?: SortOrderInput | SortOrder
    sale_date_start?: SortOrderInput | SortOrder
    sale_date_end?: SortOrderInput | SortOrder
    voltage_id?: SortOrderInput | SortOrder
    videos?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Product"> | string
    sku?: StringWithAggregatesFilter<"Product"> | string
    active?: BoolNullableWithAggregatesFilter<"Product"> | boolean | null
    brand?: StringNullableWithAggregatesFilter<"Product"> | string | null
    category_id?: StringWithAggregatesFilter<"Product"> | string
    color_id?: StringNullableWithAggregatesFilter<"Product"> | string | null
    cross_docking_days?: IntNullableWithAggregatesFilter<"Product"> | number | null
    description?: StringWithAggregatesFilter<"Product"> | string
    gender?: StringNullableWithAggregatesFilter<"Product"> | string | null
    height?: IntWithAggregatesFilter<"Product"> | number
    length?: IntWithAggregatesFilter<"Product"> | number
    images?: StringNullableListFilter<"Product">
    ean?: StringNullableWithAggregatesFilter<"Product"> | string | null
    cost_price?: IntNullableWithAggregatesFilter<"Product"> | number | null
    manufacturer_part_number?: IntNullableWithAggregatesFilter<"Product"> | number | null
    model?: StringNullableWithAggregatesFilter<"Product"> | string | null
    name?: StringWithAggregatesFilter<"Product"> | string
    origin?: StringNullableWithAggregatesFilter<"Product"> | string | null
    ncm?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatWithAggregatesFilter<"Product"> | number
    product_name?: StringNullableWithAggregatesFilter<"Product"> | string | null
    size_id?: StringNullableWithAggregatesFilter<"Product"> | string | null
    stock?: IntWithAggregatesFilter<"Product"> | number
    warranty?: IntNullableWithAggregatesFilter<"Product"> | number | null
    weight?: IntWithAggregatesFilter<"Product"> | number
    width?: IntWithAggregatesFilter<"Product"> | number
    custom_category_id?: UuidNullableWithAggregatesFilter<"Product"> | string | null
    flavor_id?: StringNullableWithAggregatesFilter<"Product"> | string | null
    measurement_unit?: StringNullableWithAggregatesFilter<"Product"> | string | null
    unit_multiplier?: IntNullableWithAggregatesFilter<"Product"> | number | null
    meta_fields?: JsonNullableListFilter<"Product">
    power_id?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sale_price?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    sale_date_start?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    sale_date_end?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    voltage_id?: StringNullableWithAggregatesFilter<"Product"> | string | null
    videos?: StringNullableListFilter<"Product">
    created_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender?: string | null
    phone?: string | null
    active?: boolean
    visitor?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    user_organizations?: OrganizationCreateNestedManyWithoutOwnerInput
    teams?: MemberCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender?: string | null
    phone?: string | null
    active?: boolean
    visitor?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    user_organizations?: OrganizationUncheckedCreateNestedManyWithoutOwnerInput
    teams?: MemberUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_organizations?: OrganizationUpdateManyWithoutOwnerNestedInput
    teams?: MemberUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_organizations?: OrganizationUncheckedUpdateManyWithoutOwnerNestedInput
    teams?: MemberUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender?: string | null
    phone?: string | null
    active?: boolean
    visitor?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutUser_organizationsInput
    members?: MemberCreateNestedManyWithoutOrganizationInput
    customer?: CustomerCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeCreateNestedManyWithoutOrganizationInput
    profile?: ProfileCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    owner_id: string
    created_at?: Date | string
    updated_at?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    customer?: CustomerUncheckedCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeUncheckedCreateNestedManyWithoutOrganizationInput
    profile?: ProfileUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutUser_organizationsNestedInput
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    customer?: CustomerUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    owner_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUncheckedUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    owner_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    owner_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    profile_avatar?: string | null
    profile_cover?: string | null
    username: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutProfileInput
    organization?: OrganizationCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    profile_avatar?: string | null
    profile_cover?: string | null
    user_id?: string | null
    organization_id?: string | null
    username: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    profile_cover?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProfileNestedInput
    organization?: OrganizationUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    profile_cover?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    organization_id?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    profile_avatar?: string | null
    profile_cover?: string | null
    user_id?: string | null
    organization_id?: string | null
    username: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    profile_cover?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    profile_cover?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    organization_id?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateInput = {
    role: $Enums.Role
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutTeamsInput
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateInput = {
    user_id: string
    role: $Enums.Role
    organization_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MemberUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organization_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateManyInput = {
    user_id: string
    role: $Enums.Role
    organization_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MemberUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organization_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name?: string | null
    second_name?: string | null
    whatsapp?: string | null
    shop_name: string
    address_line_one?: string | null
    address_line_two?: string | null
    email: string
    second_phone?: string | null
    vat_rate_id: string
    currency_id: string
    agent_id: string
    active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name?: string | null
    second_name?: string | null
    whatsapp?: string | null
    shop_name: string
    address_line_one?: string | null
    address_line_two?: string | null
    email: string
    second_phone?: string | null
    vat_rate_id: string
    currency_id: string
    agent_id: string
    active?: boolean
    organization_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    second_name?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: StringFieldUpdateOperationsInput | string
    address_line_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_line_two?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    second_phone?: NullableStringFieldUpdateOperationsInput | string | null
    vat_rate_id?: StringFieldUpdateOperationsInput | string
    currency_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    second_name?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: StringFieldUpdateOperationsInput | string
    address_line_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_line_two?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    second_phone?: NullableStringFieldUpdateOperationsInput | string | null
    vat_rate_id?: StringFieldUpdateOperationsInput | string
    currency_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyInput = {
    id?: string
    name?: string | null
    second_name?: string | null
    whatsapp?: string | null
    shop_name: string
    address_line_one?: string | null
    address_line_two?: string | null
    email: string
    second_phone?: string | null
    vat_rate_id: string
    currency_id: string
    agent_id: string
    active?: boolean
    organization_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    second_name?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: StringFieldUpdateOperationsInput | string
    address_line_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_line_two?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    second_phone?: NullableStringFieldUpdateOperationsInput | string | null
    vat_rate_id?: StringFieldUpdateOperationsInput | string
    currency_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    second_name?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: StringFieldUpdateOperationsInput | string
    address_line_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_line_two?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    second_phone?: NullableStringFieldUpdateOperationsInput | string | null
    vat_rate_id?: StringFieldUpdateOperationsInput | string
    currency_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationMessageCreateInput = {
    message: string
    type: string
    active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    id: string
    operation_message_translations?: OperationMessageTranslationCreateNestedManyWithoutOperation_messageInput
  }

  export type OperationMessageUncheckedCreateInput = {
    message: string
    type: string
    active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    id: string
    operation_message_translations?: OperationMessageTranslationUncheckedCreateNestedManyWithoutOperation_messageInput
  }

  export type OperationMessageUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    operation_message_translations?: OperationMessageTranslationUpdateManyWithoutOperation_messageNestedInput
  }

  export type OperationMessageUncheckedUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    operation_message_translations?: OperationMessageTranslationUncheckedUpdateManyWithoutOperation_messageNestedInput
  }

  export type OperationMessageCreateManyInput = {
    message: string
    type: string
    active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    id: string
  }

  export type OperationMessageUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type OperationMessageUncheckedUpdateManyInput = {
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type OperationMessageTranslationCreateInput = {
    language_code: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    operation_message: OperationMessageCreateNestedOneWithoutOperation_message_translationsInput
  }

  export type OperationMessageTranslationUncheckedCreateInput = {
    language_code: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    operation_message_id: string
  }

  export type OperationMessageTranslationUpdateInput = {
    language_code?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    operation_message?: OperationMessageUpdateOneRequiredWithoutOperation_message_translationsNestedInput
  }

  export type OperationMessageTranslationUncheckedUpdateInput = {
    language_code?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    operation_message_id?: StringFieldUpdateOperationsInput | string
  }

  export type OperationMessageTranslationCreateManyInput = {
    language_code: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
    operation_message_id: string
  }

  export type OperationMessageTranslationUpdateManyMutationInput = {
    language_code?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationMessageTranslationUncheckedUpdateManyInput = {
    language_code?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    operation_message_id?: StringFieldUpdateOperationsInput | string
  }

  export type InviteCodeCreateInput = {
    id?: string
    code: string
    expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    used?: boolean
    organization: OrganizationCreateNestedOneWithoutInvite_codeInput
  }

  export type InviteCodeUncheckedCreateInput = {
    id?: string
    code: string
    expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    used?: boolean
    organization_id: string
  }

  export type InviteCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutInvite_codeNestedInput
  }

  export type InviteCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: StringFieldUpdateOperationsInput | string
  }

  export type InviteCodeCreateManyInput = {
    id?: string
    code: string
    expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    used?: boolean
    organization_id: string
  }

  export type InviteCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InviteCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    organization_id?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCategoryCreateInput = {
    id: string
    name: string
    full_name: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductCreateNestedManyWithoutProduct_categoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id: string
    name: string
    full_name: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutProduct_categoryInput
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutProduct_categoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutProduct_categoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id: string
    name: string
    full_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductColorCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductCreateNestedManyWithoutProduct_colorInput
  }

  export type ProductColorUncheckedCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutProduct_colorInput
  }

  export type ProductColorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutProduct_colorNestedInput
  }

  export type ProductColorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutProduct_colorNestedInput
  }

  export type ProductColorCreateManyInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductColorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductColorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSizeCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductCreateNestedManyWithoutProduct_sizeInput
  }

  export type ProductSizeUncheckedCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutProduct_sizeInput
  }

  export type ProductSizeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutProduct_sizeNestedInput
  }

  export type ProductSizeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutProduct_sizeNestedInput
  }

  export type ProductSizeCreateManyInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductSizeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSizeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVoltageCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductCreateNestedManyWithoutProdut_voltageInput
  }

  export type ProductVoltageUncheckedCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutProdut_voltageInput
  }

  export type ProductVoltageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutProdut_voltageNestedInput
  }

  export type ProductVoltageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutProdut_voltageNestedInput
  }

  export type ProductVoltageCreateManyInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductVoltageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVoltageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFlavorCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductCreateNestedManyWithoutProduct_flavorInput
  }

  export type ProductFlavorUncheckedCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutProduct_flavorInput
  }

  export type ProductFlavorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutProduct_flavorNestedInput
  }

  export type ProductFlavorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutProduct_flavorNestedInput
  }

  export type ProductFlavorCreateManyInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductFlavorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFlavorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPowerCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductCreateNestedManyWithoutProduct_powerInput
  }

  export type ProductPowerUncheckedCreateInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutProduct_powerInput
  }

  export type ProductPowerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutProduct_powerNestedInput
  }

  export type ProductPowerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutProduct_powerNestedInput
  }

  export type ProductPowerCreateManyInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductPowerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPowerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleChannelCreateInput = {
    id?: string
    sale_channel: string
    code: number
    channel_type: string
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductCreateNestedOneWithoutSales_channelsInput
  }

  export type SaleChannelUncheckedCreateInput = {
    id?: string
    sale_channel: string
    code: number
    channel_type: string
    product_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sale_channel?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    channel_type?: StringFieldUpdateOperationsInput | string
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutSales_channelsNestedInput
  }

  export type SaleChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sale_channel?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    channel_type?: StringFieldUpdateOperationsInput | string
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleChannelCreateManyInput = {
    id?: string
    sale_channel: string
    code: number
    channel_type: string
    product_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sale_channel?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    channel_type?: StringFieldUpdateOperationsInput | string
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sale_channel?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    channel_type?: StringFieldUpdateOperationsInput | string
    product_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCustomCategoryCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductCreateNestedManyWithoutProduct_custom_categoryInput
  }

  export type ProductCustomCategoryUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductUncheckedCreateNestedManyWithoutProduct_custom_categoryInput
  }

  export type ProductCustomCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateManyWithoutProduct_custom_categoryNestedInput
  }

  export type ProductCustomCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUncheckedUpdateManyWithoutProduct_custom_categoryNestedInput
  }

  export type ProductCustomCategoryCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductCustomCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCustomCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelCreateNestedManyWithoutProductInput
    product_color?: ProductColorCreateNestedOneWithoutProductInput
    product_category: ProductCategoryCreateNestedOneWithoutProductInput
    product_size?: ProductSizeCreateNestedOneWithoutProductInput
    product_custom_category?: ProductCustomCategoryCreateNestedOneWithoutProductInput
    product_flavor?: ProductFlavorCreateNestedOneWithoutProductInput
    product_power?: ProductPowerCreateNestedOneWithoutProductInput
    produt_voltage?: ProductVoltageCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUpdateManyWithoutProductNestedInput
    product_color?: ProductColorUpdateOneWithoutProductNestedInput
    product_category?: ProductCategoryUpdateOneRequiredWithoutProductNestedInput
    product_size?: ProductSizeUpdateOneWithoutProductNestedInput
    product_custom_category?: ProductCustomCategoryUpdateOneWithoutProductNestedInput
    product_flavor?: ProductFlavorUpdateOneWithoutProductNestedInput
    product_power?: ProductPowerUpdateOneWithoutProductNestedInput
    produt_voltage?: ProductVoltageUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OrganizationListRelationFilter = {
    every?: OrganizationWhereInput
    some?: OrganizationWhereInput
    none?: OrganizationWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrganizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    active?: SortOrder
    visitor?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    active?: SortOrder
    visitor?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrder
    phone?: SortOrder
    active?: SortOrder
    visitor?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type InviteCodeListRelationFilter = {
    every?: InviteCodeWhereInput
    some?: InviteCodeWhereInput
    none?: InviteCodeWhereInput
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    zip_code?: SortOrder
    active?: SortOrder
    business_name?: SortOrder
    address_one?: SortOrder
    address_two?: SortOrder
    fantasy_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    website?: SortOrder
    registration_number?: SortOrder
    slug?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    zip_code?: SortOrder
    active?: SortOrder
    business_name?: SortOrder
    address_one?: SortOrder
    address_two?: SortOrder
    fantasy_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    website?: SortOrder
    registration_number?: SortOrder
    slug?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    zip_code?: SortOrder
    active?: SortOrder
    business_name?: SortOrder
    address_one?: SortOrder
    address_two?: SortOrder
    fantasy_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    website?: SortOrder
    registration_number?: SortOrder
    slug?: SortOrder
    owner_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type OrganizationNullableRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    profile_avatar?: SortOrder
    profile_cover?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
    username?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_avatar?: SortOrder
    profile_cover?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
    username?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    profile_avatar?: SortOrder
    profile_cover?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
    username?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type MemberOrganization_idUser_idCompoundUniqueInput = {
    organization_id: string
    user_id: string
  }

  export type MemberCountOrderByAggregateInput = {
    user_id?: SortOrder
    role?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    user_id?: SortOrder
    role?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    user_id?: SortOrder
    role?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    second_name?: SortOrder
    whatsapp?: SortOrder
    shop_name?: SortOrder
    address_line_one?: SortOrder
    address_line_two?: SortOrder
    email?: SortOrder
    second_phone?: SortOrder
    vat_rate_id?: SortOrder
    currency_id?: SortOrder
    agent_id?: SortOrder
    active?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    second_name?: SortOrder
    whatsapp?: SortOrder
    shop_name?: SortOrder
    address_line_one?: SortOrder
    address_line_two?: SortOrder
    email?: SortOrder
    second_phone?: SortOrder
    vat_rate_id?: SortOrder
    currency_id?: SortOrder
    agent_id?: SortOrder
    active?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    second_name?: SortOrder
    whatsapp?: SortOrder
    shop_name?: SortOrder
    address_line_one?: SortOrder
    address_line_two?: SortOrder
    email?: SortOrder
    second_phone?: SortOrder
    vat_rate_id?: SortOrder
    currency_id?: SortOrder
    agent_id?: SortOrder
    active?: SortOrder
    organization_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OperationMessageTranslationListRelationFilter = {
    every?: OperationMessageTranslationWhereInput
    some?: OperationMessageTranslationWhereInput
    none?: OperationMessageTranslationWhereInput
  }

  export type OperationMessageTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationMessageCountOrderByAggregateInput = {
    message?: SortOrder
    type?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
  }

  export type OperationMessageMaxOrderByAggregateInput = {
    message?: SortOrder
    type?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
  }

  export type OperationMessageMinOrderByAggregateInput = {
    message?: SortOrder
    type?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id?: SortOrder
  }

  export type OperationMessageRelationFilter = {
    is?: OperationMessageWhereInput
    isNot?: OperationMessageWhereInput
  }

  export type OperationMessageTranslationLanguage_codeOperation_message_idCompoundUniqueInput = {
    language_code: string
    operation_message_id: string
  }

  export type OperationMessageTranslationCountOrderByAggregateInput = {
    language_code?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    operation_message_id?: SortOrder
  }

  export type OperationMessageTranslationMaxOrderByAggregateInput = {
    language_code?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    operation_message_id?: SortOrder
  }

  export type OperationMessageTranslationMinOrderByAggregateInput = {
    language_code?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    operation_message_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type InviteCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    used?: SortOrder
    organization_id?: SortOrder
  }

  export type InviteCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    used?: SortOrder
    organization_id?: SortOrder
  }

  export type InviteCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    used?: SortOrder
    organization_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    full_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    full_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    full_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductColorCountOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductColorMaxOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductColorMinOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductSizeCountOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductSizeMaxOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductSizeMinOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductVoltageCountOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductVoltageMaxOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductVoltageMinOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductFlavorCountOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductFlavorMaxOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductFlavorMinOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductPowerCountOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductPowerMaxOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductPowerMinOrderByAggregateInput = {
    id?: SortOrder
    attribute_name?: SortOrder
    attribute_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type SaleChannelCountOrderByAggregateInput = {
    id?: SortOrder
    sale_channel?: SortOrder
    code?: SortOrder
    channel_type?: SortOrder
    product_id?: SortOrder
    sale_price?: SortOrder
    sale_date_start?: SortOrder
    sale_date_end?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SaleChannelAvgOrderByAggregateInput = {
    code?: SortOrder
    sale_price?: SortOrder
  }

  export type SaleChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_channel?: SortOrder
    code?: SortOrder
    channel_type?: SortOrder
    product_id?: SortOrder
    sale_price?: SortOrder
    sale_date_start?: SortOrder
    sale_date_end?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SaleChannelMinOrderByAggregateInput = {
    id?: SortOrder
    sale_channel?: SortOrder
    code?: SortOrder
    channel_type?: SortOrder
    product_id?: SortOrder
    sale_price?: SortOrder
    sale_date_start?: SortOrder
    sale_date_end?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SaleChannelSumOrderByAggregateInput = {
    code?: SortOrder
    sale_price?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProductCustomCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductCustomCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductCustomCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SaleChannelListRelationFilter = {
    every?: SaleChannelWhereInput
    some?: SaleChannelWhereInput
    none?: SaleChannelWhereInput
  }

  export type ProductColorNullableRelationFilter = {
    is?: ProductColorWhereInput | null
    isNot?: ProductColorWhereInput | null
  }

  export type ProductCategoryRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type ProductSizeNullableRelationFilter = {
    is?: ProductSizeWhereInput | null
    isNot?: ProductSizeWhereInput | null
  }

  export type ProductCustomCategoryNullableRelationFilter = {
    is?: ProductCustomCategoryWhereInput | null
    isNot?: ProductCustomCategoryWhereInput | null
  }

  export type ProductFlavorNullableRelationFilter = {
    is?: ProductFlavorWhereInput | null
    isNot?: ProductFlavorWhereInput | null
  }

  export type ProductPowerNullableRelationFilter = {
    is?: ProductPowerWhereInput | null
    isNot?: ProductPowerWhereInput | null
  }

  export type ProductVoltageNullableRelationFilter = {
    is?: ProductVoltageWhereInput | null
    isNot?: ProductVoltageWhereInput | null
  }

  export type SaleChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    active?: SortOrder
    brand?: SortOrder
    category_id?: SortOrder
    color_id?: SortOrder
    cross_docking_days?: SortOrder
    description?: SortOrder
    gender?: SortOrder
    height?: SortOrder
    length?: SortOrder
    images?: SortOrder
    ean?: SortOrder
    cost_price?: SortOrder
    manufacturer_part_number?: SortOrder
    model?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    ncm?: SortOrder
    price?: SortOrder
    product_name?: SortOrder
    size_id?: SortOrder
    stock?: SortOrder
    warranty?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    custom_category_id?: SortOrder
    flavor_id?: SortOrder
    measurement_unit?: SortOrder
    unit_multiplier?: SortOrder
    meta_fields?: SortOrder
    power_id?: SortOrder
    sale_price?: SortOrder
    sale_date_start?: SortOrder
    sale_date_end?: SortOrder
    voltage_id?: SortOrder
    videos?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    cross_docking_days?: SortOrder
    height?: SortOrder
    length?: SortOrder
    cost_price?: SortOrder
    manufacturer_part_number?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    warranty?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    unit_multiplier?: SortOrder
    sale_price?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    active?: SortOrder
    brand?: SortOrder
    category_id?: SortOrder
    color_id?: SortOrder
    cross_docking_days?: SortOrder
    description?: SortOrder
    gender?: SortOrder
    height?: SortOrder
    length?: SortOrder
    ean?: SortOrder
    cost_price?: SortOrder
    manufacturer_part_number?: SortOrder
    model?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    ncm?: SortOrder
    price?: SortOrder
    product_name?: SortOrder
    size_id?: SortOrder
    stock?: SortOrder
    warranty?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    custom_category_id?: SortOrder
    flavor_id?: SortOrder
    measurement_unit?: SortOrder
    unit_multiplier?: SortOrder
    power_id?: SortOrder
    sale_price?: SortOrder
    sale_date_start?: SortOrder
    sale_date_end?: SortOrder
    voltage_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sku?: SortOrder
    active?: SortOrder
    brand?: SortOrder
    category_id?: SortOrder
    color_id?: SortOrder
    cross_docking_days?: SortOrder
    description?: SortOrder
    gender?: SortOrder
    height?: SortOrder
    length?: SortOrder
    ean?: SortOrder
    cost_price?: SortOrder
    manufacturer_part_number?: SortOrder
    model?: SortOrder
    name?: SortOrder
    origin?: SortOrder
    ncm?: SortOrder
    price?: SortOrder
    product_name?: SortOrder
    size_id?: SortOrder
    stock?: SortOrder
    warranty?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    custom_category_id?: SortOrder
    flavor_id?: SortOrder
    measurement_unit?: SortOrder
    unit_multiplier?: SortOrder
    power_id?: SortOrder
    sale_price?: SortOrder
    sale_date_start?: SortOrder
    sale_date_end?: SortOrder
    voltage_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    cross_docking_days?: SortOrder
    height?: SortOrder
    length?: SortOrder
    cost_price?: SortOrder
    manufacturer_part_number?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    warranty?: SortOrder
    weight?: SortOrder
    width?: SortOrder
    unit_multiplier?: SortOrder
    sale_price?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type OrganizationCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput> | OrganizationCreateWithoutOwnerInput[] | OrganizationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput | OrganizationCreateOrConnectWithoutOwnerInput[]
    createMany?: OrganizationCreateManyOwnerInputEnvelope
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type OrganizationUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput> | OrganizationCreateWithoutOwnerInput[] | OrganizationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput | OrganizationCreateOrConnectWithoutOwnerInput[]
    createMany?: OrganizationCreateManyOwnerInputEnvelope
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrganizationUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput> | OrganizationCreateWithoutOwnerInput[] | OrganizationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput | OrganizationCreateOrConnectWithoutOwnerInput[]
    upsert?: OrganizationUpsertWithWhereUniqueWithoutOwnerInput | OrganizationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OrganizationCreateManyOwnerInputEnvelope
    set?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    disconnect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    delete?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    update?: OrganizationUpdateWithWhereUniqueWithoutOwnerInput | OrganizationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OrganizationUpdateManyWithWhereWithoutOwnerInput | OrganizationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput> | OrganizationCreateWithoutOwnerInput[] | OrganizationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: OrganizationCreateOrConnectWithoutOwnerInput | OrganizationCreateOrConnectWithoutOwnerInput[]
    upsert?: OrganizationUpsertWithWhereUniqueWithoutOwnerInput | OrganizationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: OrganizationCreateManyOwnerInputEnvelope
    set?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    disconnect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    delete?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    connect?: OrganizationWhereUniqueInput | OrganizationWhereUniqueInput[]
    update?: OrganizationUpdateWithWhereUniqueWithoutOwnerInput | OrganizationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: OrganizationUpdateManyWithWhereWithoutOwnerInput | OrganizationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput> | MemberCreateWithoutUserInput[] | MemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutUserInput | MemberCreateOrConnectWithoutUserInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutUserInput | MemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MemberCreateManyUserInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutUserInput | MemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutUserInput | MemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutUser_organizationsInput = {
    create?: XOR<UserCreateWithoutUser_organizationsInput, UserUncheckedCreateWithoutUser_organizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_organizationsInput
    connect?: UserWhereUniqueInput
  }

  export type MemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CustomerCreateWithoutOrganizationInput, CustomerUncheckedCreateWithoutOrganizationInput> | CustomerCreateWithoutOrganizationInput[] | CustomerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrganizationInput | CustomerCreateOrConnectWithoutOrganizationInput[]
    createMany?: CustomerCreateManyOrganizationInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InviteCodeCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InviteCodeCreateWithoutOrganizationInput, InviteCodeUncheckedCreateWithoutOrganizationInput> | InviteCodeCreateWithoutOrganizationInput[] | InviteCodeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InviteCodeCreateOrConnectWithoutOrganizationInput | InviteCodeCreateOrConnectWithoutOrganizationInput[]
    createMany?: InviteCodeCreateManyOrganizationInputEnvelope
    connect?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<ProfileCreateWithoutOrganizationInput, ProfileUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutOrganizationInput
    connect?: ProfileWhereUniqueInput
  }

  export type MemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CustomerCreateWithoutOrganizationInput, CustomerUncheckedCreateWithoutOrganizationInput> | CustomerCreateWithoutOrganizationInput[] | CustomerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrganizationInput | CustomerCreateOrConnectWithoutOrganizationInput[]
    createMany?: CustomerCreateManyOrganizationInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type InviteCodeUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InviteCodeCreateWithoutOrganizationInput, InviteCodeUncheckedCreateWithoutOrganizationInput> | InviteCodeCreateWithoutOrganizationInput[] | InviteCodeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InviteCodeCreateOrConnectWithoutOrganizationInput | InviteCodeCreateOrConnectWithoutOrganizationInput[]
    createMany?: InviteCodeCreateManyOrganizationInputEnvelope
    connect?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutOrganizationInput = {
    create?: XOR<ProfileCreateWithoutOrganizationInput, ProfileUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutOrganizationInput
    connect?: ProfileWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_organizationsNestedInput = {
    create?: XOR<UserCreateWithoutUser_organizationsInput, UserUncheckedCreateWithoutUser_organizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_organizationsInput
    upsert?: UserUpsertWithoutUser_organizationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_organizationsInput, UserUpdateWithoutUser_organizationsInput>, UserUncheckedUpdateWithoutUser_organizationsInput>
  }

  export type MemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CustomerCreateWithoutOrganizationInput, CustomerUncheckedCreateWithoutOrganizationInput> | CustomerCreateWithoutOrganizationInput[] | CustomerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrganizationInput | CustomerCreateOrConnectWithoutOrganizationInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutOrganizationInput | CustomerUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CustomerCreateManyOrganizationInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutOrganizationInput | CustomerUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutOrganizationInput | CustomerUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InviteCodeUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InviteCodeCreateWithoutOrganizationInput, InviteCodeUncheckedCreateWithoutOrganizationInput> | InviteCodeCreateWithoutOrganizationInput[] | InviteCodeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InviteCodeCreateOrConnectWithoutOrganizationInput | InviteCodeCreateOrConnectWithoutOrganizationInput[]
    upsert?: InviteCodeUpsertWithWhereUniqueWithoutOrganizationInput | InviteCodeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InviteCodeCreateManyOrganizationInputEnvelope
    set?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
    disconnect?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
    delete?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
    connect?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
    update?: InviteCodeUpdateWithWhereUniqueWithoutOrganizationInput | InviteCodeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InviteCodeUpdateManyWithWhereWithoutOrganizationInput | InviteCodeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InviteCodeScalarWhereInput | InviteCodeScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<ProfileCreateWithoutOrganizationInput, ProfileUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutOrganizationInput
    upsert?: ProfileUpsertWithoutOrganizationInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutOrganizationInput, ProfileUpdateWithoutOrganizationInput>, ProfileUncheckedUpdateWithoutOrganizationInput>
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput> | MemberCreateWithoutOrganizationInput[] | MemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MemberCreateOrConnectWithoutOrganizationInput | MemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: MemberUpsertWithWhereUniqueWithoutOrganizationInput | MemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MemberCreateManyOrganizationInputEnvelope
    set?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    disconnect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    delete?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    connect?: MemberWhereUniqueInput | MemberWhereUniqueInput[]
    update?: MemberUpdateWithWhereUniqueWithoutOrganizationInput | MemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MemberUpdateManyWithWhereWithoutOrganizationInput | MemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MemberScalarWhereInput | MemberScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CustomerCreateWithoutOrganizationInput, CustomerUncheckedCreateWithoutOrganizationInput> | CustomerCreateWithoutOrganizationInput[] | CustomerUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutOrganizationInput | CustomerCreateOrConnectWithoutOrganizationInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutOrganizationInput | CustomerUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CustomerCreateManyOrganizationInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutOrganizationInput | CustomerUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutOrganizationInput | CustomerUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type InviteCodeUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InviteCodeCreateWithoutOrganizationInput, InviteCodeUncheckedCreateWithoutOrganizationInput> | InviteCodeCreateWithoutOrganizationInput[] | InviteCodeUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InviteCodeCreateOrConnectWithoutOrganizationInput | InviteCodeCreateOrConnectWithoutOrganizationInput[]
    upsert?: InviteCodeUpsertWithWhereUniqueWithoutOrganizationInput | InviteCodeUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InviteCodeCreateManyOrganizationInputEnvelope
    set?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
    disconnect?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
    delete?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
    connect?: InviteCodeWhereUniqueInput | InviteCodeWhereUniqueInput[]
    update?: InviteCodeUpdateWithWhereUniqueWithoutOrganizationInput | InviteCodeUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InviteCodeUpdateManyWithWhereWithoutOrganizationInput | InviteCodeUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InviteCodeScalarWhereInput | InviteCodeScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutOrganizationNestedInput = {
    create?: XOR<ProfileCreateWithoutOrganizationInput, ProfileUncheckedCreateWithoutOrganizationInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutOrganizationInput
    upsert?: ProfileUpsertWithoutOrganizationInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutOrganizationInput, ProfileUpdateWithoutOrganizationInput>, ProfileUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutProfileInput = {
    create?: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProfileInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserUpdateOneWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type OrganizationUpdateOneWithoutProfileNestedInput = {
    create?: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProfileInput
    upsert?: OrganizationUpsertWithoutProfileInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProfileInput, OrganizationUpdateWithoutProfileInput>, OrganizationUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutTeamsInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type UserUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    upsert?: UserUpsertWithoutTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsInput, UserUpdateWithoutTeamsInput>, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationCreateNestedOneWithoutCustomerInput = {
    create?: XOR<OrganizationCreateWithoutCustomerInput, OrganizationUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomerInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutCustomerNestedInput = {
    create?: XOR<OrganizationCreateWithoutCustomerInput, OrganizationUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutCustomerInput
    upsert?: OrganizationUpsertWithoutCustomerInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutCustomerInput, OrganizationUpdateWithoutCustomerInput>, OrganizationUncheckedUpdateWithoutCustomerInput>
  }

  export type OperationMessageTranslationCreateNestedManyWithoutOperation_messageInput = {
    create?: XOR<OperationMessageTranslationCreateWithoutOperation_messageInput, OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput> | OperationMessageTranslationCreateWithoutOperation_messageInput[] | OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput[]
    connectOrCreate?: OperationMessageTranslationCreateOrConnectWithoutOperation_messageInput | OperationMessageTranslationCreateOrConnectWithoutOperation_messageInput[]
    createMany?: OperationMessageTranslationCreateManyOperation_messageInputEnvelope
    connect?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
  }

  export type OperationMessageTranslationUncheckedCreateNestedManyWithoutOperation_messageInput = {
    create?: XOR<OperationMessageTranslationCreateWithoutOperation_messageInput, OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput> | OperationMessageTranslationCreateWithoutOperation_messageInput[] | OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput[]
    connectOrCreate?: OperationMessageTranslationCreateOrConnectWithoutOperation_messageInput | OperationMessageTranslationCreateOrConnectWithoutOperation_messageInput[]
    createMany?: OperationMessageTranslationCreateManyOperation_messageInputEnvelope
    connect?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
  }

  export type OperationMessageTranslationUpdateManyWithoutOperation_messageNestedInput = {
    create?: XOR<OperationMessageTranslationCreateWithoutOperation_messageInput, OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput> | OperationMessageTranslationCreateWithoutOperation_messageInput[] | OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput[]
    connectOrCreate?: OperationMessageTranslationCreateOrConnectWithoutOperation_messageInput | OperationMessageTranslationCreateOrConnectWithoutOperation_messageInput[]
    upsert?: OperationMessageTranslationUpsertWithWhereUniqueWithoutOperation_messageInput | OperationMessageTranslationUpsertWithWhereUniqueWithoutOperation_messageInput[]
    createMany?: OperationMessageTranslationCreateManyOperation_messageInputEnvelope
    set?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
    disconnect?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
    delete?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
    connect?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
    update?: OperationMessageTranslationUpdateWithWhereUniqueWithoutOperation_messageInput | OperationMessageTranslationUpdateWithWhereUniqueWithoutOperation_messageInput[]
    updateMany?: OperationMessageTranslationUpdateManyWithWhereWithoutOperation_messageInput | OperationMessageTranslationUpdateManyWithWhereWithoutOperation_messageInput[]
    deleteMany?: OperationMessageTranslationScalarWhereInput | OperationMessageTranslationScalarWhereInput[]
  }

  export type OperationMessageTranslationUncheckedUpdateManyWithoutOperation_messageNestedInput = {
    create?: XOR<OperationMessageTranslationCreateWithoutOperation_messageInput, OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput> | OperationMessageTranslationCreateWithoutOperation_messageInput[] | OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput[]
    connectOrCreate?: OperationMessageTranslationCreateOrConnectWithoutOperation_messageInput | OperationMessageTranslationCreateOrConnectWithoutOperation_messageInput[]
    upsert?: OperationMessageTranslationUpsertWithWhereUniqueWithoutOperation_messageInput | OperationMessageTranslationUpsertWithWhereUniqueWithoutOperation_messageInput[]
    createMany?: OperationMessageTranslationCreateManyOperation_messageInputEnvelope
    set?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
    disconnect?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
    delete?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
    connect?: OperationMessageTranslationWhereUniqueInput | OperationMessageTranslationWhereUniqueInput[]
    update?: OperationMessageTranslationUpdateWithWhereUniqueWithoutOperation_messageInput | OperationMessageTranslationUpdateWithWhereUniqueWithoutOperation_messageInput[]
    updateMany?: OperationMessageTranslationUpdateManyWithWhereWithoutOperation_messageInput | OperationMessageTranslationUpdateManyWithWhereWithoutOperation_messageInput[]
    deleteMany?: OperationMessageTranslationScalarWhereInput | OperationMessageTranslationScalarWhereInput[]
  }

  export type OperationMessageCreateNestedOneWithoutOperation_message_translationsInput = {
    create?: XOR<OperationMessageCreateWithoutOperation_message_translationsInput, OperationMessageUncheckedCreateWithoutOperation_message_translationsInput>
    connectOrCreate?: OperationMessageCreateOrConnectWithoutOperation_message_translationsInput
    connect?: OperationMessageWhereUniqueInput
  }

  export type OperationMessageUpdateOneRequiredWithoutOperation_message_translationsNestedInput = {
    create?: XOR<OperationMessageCreateWithoutOperation_message_translationsInput, OperationMessageUncheckedCreateWithoutOperation_message_translationsInput>
    connectOrCreate?: OperationMessageCreateOrConnectWithoutOperation_message_translationsInput
    upsert?: OperationMessageUpsertWithoutOperation_message_translationsInput
    connect?: OperationMessageWhereUniqueInput
    update?: XOR<XOR<OperationMessageUpdateToOneWithWhereWithoutOperation_message_translationsInput, OperationMessageUpdateWithoutOperation_message_translationsInput>, OperationMessageUncheckedUpdateWithoutOperation_message_translationsInput>
  }

  export type OrganizationCreateNestedOneWithoutInvite_codeInput = {
    create?: XOR<OrganizationCreateWithoutInvite_codeInput, OrganizationUncheckedCreateWithoutInvite_codeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvite_codeInput
    connect?: OrganizationWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrganizationUpdateOneRequiredWithoutInvite_codeNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvite_codeInput, OrganizationUncheckedCreateWithoutInvite_codeInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvite_codeInput
    upsert?: OrganizationUpsertWithoutInvite_codeInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvite_codeInput, OrganizationUpdateWithoutInvite_codeInput>, OrganizationUncheckedUpdateWithoutInvite_codeInput>
  }

  export type ProductCreateNestedManyWithoutProduct_categoryInput = {
    create?: XOR<ProductCreateWithoutProduct_categoryInput, ProductUncheckedCreateWithoutProduct_categoryInput> | ProductCreateWithoutProduct_categoryInput[] | ProductUncheckedCreateWithoutProduct_categoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_categoryInput | ProductCreateOrConnectWithoutProduct_categoryInput[]
    createMany?: ProductCreateManyProduct_categoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProduct_categoryInput = {
    create?: XOR<ProductCreateWithoutProduct_categoryInput, ProductUncheckedCreateWithoutProduct_categoryInput> | ProductCreateWithoutProduct_categoryInput[] | ProductUncheckedCreateWithoutProduct_categoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_categoryInput | ProductCreateOrConnectWithoutProduct_categoryInput[]
    createMany?: ProductCreateManyProduct_categoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProduct_categoryNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_categoryInput, ProductUncheckedCreateWithoutProduct_categoryInput> | ProductCreateWithoutProduct_categoryInput[] | ProductUncheckedCreateWithoutProduct_categoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_categoryInput | ProductCreateOrConnectWithoutProduct_categoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_categoryInput | ProductUpsertWithWhereUniqueWithoutProduct_categoryInput[]
    createMany?: ProductCreateManyProduct_categoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_categoryInput | ProductUpdateWithWhereUniqueWithoutProduct_categoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_categoryInput | ProductUpdateManyWithWhereWithoutProduct_categoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProduct_categoryNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_categoryInput, ProductUncheckedCreateWithoutProduct_categoryInput> | ProductCreateWithoutProduct_categoryInput[] | ProductUncheckedCreateWithoutProduct_categoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_categoryInput | ProductCreateOrConnectWithoutProduct_categoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_categoryInput | ProductUpsertWithWhereUniqueWithoutProduct_categoryInput[]
    createMany?: ProductCreateManyProduct_categoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_categoryInput | ProductUpdateWithWhereUniqueWithoutProduct_categoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_categoryInput | ProductUpdateManyWithWhereWithoutProduct_categoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProduct_colorInput = {
    create?: XOR<ProductCreateWithoutProduct_colorInput, ProductUncheckedCreateWithoutProduct_colorInput> | ProductCreateWithoutProduct_colorInput[] | ProductUncheckedCreateWithoutProduct_colorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_colorInput | ProductCreateOrConnectWithoutProduct_colorInput[]
    createMany?: ProductCreateManyProduct_colorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProduct_colorInput = {
    create?: XOR<ProductCreateWithoutProduct_colorInput, ProductUncheckedCreateWithoutProduct_colorInput> | ProductCreateWithoutProduct_colorInput[] | ProductUncheckedCreateWithoutProduct_colorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_colorInput | ProductCreateOrConnectWithoutProduct_colorInput[]
    createMany?: ProductCreateManyProduct_colorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProduct_colorNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_colorInput, ProductUncheckedCreateWithoutProduct_colorInput> | ProductCreateWithoutProduct_colorInput[] | ProductUncheckedCreateWithoutProduct_colorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_colorInput | ProductCreateOrConnectWithoutProduct_colorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_colorInput | ProductUpsertWithWhereUniqueWithoutProduct_colorInput[]
    createMany?: ProductCreateManyProduct_colorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_colorInput | ProductUpdateWithWhereUniqueWithoutProduct_colorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_colorInput | ProductUpdateManyWithWhereWithoutProduct_colorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProduct_colorNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_colorInput, ProductUncheckedCreateWithoutProduct_colorInput> | ProductCreateWithoutProduct_colorInput[] | ProductUncheckedCreateWithoutProduct_colorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_colorInput | ProductCreateOrConnectWithoutProduct_colorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_colorInput | ProductUpsertWithWhereUniqueWithoutProduct_colorInput[]
    createMany?: ProductCreateManyProduct_colorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_colorInput | ProductUpdateWithWhereUniqueWithoutProduct_colorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_colorInput | ProductUpdateManyWithWhereWithoutProduct_colorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProduct_sizeInput = {
    create?: XOR<ProductCreateWithoutProduct_sizeInput, ProductUncheckedCreateWithoutProduct_sizeInput> | ProductCreateWithoutProduct_sizeInput[] | ProductUncheckedCreateWithoutProduct_sizeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_sizeInput | ProductCreateOrConnectWithoutProduct_sizeInput[]
    createMany?: ProductCreateManyProduct_sizeInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProduct_sizeInput = {
    create?: XOR<ProductCreateWithoutProduct_sizeInput, ProductUncheckedCreateWithoutProduct_sizeInput> | ProductCreateWithoutProduct_sizeInput[] | ProductUncheckedCreateWithoutProduct_sizeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_sizeInput | ProductCreateOrConnectWithoutProduct_sizeInput[]
    createMany?: ProductCreateManyProduct_sizeInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProduct_sizeNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_sizeInput, ProductUncheckedCreateWithoutProduct_sizeInput> | ProductCreateWithoutProduct_sizeInput[] | ProductUncheckedCreateWithoutProduct_sizeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_sizeInput | ProductCreateOrConnectWithoutProduct_sizeInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_sizeInput | ProductUpsertWithWhereUniqueWithoutProduct_sizeInput[]
    createMany?: ProductCreateManyProduct_sizeInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_sizeInput | ProductUpdateWithWhereUniqueWithoutProduct_sizeInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_sizeInput | ProductUpdateManyWithWhereWithoutProduct_sizeInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProduct_sizeNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_sizeInput, ProductUncheckedCreateWithoutProduct_sizeInput> | ProductCreateWithoutProduct_sizeInput[] | ProductUncheckedCreateWithoutProduct_sizeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_sizeInput | ProductCreateOrConnectWithoutProduct_sizeInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_sizeInput | ProductUpsertWithWhereUniqueWithoutProduct_sizeInput[]
    createMany?: ProductCreateManyProduct_sizeInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_sizeInput | ProductUpdateWithWhereUniqueWithoutProduct_sizeInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_sizeInput | ProductUpdateManyWithWhereWithoutProduct_sizeInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProdut_voltageInput = {
    create?: XOR<ProductCreateWithoutProdut_voltageInput, ProductUncheckedCreateWithoutProdut_voltageInput> | ProductCreateWithoutProdut_voltageInput[] | ProductUncheckedCreateWithoutProdut_voltageInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProdut_voltageInput | ProductCreateOrConnectWithoutProdut_voltageInput[]
    createMany?: ProductCreateManyProdut_voltageInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProdut_voltageInput = {
    create?: XOR<ProductCreateWithoutProdut_voltageInput, ProductUncheckedCreateWithoutProdut_voltageInput> | ProductCreateWithoutProdut_voltageInput[] | ProductUncheckedCreateWithoutProdut_voltageInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProdut_voltageInput | ProductCreateOrConnectWithoutProdut_voltageInput[]
    createMany?: ProductCreateManyProdut_voltageInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProdut_voltageNestedInput = {
    create?: XOR<ProductCreateWithoutProdut_voltageInput, ProductUncheckedCreateWithoutProdut_voltageInput> | ProductCreateWithoutProdut_voltageInput[] | ProductUncheckedCreateWithoutProdut_voltageInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProdut_voltageInput | ProductCreateOrConnectWithoutProdut_voltageInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProdut_voltageInput | ProductUpsertWithWhereUniqueWithoutProdut_voltageInput[]
    createMany?: ProductCreateManyProdut_voltageInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProdut_voltageInput | ProductUpdateWithWhereUniqueWithoutProdut_voltageInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProdut_voltageInput | ProductUpdateManyWithWhereWithoutProdut_voltageInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProdut_voltageNestedInput = {
    create?: XOR<ProductCreateWithoutProdut_voltageInput, ProductUncheckedCreateWithoutProdut_voltageInput> | ProductCreateWithoutProdut_voltageInput[] | ProductUncheckedCreateWithoutProdut_voltageInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProdut_voltageInput | ProductCreateOrConnectWithoutProdut_voltageInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProdut_voltageInput | ProductUpsertWithWhereUniqueWithoutProdut_voltageInput[]
    createMany?: ProductCreateManyProdut_voltageInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProdut_voltageInput | ProductUpdateWithWhereUniqueWithoutProdut_voltageInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProdut_voltageInput | ProductUpdateManyWithWhereWithoutProdut_voltageInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProduct_flavorInput = {
    create?: XOR<ProductCreateWithoutProduct_flavorInput, ProductUncheckedCreateWithoutProduct_flavorInput> | ProductCreateWithoutProduct_flavorInput[] | ProductUncheckedCreateWithoutProduct_flavorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_flavorInput | ProductCreateOrConnectWithoutProduct_flavorInput[]
    createMany?: ProductCreateManyProduct_flavorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProduct_flavorInput = {
    create?: XOR<ProductCreateWithoutProduct_flavorInput, ProductUncheckedCreateWithoutProduct_flavorInput> | ProductCreateWithoutProduct_flavorInput[] | ProductUncheckedCreateWithoutProduct_flavorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_flavorInput | ProductCreateOrConnectWithoutProduct_flavorInput[]
    createMany?: ProductCreateManyProduct_flavorInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProduct_flavorNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_flavorInput, ProductUncheckedCreateWithoutProduct_flavorInput> | ProductCreateWithoutProduct_flavorInput[] | ProductUncheckedCreateWithoutProduct_flavorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_flavorInput | ProductCreateOrConnectWithoutProduct_flavorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_flavorInput | ProductUpsertWithWhereUniqueWithoutProduct_flavorInput[]
    createMany?: ProductCreateManyProduct_flavorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_flavorInput | ProductUpdateWithWhereUniqueWithoutProduct_flavorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_flavorInput | ProductUpdateManyWithWhereWithoutProduct_flavorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProduct_flavorNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_flavorInput, ProductUncheckedCreateWithoutProduct_flavorInput> | ProductCreateWithoutProduct_flavorInput[] | ProductUncheckedCreateWithoutProduct_flavorInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_flavorInput | ProductCreateOrConnectWithoutProduct_flavorInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_flavorInput | ProductUpsertWithWhereUniqueWithoutProduct_flavorInput[]
    createMany?: ProductCreateManyProduct_flavorInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_flavorInput | ProductUpdateWithWhereUniqueWithoutProduct_flavorInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_flavorInput | ProductUpdateManyWithWhereWithoutProduct_flavorInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProduct_powerInput = {
    create?: XOR<ProductCreateWithoutProduct_powerInput, ProductUncheckedCreateWithoutProduct_powerInput> | ProductCreateWithoutProduct_powerInput[] | ProductUncheckedCreateWithoutProduct_powerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_powerInput | ProductCreateOrConnectWithoutProduct_powerInput[]
    createMany?: ProductCreateManyProduct_powerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProduct_powerInput = {
    create?: XOR<ProductCreateWithoutProduct_powerInput, ProductUncheckedCreateWithoutProduct_powerInput> | ProductCreateWithoutProduct_powerInput[] | ProductUncheckedCreateWithoutProduct_powerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_powerInput | ProductCreateOrConnectWithoutProduct_powerInput[]
    createMany?: ProductCreateManyProduct_powerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProduct_powerNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_powerInput, ProductUncheckedCreateWithoutProduct_powerInput> | ProductCreateWithoutProduct_powerInput[] | ProductUncheckedCreateWithoutProduct_powerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_powerInput | ProductCreateOrConnectWithoutProduct_powerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_powerInput | ProductUpsertWithWhereUniqueWithoutProduct_powerInput[]
    createMany?: ProductCreateManyProduct_powerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_powerInput | ProductUpdateWithWhereUniqueWithoutProduct_powerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_powerInput | ProductUpdateManyWithWhereWithoutProduct_powerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProduct_powerNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_powerInput, ProductUncheckedCreateWithoutProduct_powerInput> | ProductCreateWithoutProduct_powerInput[] | ProductUncheckedCreateWithoutProduct_powerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_powerInput | ProductCreateOrConnectWithoutProduct_powerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_powerInput | ProductUpsertWithWhereUniqueWithoutProduct_powerInput[]
    createMany?: ProductCreateManyProduct_powerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_powerInput | ProductUpdateWithWhereUniqueWithoutProduct_powerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_powerInput | ProductUpdateManyWithWhereWithoutProduct_powerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutSales_channelsInput = {
    create?: XOR<ProductCreateWithoutSales_channelsInput, ProductUncheckedCreateWithoutSales_channelsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSales_channelsInput
    connect?: ProductWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneWithoutSales_channelsNestedInput = {
    create?: XOR<ProductCreateWithoutSales_channelsInput, ProductUncheckedCreateWithoutSales_channelsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSales_channelsInput
    upsert?: ProductUpsertWithoutSales_channelsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSales_channelsInput, ProductUpdateWithoutSales_channelsInput>, ProductUncheckedUpdateWithoutSales_channelsInput>
  }

  export type ProductCreateNestedManyWithoutProduct_custom_categoryInput = {
    create?: XOR<ProductCreateWithoutProduct_custom_categoryInput, ProductUncheckedCreateWithoutProduct_custom_categoryInput> | ProductCreateWithoutProduct_custom_categoryInput[] | ProductUncheckedCreateWithoutProduct_custom_categoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_custom_categoryInput | ProductCreateOrConnectWithoutProduct_custom_categoryInput[]
    createMany?: ProductCreateManyProduct_custom_categoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProduct_custom_categoryInput = {
    create?: XOR<ProductCreateWithoutProduct_custom_categoryInput, ProductUncheckedCreateWithoutProduct_custom_categoryInput> | ProductCreateWithoutProduct_custom_categoryInput[] | ProductUncheckedCreateWithoutProduct_custom_categoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_custom_categoryInput | ProductCreateOrConnectWithoutProduct_custom_categoryInput[]
    createMany?: ProductCreateManyProduct_custom_categoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProduct_custom_categoryNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_custom_categoryInput, ProductUncheckedCreateWithoutProduct_custom_categoryInput> | ProductCreateWithoutProduct_custom_categoryInput[] | ProductUncheckedCreateWithoutProduct_custom_categoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_custom_categoryInput | ProductCreateOrConnectWithoutProduct_custom_categoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_custom_categoryInput | ProductUpsertWithWhereUniqueWithoutProduct_custom_categoryInput[]
    createMany?: ProductCreateManyProduct_custom_categoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_custom_categoryInput | ProductUpdateWithWhereUniqueWithoutProduct_custom_categoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_custom_categoryInput | ProductUpdateManyWithWhereWithoutProduct_custom_categoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProduct_custom_categoryNestedInput = {
    create?: XOR<ProductCreateWithoutProduct_custom_categoryInput, ProductUncheckedCreateWithoutProduct_custom_categoryInput> | ProductCreateWithoutProduct_custom_categoryInput[] | ProductUncheckedCreateWithoutProduct_custom_categoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProduct_custom_categoryInput | ProductCreateOrConnectWithoutProduct_custom_categoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProduct_custom_categoryInput | ProductUpsertWithWhereUniqueWithoutProduct_custom_categoryInput[]
    createMany?: ProductCreateManyProduct_custom_categoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProduct_custom_categoryInput | ProductUpdateWithWhereUniqueWithoutProduct_custom_categoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProduct_custom_categoryInput | ProductUpdateManyWithWhereWithoutProduct_custom_categoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateimagesInput = {
    set: string[]
  }

  export type ProductCreatemeta_fieldsInput = {
    set: InputJsonValue[]
  }

  export type ProductCreatevideosInput = {
    set: string[]
  }

  export type SaleChannelCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleChannelCreateWithoutProductInput, SaleChannelUncheckedCreateWithoutProductInput> | SaleChannelCreateWithoutProductInput[] | SaleChannelUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleChannelCreateOrConnectWithoutProductInput | SaleChannelCreateOrConnectWithoutProductInput[]
    createMany?: SaleChannelCreateManyProductInputEnvelope
    connect?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
  }

  export type ProductColorCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductColorCreateWithoutProductInput, ProductColorUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutProductInput
    connect?: ProductColorWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type ProductSizeCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput
    connect?: ProductSizeWhereUniqueInput
  }

  export type ProductCustomCategoryCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductCustomCategoryCreateWithoutProductInput, ProductCustomCategoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductCustomCategoryCreateOrConnectWithoutProductInput
    connect?: ProductCustomCategoryWhereUniqueInput
  }

  export type ProductFlavorCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductFlavorCreateWithoutProductInput, ProductFlavorUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductFlavorCreateOrConnectWithoutProductInput
    connect?: ProductFlavorWhereUniqueInput
  }

  export type ProductPowerCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductPowerCreateWithoutProductInput, ProductPowerUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductPowerCreateOrConnectWithoutProductInput
    connect?: ProductPowerWhereUniqueInput
  }

  export type ProductVoltageCreateNestedOneWithoutProductInput = {
    create?: XOR<ProductVoltageCreateWithoutProductInput, ProductVoltageUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductVoltageCreateOrConnectWithoutProductInput
    connect?: ProductVoltageWhereUniqueInput
  }

  export type SaleChannelUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleChannelCreateWithoutProductInput, SaleChannelUncheckedCreateWithoutProductInput> | SaleChannelCreateWithoutProductInput[] | SaleChannelUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleChannelCreateOrConnectWithoutProductInput | SaleChannelCreateOrConnectWithoutProductInput[]
    createMany?: SaleChannelCreateManyProductInputEnvelope
    connect?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdatemeta_fieldsInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type ProductUpdatevideosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SaleChannelUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleChannelCreateWithoutProductInput, SaleChannelUncheckedCreateWithoutProductInput> | SaleChannelCreateWithoutProductInput[] | SaleChannelUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleChannelCreateOrConnectWithoutProductInput | SaleChannelCreateOrConnectWithoutProductInput[]
    upsert?: SaleChannelUpsertWithWhereUniqueWithoutProductInput | SaleChannelUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleChannelCreateManyProductInputEnvelope
    set?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
    disconnect?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
    delete?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
    connect?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
    update?: SaleChannelUpdateWithWhereUniqueWithoutProductInput | SaleChannelUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleChannelUpdateManyWithWhereWithoutProductInput | SaleChannelUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleChannelScalarWhereInput | SaleChannelScalarWhereInput[]
  }

  export type ProductColorUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductColorCreateWithoutProductInput, ProductColorUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductColorCreateOrConnectWithoutProductInput
    upsert?: ProductColorUpsertWithoutProductInput
    disconnect?: ProductColorWhereInput | boolean
    delete?: ProductColorWhereInput | boolean
    connect?: ProductColorWhereUniqueInput
    update?: XOR<XOR<ProductColorUpdateToOneWithWhereWithoutProductInput, ProductColorUpdateWithoutProductInput>, ProductColorUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput
    upsert?: ProductCategoryUpsertWithoutProductInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductInput, ProductCategoryUpdateWithoutProductInput>, ProductCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductSizeUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput
    upsert?: ProductSizeUpsertWithoutProductInput
    disconnect?: ProductSizeWhereInput | boolean
    delete?: ProductSizeWhereInput | boolean
    connect?: ProductSizeWhereUniqueInput
    update?: XOR<XOR<ProductSizeUpdateToOneWithWhereWithoutProductInput, ProductSizeUpdateWithoutProductInput>, ProductSizeUncheckedUpdateWithoutProductInput>
  }

  export type ProductCustomCategoryUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductCustomCategoryCreateWithoutProductInput, ProductCustomCategoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductCustomCategoryCreateOrConnectWithoutProductInput
    upsert?: ProductCustomCategoryUpsertWithoutProductInput
    disconnect?: ProductCustomCategoryWhereInput | boolean
    delete?: ProductCustomCategoryWhereInput | boolean
    connect?: ProductCustomCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCustomCategoryUpdateToOneWithWhereWithoutProductInput, ProductCustomCategoryUpdateWithoutProductInput>, ProductCustomCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductFlavorUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductFlavorCreateWithoutProductInput, ProductFlavorUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductFlavorCreateOrConnectWithoutProductInput
    upsert?: ProductFlavorUpsertWithoutProductInput
    disconnect?: ProductFlavorWhereInput | boolean
    delete?: ProductFlavorWhereInput | boolean
    connect?: ProductFlavorWhereUniqueInput
    update?: XOR<XOR<ProductFlavorUpdateToOneWithWhereWithoutProductInput, ProductFlavorUpdateWithoutProductInput>, ProductFlavorUncheckedUpdateWithoutProductInput>
  }

  export type ProductPowerUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductPowerCreateWithoutProductInput, ProductPowerUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductPowerCreateOrConnectWithoutProductInput
    upsert?: ProductPowerUpsertWithoutProductInput
    disconnect?: ProductPowerWhereInput | boolean
    delete?: ProductPowerWhereInput | boolean
    connect?: ProductPowerWhereUniqueInput
    update?: XOR<XOR<ProductPowerUpdateToOneWithWhereWithoutProductInput, ProductPowerUpdateWithoutProductInput>, ProductPowerUncheckedUpdateWithoutProductInput>
  }

  export type ProductVoltageUpdateOneWithoutProductNestedInput = {
    create?: XOR<ProductVoltageCreateWithoutProductInput, ProductVoltageUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProductVoltageCreateOrConnectWithoutProductInput
    upsert?: ProductVoltageUpsertWithoutProductInput
    disconnect?: ProductVoltageWhereInput | boolean
    delete?: ProductVoltageWhereInput | boolean
    connect?: ProductVoltageWhereUniqueInput
    update?: XOR<XOR<ProductVoltageUpdateToOneWithWhereWithoutProductInput, ProductVoltageUpdateWithoutProductInput>, ProductVoltageUncheckedUpdateWithoutProductInput>
  }

  export type SaleChannelUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleChannelCreateWithoutProductInput, SaleChannelUncheckedCreateWithoutProductInput> | SaleChannelCreateWithoutProductInput[] | SaleChannelUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleChannelCreateOrConnectWithoutProductInput | SaleChannelCreateOrConnectWithoutProductInput[]
    upsert?: SaleChannelUpsertWithWhereUniqueWithoutProductInput | SaleChannelUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleChannelCreateManyProductInputEnvelope
    set?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
    disconnect?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
    delete?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
    connect?: SaleChannelWhereUniqueInput | SaleChannelWhereUniqueInput[]
    update?: SaleChannelUpdateWithWhereUniqueWithoutProductInput | SaleChannelUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleChannelUpdateManyWithWhereWithoutProductInput | SaleChannelUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleChannelScalarWhereInput | SaleChannelScalarWhereInput[]
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type OrganizationCreateWithoutOwnerInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    members?: MemberCreateNestedManyWithoutOrganizationInput
    customer?: CustomerCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeCreateNestedManyWithoutOrganizationInput
    profile?: ProfileCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutOwnerInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    customer?: CustomerUncheckedCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeUncheckedCreateNestedManyWithoutOrganizationInput
    profile?: ProfileUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutOwnerInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
  }

  export type OrganizationCreateManyOwnerInputEnvelope = {
    data: OrganizationCreateManyOwnerInput | OrganizationCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutUserInput = {
    role: $Enums.Role
    created_at?: Date | string
    updated_at?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    role: $Enums.Role
    organization_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: MemberCreateManyUserInput | MemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    profile_avatar?: string | null
    profile_cover?: string | null
    username: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    organization?: OrganizationCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    profile_avatar?: string | null
    profile_cover?: string | null
    organization_id?: string | null
    username: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type OrganizationUpsertWithWhereUniqueWithoutOwnerInput = {
    where: OrganizationWhereUniqueInput
    update: XOR<OrganizationUpdateWithoutOwnerInput, OrganizationUncheckedUpdateWithoutOwnerInput>
    create: XOR<OrganizationCreateWithoutOwnerInput, OrganizationUncheckedCreateWithoutOwnerInput>
  }

  export type OrganizationUpdateWithWhereUniqueWithoutOwnerInput = {
    where: OrganizationWhereUniqueInput
    data: XOR<OrganizationUpdateWithoutOwnerInput, OrganizationUncheckedUpdateWithoutOwnerInput>
  }

  export type OrganizationUpdateManyWithWhereWithoutOwnerInput = {
    where: OrganizationScalarWhereInput
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyWithoutOwnerInput>
  }

  export type OrganizationScalarWhereInput = {
    AND?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
    OR?: OrganizationScalarWhereInput[]
    NOT?: OrganizationScalarWhereInput | OrganizationScalarWhereInput[]
    id?: UuidFilter<"Organization"> | string
    zip_code?: StringNullableFilter<"Organization"> | string | null
    active?: BoolFilter<"Organization"> | boolean
    business_name?: StringFilter<"Organization"> | string
    address_one?: StringNullableFilter<"Organization"> | string | null
    address_two?: StringNullableFilter<"Organization"> | string | null
    fantasy_name?: StringFilter<"Organization"> | string
    email?: StringFilter<"Organization"> | string
    phone_number?: StringFilter<"Organization"> | string
    website?: StringNullableFilter<"Organization"> | string | null
    registration_number?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    owner_id?: UuidFilter<"Organization"> | string
    created_at?: DateTimeFilter<"Organization"> | Date | string
    updated_at?: DateTimeFilter<"Organization"> | Date | string
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutUserInput>
  }

  export type MemberScalarWhereInput = {
    AND?: MemberScalarWhereInput | MemberScalarWhereInput[]
    OR?: MemberScalarWhereInput[]
    NOT?: MemberScalarWhereInput | MemberScalarWhereInput[]
    user_id?: UuidFilter<"Member"> | string
    role?: EnumRoleFilter<"Member"> | $Enums.Role
    organization_id?: UuidFilter<"Member"> | string
    created_at?: DateTimeFilter<"Member"> | Date | string
    updated_at?: DateTimeFilter<"Member"> | Date | string
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    profile_cover?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    profile_cover?: NullableStringFieldUpdateOperationsInput | string | null
    organization_id?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUser_organizationsInput = {
    id?: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender?: string | null
    phone?: string | null
    active?: boolean
    visitor?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    teams?: MemberCreateNestedManyWithoutUserInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_organizationsInput = {
    id?: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender?: string | null
    phone?: string | null
    active?: boolean
    visitor?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    teams?: MemberUncheckedCreateNestedManyWithoutUserInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_organizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_organizationsInput, UserUncheckedCreateWithoutUser_organizationsInput>
  }

  export type MemberCreateWithoutOrganizationInput = {
    role: $Enums.Role
    created_at?: Date | string
    updated_at?: Date | string
    user: UserCreateNestedOneWithoutTeamsInput
  }

  export type MemberUncheckedCreateWithoutOrganizationInput = {
    user_id: string
    role: $Enums.Role
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MemberCreateOrConnectWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberCreateManyOrganizationInputEnvelope = {
    data: MemberCreateManyOrganizationInput | MemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    second_name?: string | null
    whatsapp?: string | null
    shop_name: string
    address_line_one?: string | null
    address_line_two?: string | null
    email: string
    second_phone?: string | null
    vat_rate_id: string
    currency_id: string
    agent_id: string
    active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    second_name?: string | null
    whatsapp?: string | null
    shop_name: string
    address_line_one?: string | null
    address_line_two?: string | null
    email: string
    second_phone?: string | null
    vat_rate_id: string
    currency_id: string
    agent_id: string
    active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerCreateOrConnectWithoutOrganizationInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrganizationInput, CustomerUncheckedCreateWithoutOrganizationInput>
  }

  export type CustomerCreateManyOrganizationInputEnvelope = {
    data: CustomerCreateManyOrganizationInput | CustomerCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type InviteCodeCreateWithoutOrganizationInput = {
    id?: string
    code: string
    expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    used?: boolean
  }

  export type InviteCodeUncheckedCreateWithoutOrganizationInput = {
    id?: string
    code: string
    expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    used?: boolean
  }

  export type InviteCodeCreateOrConnectWithoutOrganizationInput = {
    where: InviteCodeWhereUniqueInput
    create: XOR<InviteCodeCreateWithoutOrganizationInput, InviteCodeUncheckedCreateWithoutOrganizationInput>
  }

  export type InviteCodeCreateManyOrganizationInputEnvelope = {
    data: InviteCodeCreateManyOrganizationInput | InviteCodeCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutOrganizationInput = {
    id?: string
    profile_avatar?: string | null
    profile_cover?: string | null
    username: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    user?: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutOrganizationInput = {
    id?: string
    profile_avatar?: string | null
    profile_cover?: string | null
    user_id?: string | null
    username: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProfileCreateOrConnectWithoutOrganizationInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutOrganizationInput, ProfileUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpsertWithoutUser_organizationsInput = {
    update: XOR<UserUpdateWithoutUser_organizationsInput, UserUncheckedUpdateWithoutUser_organizationsInput>
    create: XOR<UserCreateWithoutUser_organizationsInput, UserUncheckedCreateWithoutUser_organizationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_organizationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_organizationsInput, UserUncheckedUpdateWithoutUser_organizationsInput>
  }

  export type UserUpdateWithoutUser_organizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: MemberUpdateManyWithoutUserNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_organizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: MemberUncheckedUpdateManyWithoutUserNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type MemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MemberCreateWithoutOrganizationInput, MemberUncheckedCreateWithoutOrganizationInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutOrganizationInput, MemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type MemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutOrganizationInput, CustomerUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CustomerCreateWithoutOrganizationInput, CustomerUncheckedCreateWithoutOrganizationInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutOrganizationInput, CustomerUncheckedUpdateWithoutOrganizationInput>
  }

  export type CustomerUpdateManyWithWhereWithoutOrganizationInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: UuidFilter<"Customer"> | string
    name?: StringNullableFilter<"Customer"> | string | null
    second_name?: StringNullableFilter<"Customer"> | string | null
    whatsapp?: StringNullableFilter<"Customer"> | string | null
    shop_name?: StringFilter<"Customer"> | string
    address_line_one?: StringNullableFilter<"Customer"> | string | null
    address_line_two?: StringNullableFilter<"Customer"> | string | null
    email?: StringFilter<"Customer"> | string
    second_phone?: StringNullableFilter<"Customer"> | string | null
    vat_rate_id?: UuidFilter<"Customer"> | string
    currency_id?: UuidFilter<"Customer"> | string
    agent_id?: UuidFilter<"Customer"> | string
    active?: BoolFilter<"Customer"> | boolean
    organization_id?: UuidFilter<"Customer"> | string
    created_at?: DateTimeFilter<"Customer"> | Date | string
    updated_at?: DateTimeFilter<"Customer"> | Date | string
  }

  export type InviteCodeUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: InviteCodeWhereUniqueInput
    update: XOR<InviteCodeUpdateWithoutOrganizationInput, InviteCodeUncheckedUpdateWithoutOrganizationInput>
    create: XOR<InviteCodeCreateWithoutOrganizationInput, InviteCodeUncheckedCreateWithoutOrganizationInput>
  }

  export type InviteCodeUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: InviteCodeWhereUniqueInput
    data: XOR<InviteCodeUpdateWithoutOrganizationInput, InviteCodeUncheckedUpdateWithoutOrganizationInput>
  }

  export type InviteCodeUpdateManyWithWhereWithoutOrganizationInput = {
    where: InviteCodeScalarWhereInput
    data: XOR<InviteCodeUpdateManyMutationInput, InviteCodeUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type InviteCodeScalarWhereInput = {
    AND?: InviteCodeScalarWhereInput | InviteCodeScalarWhereInput[]
    OR?: InviteCodeScalarWhereInput[]
    NOT?: InviteCodeScalarWhereInput | InviteCodeScalarWhereInput[]
    id?: UuidFilter<"InviteCode"> | string
    code?: StringFilter<"InviteCode"> | string
    expires_at?: DateTimeNullableFilter<"InviteCode"> | Date | string | null
    created_at?: DateTimeFilter<"InviteCode"> | Date | string
    updated_at?: DateTimeFilter<"InviteCode"> | Date | string
    used?: BoolFilter<"InviteCode"> | boolean
    organization_id?: UuidFilter<"InviteCode"> | string
  }

  export type ProfileUpsertWithoutOrganizationInput = {
    update: XOR<ProfileUpdateWithoutOrganizationInput, ProfileUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProfileCreateWithoutOrganizationInput, ProfileUncheckedCreateWithoutOrganizationInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutOrganizationInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutOrganizationInput, ProfileUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProfileUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    profile_cover?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profile_avatar?: NullableStringFieldUpdateOperationsInput | string | null
    profile_cover?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender?: string | null
    phone?: string | null
    active?: boolean
    visitor?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    user_organizations?: OrganizationCreateNestedManyWithoutOwnerInput
    teams?: MemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender?: string | null
    phone?: string | null
    active?: boolean
    visitor?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    user_organizations?: OrganizationUncheckedCreateNestedManyWithoutOwnerInput
    teams?: MemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type OrganizationCreateWithoutProfileInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutUser_organizationsInput
    members?: MemberCreateNestedManyWithoutOrganizationInput
    customer?: CustomerCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProfileInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    owner_id: string
    created_at?: Date | string
    updated_at?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    customer?: CustomerUncheckedCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProfileInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_organizations?: OrganizationUpdateManyWithoutOwnerNestedInput
    teams?: MemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_organizations?: OrganizationUncheckedUpdateManyWithoutOwnerNestedInput
    teams?: MemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutProfileInput = {
    update: XOR<OrganizationUpdateWithoutProfileInput, OrganizationUncheckedUpdateWithoutProfileInput>
    create: XOR<OrganizationCreateWithoutProfileInput, OrganizationUncheckedCreateWithoutProfileInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProfileInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProfileInput, OrganizationUncheckedUpdateWithoutProfileInput>
  }

  export type OrganizationUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutUser_organizationsNestedInput
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    customer?: CustomerUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    owner_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutTeamsInput = {
    id?: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender?: string | null
    phone?: string | null
    active?: boolean
    visitor?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    user_organizations?: OrganizationCreateNestedManyWithoutOwnerInput
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: string
    email: string
    password: string
    first_name: string
    last_name: string
    gender?: string | null
    phone?: string | null
    active?: boolean
    visitor?: boolean | null
    created_at?: Date | string
    updated_at?: Date | string
    user_organizations?: OrganizationUncheckedCreateNestedManyWithoutOwnerInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutUser_organizationsInput
    customer?: CustomerCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeCreateNestedManyWithoutOrganizationInput
    profile?: ProfileCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    owner_id: string
    created_at?: Date | string
    updated_at?: Date | string
    customer?: CustomerUncheckedCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeUncheckedCreateNestedManyWithoutOrganizationInput
    profile?: ProfileUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutTeamsInput = {
    update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_organizations?: OrganizationUpdateManyWithoutOwnerNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    visitor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_organizations?: OrganizationUncheckedUpdateManyWithoutOwnerNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutUser_organizationsNestedInput
    customer?: CustomerUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    owner_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUncheckedUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUncheckedUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutCustomerInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutUser_organizationsInput
    members?: MemberCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeCreateNestedManyWithoutOrganizationInput
    profile?: ProfileCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutCustomerInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    owner_id: string
    created_at?: Date | string
    updated_at?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    invite_code?: InviteCodeUncheckedCreateNestedManyWithoutOrganizationInput
    profile?: ProfileUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutCustomerInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutCustomerInput, OrganizationUncheckedCreateWithoutCustomerInput>
  }

  export type OrganizationUpsertWithoutCustomerInput = {
    update: XOR<OrganizationUpdateWithoutCustomerInput, OrganizationUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrganizationCreateWithoutCustomerInput, OrganizationUncheckedCreateWithoutCustomerInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutCustomerInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutCustomerInput, OrganizationUncheckedUpdateWithoutCustomerInput>
  }

  export type OrganizationUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutUser_organizationsNestedInput
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    owner_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUncheckedUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type OperationMessageTranslationCreateWithoutOperation_messageInput = {
    language_code: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput = {
    language_code: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OperationMessageTranslationCreateOrConnectWithoutOperation_messageInput = {
    where: OperationMessageTranslationWhereUniqueInput
    create: XOR<OperationMessageTranslationCreateWithoutOperation_messageInput, OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput>
  }

  export type OperationMessageTranslationCreateManyOperation_messageInputEnvelope = {
    data: OperationMessageTranslationCreateManyOperation_messageInput | OperationMessageTranslationCreateManyOperation_messageInput[]
    skipDuplicates?: boolean
  }

  export type OperationMessageTranslationUpsertWithWhereUniqueWithoutOperation_messageInput = {
    where: OperationMessageTranslationWhereUniqueInput
    update: XOR<OperationMessageTranslationUpdateWithoutOperation_messageInput, OperationMessageTranslationUncheckedUpdateWithoutOperation_messageInput>
    create: XOR<OperationMessageTranslationCreateWithoutOperation_messageInput, OperationMessageTranslationUncheckedCreateWithoutOperation_messageInput>
  }

  export type OperationMessageTranslationUpdateWithWhereUniqueWithoutOperation_messageInput = {
    where: OperationMessageTranslationWhereUniqueInput
    data: XOR<OperationMessageTranslationUpdateWithoutOperation_messageInput, OperationMessageTranslationUncheckedUpdateWithoutOperation_messageInput>
  }

  export type OperationMessageTranslationUpdateManyWithWhereWithoutOperation_messageInput = {
    where: OperationMessageTranslationScalarWhereInput
    data: XOR<OperationMessageTranslationUpdateManyMutationInput, OperationMessageTranslationUncheckedUpdateManyWithoutOperation_messageInput>
  }

  export type OperationMessageTranslationScalarWhereInput = {
    AND?: OperationMessageTranslationScalarWhereInput | OperationMessageTranslationScalarWhereInput[]
    OR?: OperationMessageTranslationScalarWhereInput[]
    NOT?: OperationMessageTranslationScalarWhereInput | OperationMessageTranslationScalarWhereInput[]
    language_code?: StringFilter<"OperationMessageTranslation"> | string
    message?: StringFilter<"OperationMessageTranslation"> | string
    created_at?: DateTimeFilter<"OperationMessageTranslation"> | Date | string
    updated_at?: DateTimeFilter<"OperationMessageTranslation"> | Date | string
    operation_message_id?: StringFilter<"OperationMessageTranslation"> | string
  }

  export type OperationMessageCreateWithoutOperation_message_translationsInput = {
    message: string
    type: string
    active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    id: string
  }

  export type OperationMessageUncheckedCreateWithoutOperation_message_translationsInput = {
    message: string
    type: string
    active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    id: string
  }

  export type OperationMessageCreateOrConnectWithoutOperation_message_translationsInput = {
    where: OperationMessageWhereUniqueInput
    create: XOR<OperationMessageCreateWithoutOperation_message_translationsInput, OperationMessageUncheckedCreateWithoutOperation_message_translationsInput>
  }

  export type OperationMessageUpsertWithoutOperation_message_translationsInput = {
    update: XOR<OperationMessageUpdateWithoutOperation_message_translationsInput, OperationMessageUncheckedUpdateWithoutOperation_message_translationsInput>
    create: XOR<OperationMessageCreateWithoutOperation_message_translationsInput, OperationMessageUncheckedCreateWithoutOperation_message_translationsInput>
    where?: OperationMessageWhereInput
  }

  export type OperationMessageUpdateToOneWithWhereWithoutOperation_message_translationsInput = {
    where?: OperationMessageWhereInput
    data: XOR<OperationMessageUpdateWithoutOperation_message_translationsInput, OperationMessageUncheckedUpdateWithoutOperation_message_translationsInput>
  }

  export type OperationMessageUpdateWithoutOperation_message_translationsInput = {
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type OperationMessageUncheckedUpdateWithoutOperation_message_translationsInput = {
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationCreateWithoutInvite_codeInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
    owner: UserCreateNestedOneWithoutUser_organizationsInput
    members?: MemberCreateNestedManyWithoutOrganizationInput
    customer?: CustomerCreateNestedManyWithoutOrganizationInput
    profile?: ProfileCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutInvite_codeInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    owner_id: string
    created_at?: Date | string
    updated_at?: Date | string
    members?: MemberUncheckedCreateNestedManyWithoutOrganizationInput
    customer?: CustomerUncheckedCreateNestedManyWithoutOrganizationInput
    profile?: ProfileUncheckedCreateNestedOneWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutInvite_codeInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvite_codeInput, OrganizationUncheckedCreateWithoutInvite_codeInput>
  }

  export type OrganizationUpsertWithoutInvite_codeInput = {
    update: XOR<OrganizationUpdateWithoutInvite_codeInput, OrganizationUncheckedUpdateWithoutInvite_codeInput>
    create: XOR<OrganizationCreateWithoutInvite_codeInput, OrganizationUncheckedCreateWithoutInvite_codeInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvite_codeInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvite_codeInput, OrganizationUncheckedUpdateWithoutInvite_codeInput>
  }

  export type OrganizationUpdateWithoutInvite_codeInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutUser_organizationsNestedInput
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    customer?: CustomerUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvite_codeInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    owner_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type ProductCreateWithoutProduct_categoryInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelCreateNestedManyWithoutProductInput
    product_color?: ProductColorCreateNestedOneWithoutProductInput
    product_size?: ProductSizeCreateNestedOneWithoutProductInput
    product_custom_category?: ProductCustomCategoryCreateNestedOneWithoutProductInput
    product_flavor?: ProductFlavorCreateNestedOneWithoutProductInput
    product_power?: ProductPowerCreateNestedOneWithoutProductInput
    produt_voltage?: ProductVoltageCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProduct_categoryInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_categoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_categoryInput, ProductUncheckedCreateWithoutProduct_categoryInput>
  }

  export type ProductCreateManyProduct_categoryInputEnvelope = {
    data: ProductCreateManyProduct_categoryInput | ProductCreateManyProduct_categoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProduct_categoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProduct_categoryInput, ProductUncheckedUpdateWithoutProduct_categoryInput>
    create: XOR<ProductCreateWithoutProduct_categoryInput, ProductUncheckedCreateWithoutProduct_categoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProduct_categoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProduct_categoryInput, ProductUncheckedUpdateWithoutProduct_categoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutProduct_categoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProduct_categoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: UuidFilter<"Product"> | string
    sku?: StringFilter<"Product"> | string
    active?: BoolNullableFilter<"Product"> | boolean | null
    brand?: StringNullableFilter<"Product"> | string | null
    category_id?: StringFilter<"Product"> | string
    color_id?: StringNullableFilter<"Product"> | string | null
    cross_docking_days?: IntNullableFilter<"Product"> | number | null
    description?: StringFilter<"Product"> | string
    gender?: StringNullableFilter<"Product"> | string | null
    height?: IntFilter<"Product"> | number
    length?: IntFilter<"Product"> | number
    images?: StringNullableListFilter<"Product">
    ean?: StringNullableFilter<"Product"> | string | null
    cost_price?: IntNullableFilter<"Product"> | number | null
    manufacturer_part_number?: IntNullableFilter<"Product"> | number | null
    model?: StringNullableFilter<"Product"> | string | null
    name?: StringFilter<"Product"> | string
    origin?: StringNullableFilter<"Product"> | string | null
    ncm?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    product_name?: StringNullableFilter<"Product"> | string | null
    size_id?: StringNullableFilter<"Product"> | string | null
    stock?: IntFilter<"Product"> | number
    warranty?: IntNullableFilter<"Product"> | number | null
    weight?: IntFilter<"Product"> | number
    width?: IntFilter<"Product"> | number
    custom_category_id?: UuidNullableFilter<"Product"> | string | null
    flavor_id?: StringNullableFilter<"Product"> | string | null
    measurement_unit?: StringNullableFilter<"Product"> | string | null
    unit_multiplier?: IntNullableFilter<"Product"> | number | null
    meta_fields?: JsonNullableListFilter<"Product">
    power_id?: StringNullableFilter<"Product"> | string | null
    sale_price?: FloatNullableFilter<"Product"> | number | null
    sale_date_start?: DateTimeNullableFilter<"Product"> | Date | string | null
    sale_date_end?: DateTimeNullableFilter<"Product"> | Date | string | null
    voltage_id?: StringNullableFilter<"Product"> | string | null
    videos?: StringNullableListFilter<"Product">
    created_at?: DateTimeFilter<"Product"> | Date | string
    updated_at?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductCreateWithoutProduct_colorInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelCreateNestedManyWithoutProductInput
    product_category: ProductCategoryCreateNestedOneWithoutProductInput
    product_size?: ProductSizeCreateNestedOneWithoutProductInput
    product_custom_category?: ProductCustomCategoryCreateNestedOneWithoutProductInput
    product_flavor?: ProductFlavorCreateNestedOneWithoutProductInput
    product_power?: ProductPowerCreateNestedOneWithoutProductInput
    produt_voltage?: ProductVoltageCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProduct_colorInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_colorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_colorInput, ProductUncheckedCreateWithoutProduct_colorInput>
  }

  export type ProductCreateManyProduct_colorInputEnvelope = {
    data: ProductCreateManyProduct_colorInput | ProductCreateManyProduct_colorInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProduct_colorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProduct_colorInput, ProductUncheckedUpdateWithoutProduct_colorInput>
    create: XOR<ProductCreateWithoutProduct_colorInput, ProductUncheckedCreateWithoutProduct_colorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProduct_colorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProduct_colorInput, ProductUncheckedUpdateWithoutProduct_colorInput>
  }

  export type ProductUpdateManyWithWhereWithoutProduct_colorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProduct_colorInput>
  }

  export type ProductCreateWithoutProduct_sizeInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelCreateNestedManyWithoutProductInput
    product_color?: ProductColorCreateNestedOneWithoutProductInput
    product_category: ProductCategoryCreateNestedOneWithoutProductInput
    product_custom_category?: ProductCustomCategoryCreateNestedOneWithoutProductInput
    product_flavor?: ProductFlavorCreateNestedOneWithoutProductInput
    product_power?: ProductPowerCreateNestedOneWithoutProductInput
    produt_voltage?: ProductVoltageCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProduct_sizeInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_sizeInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_sizeInput, ProductUncheckedCreateWithoutProduct_sizeInput>
  }

  export type ProductCreateManyProduct_sizeInputEnvelope = {
    data: ProductCreateManyProduct_sizeInput | ProductCreateManyProduct_sizeInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProduct_sizeInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProduct_sizeInput, ProductUncheckedUpdateWithoutProduct_sizeInput>
    create: XOR<ProductCreateWithoutProduct_sizeInput, ProductUncheckedCreateWithoutProduct_sizeInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProduct_sizeInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProduct_sizeInput, ProductUncheckedUpdateWithoutProduct_sizeInput>
  }

  export type ProductUpdateManyWithWhereWithoutProduct_sizeInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProduct_sizeInput>
  }

  export type ProductCreateWithoutProdut_voltageInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelCreateNestedManyWithoutProductInput
    product_color?: ProductColorCreateNestedOneWithoutProductInput
    product_category: ProductCategoryCreateNestedOneWithoutProductInput
    product_size?: ProductSizeCreateNestedOneWithoutProductInput
    product_custom_category?: ProductCustomCategoryCreateNestedOneWithoutProductInput
    product_flavor?: ProductFlavorCreateNestedOneWithoutProductInput
    product_power?: ProductPowerCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProdut_voltageInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProdut_voltageInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProdut_voltageInput, ProductUncheckedCreateWithoutProdut_voltageInput>
  }

  export type ProductCreateManyProdut_voltageInputEnvelope = {
    data: ProductCreateManyProdut_voltageInput | ProductCreateManyProdut_voltageInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProdut_voltageInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProdut_voltageInput, ProductUncheckedUpdateWithoutProdut_voltageInput>
    create: XOR<ProductCreateWithoutProdut_voltageInput, ProductUncheckedCreateWithoutProdut_voltageInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProdut_voltageInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProdut_voltageInput, ProductUncheckedUpdateWithoutProdut_voltageInput>
  }

  export type ProductUpdateManyWithWhereWithoutProdut_voltageInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProdut_voltageInput>
  }

  export type ProductCreateWithoutProduct_flavorInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelCreateNestedManyWithoutProductInput
    product_color?: ProductColorCreateNestedOneWithoutProductInput
    product_category: ProductCategoryCreateNestedOneWithoutProductInput
    product_size?: ProductSizeCreateNestedOneWithoutProductInput
    product_custom_category?: ProductCustomCategoryCreateNestedOneWithoutProductInput
    product_power?: ProductPowerCreateNestedOneWithoutProductInput
    produt_voltage?: ProductVoltageCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProduct_flavorInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_flavorInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_flavorInput, ProductUncheckedCreateWithoutProduct_flavorInput>
  }

  export type ProductCreateManyProduct_flavorInputEnvelope = {
    data: ProductCreateManyProduct_flavorInput | ProductCreateManyProduct_flavorInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProduct_flavorInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProduct_flavorInput, ProductUncheckedUpdateWithoutProduct_flavorInput>
    create: XOR<ProductCreateWithoutProduct_flavorInput, ProductUncheckedCreateWithoutProduct_flavorInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProduct_flavorInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProduct_flavorInput, ProductUncheckedUpdateWithoutProduct_flavorInput>
  }

  export type ProductUpdateManyWithWhereWithoutProduct_flavorInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProduct_flavorInput>
  }

  export type ProductCreateWithoutProduct_powerInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelCreateNestedManyWithoutProductInput
    product_color?: ProductColorCreateNestedOneWithoutProductInput
    product_category: ProductCategoryCreateNestedOneWithoutProductInput
    product_size?: ProductSizeCreateNestedOneWithoutProductInput
    product_custom_category?: ProductCustomCategoryCreateNestedOneWithoutProductInput
    product_flavor?: ProductFlavorCreateNestedOneWithoutProductInput
    produt_voltage?: ProductVoltageCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProduct_powerInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_powerInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_powerInput, ProductUncheckedCreateWithoutProduct_powerInput>
  }

  export type ProductCreateManyProduct_powerInputEnvelope = {
    data: ProductCreateManyProduct_powerInput | ProductCreateManyProduct_powerInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProduct_powerInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProduct_powerInput, ProductUncheckedUpdateWithoutProduct_powerInput>
    create: XOR<ProductCreateWithoutProduct_powerInput, ProductUncheckedCreateWithoutProduct_powerInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProduct_powerInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProduct_powerInput, ProductUncheckedUpdateWithoutProduct_powerInput>
  }

  export type ProductUpdateManyWithWhereWithoutProduct_powerInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProduct_powerInput>
  }

  export type ProductCreateWithoutSales_channelsInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    product_color?: ProductColorCreateNestedOneWithoutProductInput
    product_category: ProductCategoryCreateNestedOneWithoutProductInput
    product_size?: ProductSizeCreateNestedOneWithoutProductInput
    product_custom_category?: ProductCustomCategoryCreateNestedOneWithoutProductInput
    product_flavor?: ProductFlavorCreateNestedOneWithoutProductInput
    product_power?: ProductPowerCreateNestedOneWithoutProductInput
    produt_voltage?: ProductVoltageCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSales_channelsInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductCreateOrConnectWithoutSales_channelsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSales_channelsInput, ProductUncheckedCreateWithoutSales_channelsInput>
  }

  export type ProductUpsertWithoutSales_channelsInput = {
    update: XOR<ProductUpdateWithoutSales_channelsInput, ProductUncheckedUpdateWithoutSales_channelsInput>
    create: XOR<ProductCreateWithoutSales_channelsInput, ProductUncheckedCreateWithoutSales_channelsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSales_channelsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSales_channelsInput, ProductUncheckedUpdateWithoutSales_channelsInput>
  }

  export type ProductUpdateWithoutSales_channelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_color?: ProductColorUpdateOneWithoutProductNestedInput
    product_category?: ProductCategoryUpdateOneRequiredWithoutProductNestedInput
    product_size?: ProductSizeUpdateOneWithoutProductNestedInput
    product_custom_category?: ProductCustomCategoryUpdateOneWithoutProductNestedInput
    product_flavor?: ProductFlavorUpdateOneWithoutProductNestedInput
    product_power?: ProductPowerUpdateOneWithoutProductNestedInput
    produt_voltage?: ProductVoltageUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSales_channelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutProduct_custom_categoryInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelCreateNestedManyWithoutProductInput
    product_color?: ProductColorCreateNestedOneWithoutProductInput
    product_category: ProductCategoryCreateNestedOneWithoutProductInput
    product_size?: ProductSizeCreateNestedOneWithoutProductInput
    product_flavor?: ProductFlavorCreateNestedOneWithoutProductInput
    product_power?: ProductPowerCreateNestedOneWithoutProductInput
    produt_voltage?: ProductVoltageCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProduct_custom_categoryInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
    sales_channels?: SaleChannelUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProduct_custom_categoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProduct_custom_categoryInput, ProductUncheckedCreateWithoutProduct_custom_categoryInput>
  }

  export type ProductCreateManyProduct_custom_categoryInputEnvelope = {
    data: ProductCreateManyProduct_custom_categoryInput | ProductCreateManyProduct_custom_categoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProduct_custom_categoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProduct_custom_categoryInput, ProductUncheckedUpdateWithoutProduct_custom_categoryInput>
    create: XOR<ProductCreateWithoutProduct_custom_categoryInput, ProductUncheckedCreateWithoutProduct_custom_categoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProduct_custom_categoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProduct_custom_categoryInput, ProductUncheckedUpdateWithoutProduct_custom_categoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutProduct_custom_categoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProduct_custom_categoryInput>
  }

  export type SaleChannelCreateWithoutProductInput = {
    id?: string
    sale_channel: string
    code: number
    channel_type: string
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleChannelUncheckedCreateWithoutProductInput = {
    id?: string
    sale_channel: string
    code: number
    channel_type: string
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleChannelCreateOrConnectWithoutProductInput = {
    where: SaleChannelWhereUniqueInput
    create: XOR<SaleChannelCreateWithoutProductInput, SaleChannelUncheckedCreateWithoutProductInput>
  }

  export type SaleChannelCreateManyProductInputEnvelope = {
    data: SaleChannelCreateManyProductInput | SaleChannelCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductColorCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductColorUncheckedCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductColorCreateOrConnectWithoutProductInput = {
    where: ProductColorWhereUniqueInput
    create: XOR<ProductColorCreateWithoutProductInput, ProductColorUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryCreateWithoutProductInput = {
    id: string
    name: string
    full_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductCategoryUncheckedCreateWithoutProductInput = {
    id: string
    name: string
    full_name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductCategoryCreateOrConnectWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductSizeCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductSizeUncheckedCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductSizeCreateOrConnectWithoutProductInput = {
    where: ProductSizeWhereUniqueInput
    create: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput>
  }

  export type ProductCustomCategoryCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductCustomCategoryUncheckedCreateWithoutProductInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductCustomCategoryCreateOrConnectWithoutProductInput = {
    where: ProductCustomCategoryWhereUniqueInput
    create: XOR<ProductCustomCategoryCreateWithoutProductInput, ProductCustomCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductFlavorCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductFlavorUncheckedCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductFlavorCreateOrConnectWithoutProductInput = {
    where: ProductFlavorWhereUniqueInput
    create: XOR<ProductFlavorCreateWithoutProductInput, ProductFlavorUncheckedCreateWithoutProductInput>
  }

  export type ProductPowerCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductPowerUncheckedCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductPowerCreateOrConnectWithoutProductInput = {
    where: ProductPowerWhereUniqueInput
    create: XOR<ProductPowerCreateWithoutProductInput, ProductPowerUncheckedCreateWithoutProductInput>
  }

  export type ProductVoltageCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductVoltageUncheckedCreateWithoutProductInput = {
    id: string
    attribute_name: string
    attribute_type: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductVoltageCreateOrConnectWithoutProductInput = {
    where: ProductVoltageWhereUniqueInput
    create: XOR<ProductVoltageCreateWithoutProductInput, ProductVoltageUncheckedCreateWithoutProductInput>
  }

  export type SaleChannelUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleChannelWhereUniqueInput
    update: XOR<SaleChannelUpdateWithoutProductInput, SaleChannelUncheckedUpdateWithoutProductInput>
    create: XOR<SaleChannelCreateWithoutProductInput, SaleChannelUncheckedCreateWithoutProductInput>
  }

  export type SaleChannelUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleChannelWhereUniqueInput
    data: XOR<SaleChannelUpdateWithoutProductInput, SaleChannelUncheckedUpdateWithoutProductInput>
  }

  export type SaleChannelUpdateManyWithWhereWithoutProductInput = {
    where: SaleChannelScalarWhereInput
    data: XOR<SaleChannelUpdateManyMutationInput, SaleChannelUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleChannelScalarWhereInput = {
    AND?: SaleChannelScalarWhereInput | SaleChannelScalarWhereInput[]
    OR?: SaleChannelScalarWhereInput[]
    NOT?: SaleChannelScalarWhereInput | SaleChannelScalarWhereInput[]
    id?: UuidFilter<"SaleChannel"> | string
    sale_channel?: StringFilter<"SaleChannel"> | string
    code?: IntFilter<"SaleChannel"> | number
    channel_type?: StringFilter<"SaleChannel"> | string
    product_id?: UuidNullableFilter<"SaleChannel"> | string | null
    sale_price?: FloatNullableFilter<"SaleChannel"> | number | null
    sale_date_start?: DateTimeNullableFilter<"SaleChannel"> | Date | string | null
    sale_date_end?: DateTimeNullableFilter<"SaleChannel"> | Date | string | null
    created_at?: DateTimeFilter<"SaleChannel"> | Date | string
    updated_at?: DateTimeFilter<"SaleChannel"> | Date | string
  }

  export type ProductColorUpsertWithoutProductInput = {
    update: XOR<ProductColorUpdateWithoutProductInput, ProductColorUncheckedUpdateWithoutProductInput>
    create: XOR<ProductColorCreateWithoutProductInput, ProductColorUncheckedCreateWithoutProductInput>
    where?: ProductColorWhereInput
  }

  export type ProductColorUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductColorWhereInput
    data: XOR<ProductColorUpdateWithoutProductInput, ProductColorUncheckedUpdateWithoutProductInput>
  }

  export type ProductColorUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductColorUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpsertWithoutProductInput = {
    update: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSizeUpsertWithoutProductInput = {
    update: XOR<ProductSizeUpdateWithoutProductInput, ProductSizeUncheckedUpdateWithoutProductInput>
    create: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput>
    where?: ProductSizeWhereInput
  }

  export type ProductSizeUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductSizeWhereInput
    data: XOR<ProductSizeUpdateWithoutProductInput, ProductSizeUncheckedUpdateWithoutProductInput>
  }

  export type ProductSizeUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSizeUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCustomCategoryUpsertWithoutProductInput = {
    update: XOR<ProductCustomCategoryUpdateWithoutProductInput, ProductCustomCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCustomCategoryCreateWithoutProductInput, ProductCustomCategoryUncheckedCreateWithoutProductInput>
    where?: ProductCustomCategoryWhereInput
  }

  export type ProductCustomCategoryUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductCustomCategoryWhereInput
    data: XOR<ProductCustomCategoryUpdateWithoutProductInput, ProductCustomCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductCustomCategoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCustomCategoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFlavorUpsertWithoutProductInput = {
    update: XOR<ProductFlavorUpdateWithoutProductInput, ProductFlavorUncheckedUpdateWithoutProductInput>
    create: XOR<ProductFlavorCreateWithoutProductInput, ProductFlavorUncheckedCreateWithoutProductInput>
    where?: ProductFlavorWhereInput
  }

  export type ProductFlavorUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductFlavorWhereInput
    data: XOR<ProductFlavorUpdateWithoutProductInput, ProductFlavorUncheckedUpdateWithoutProductInput>
  }

  export type ProductFlavorUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductFlavorUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPowerUpsertWithoutProductInput = {
    update: XOR<ProductPowerUpdateWithoutProductInput, ProductPowerUncheckedUpdateWithoutProductInput>
    create: XOR<ProductPowerCreateWithoutProductInput, ProductPowerUncheckedCreateWithoutProductInput>
    where?: ProductPowerWhereInput
  }

  export type ProductPowerUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductPowerWhereInput
    data: XOR<ProductPowerUpdateWithoutProductInput, ProductPowerUncheckedUpdateWithoutProductInput>
  }

  export type ProductPowerUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductPowerUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVoltageUpsertWithoutProductInput = {
    update: XOR<ProductVoltageUpdateWithoutProductInput, ProductVoltageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVoltageCreateWithoutProductInput, ProductVoltageUncheckedCreateWithoutProductInput>
    where?: ProductVoltageWhereInput
  }

  export type ProductVoltageUpdateToOneWithWhereWithoutProductInput = {
    where?: ProductVoltageWhereInput
    data: XOR<ProductVoltageUpdateWithoutProductInput, ProductVoltageUncheckedUpdateWithoutProductInput>
  }

  export type ProductVoltageUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVoltageUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_name?: StringFieldUpdateOperationsInput | string
    attribute_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateManyOwnerInput = {
    id?: string
    zip_code?: string | null
    active?: boolean
    business_name: string
    address_one?: string | null
    address_two?: string | null
    fantasy_name: string
    email: string
    phone_number: string
    website?: string | null
    registration_number: string
    slug: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MemberCreateManyUserInput = {
    role: $Enums.Role
    organization_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OrganizationUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUpdateManyWithoutOrganizationNestedInput
    customer?: CustomerUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: MemberUncheckedUpdateManyWithoutOrganizationNestedInput
    customer?: CustomerUncheckedUpdateManyWithoutOrganizationNestedInput
    invite_code?: InviteCodeUncheckedUpdateManyWithoutOrganizationNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    zip_code?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    business_name?: StringFieldUpdateOperationsInput | string
    address_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_two?: NullableStringFieldUpdateOperationsInput | string | null
    fantasy_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    registration_number?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organization_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    organization_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberCreateManyOrganizationInput = {
    user_id: string
    role: $Enums.Role
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CustomerCreateManyOrganizationInput = {
    id?: string
    name?: string | null
    second_name?: string | null
    whatsapp?: string | null
    shop_name: string
    address_line_one?: string | null
    address_line_two?: string | null
    email: string
    second_phone?: string | null
    vat_rate_id: string
    currency_id: string
    agent_id: string
    active?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InviteCodeCreateManyOrganizationInput = {
    id?: string
    code: string
    expires_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    used?: boolean
  }

  export type MemberUpdateWithoutOrganizationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type MemberUncheckedUpdateWithoutOrganizationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyWithoutOrganizationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    second_name?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: StringFieldUpdateOperationsInput | string
    address_line_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_line_two?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    second_phone?: NullableStringFieldUpdateOperationsInput | string | null
    vat_rate_id?: StringFieldUpdateOperationsInput | string
    currency_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    second_name?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: StringFieldUpdateOperationsInput | string
    address_line_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_line_two?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    second_phone?: NullableStringFieldUpdateOperationsInput | string | null
    vat_rate_id?: StringFieldUpdateOperationsInput | string
    currency_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    second_name?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    shop_name?: StringFieldUpdateOperationsInput | string
    address_line_one?: NullableStringFieldUpdateOperationsInput | string | null
    address_line_two?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    second_phone?: NullableStringFieldUpdateOperationsInput | string | null
    vat_rate_id?: StringFieldUpdateOperationsInput | string
    currency_id?: StringFieldUpdateOperationsInput | string
    agent_id?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteCodeUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InviteCodeUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InviteCodeUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OperationMessageTranslationCreateManyOperation_messageInput = {
    language_code: string
    message: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type OperationMessageTranslationUpdateWithoutOperation_messageInput = {
    language_code?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationMessageTranslationUncheckedUpdateWithoutOperation_messageInput = {
    language_code?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperationMessageTranslationUncheckedUpdateManyWithoutOperation_messageInput = {
    language_code?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProduct_categoryInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateWithoutProduct_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUpdateManyWithoutProductNestedInput
    product_color?: ProductColorUpdateOneWithoutProductNestedInput
    product_size?: ProductSizeUpdateOneWithoutProductNestedInput
    product_custom_category?: ProductCustomCategoryUpdateOneWithoutProductNestedInput
    product_flavor?: ProductFlavorUpdateOneWithoutProductNestedInput
    product_power?: ProductPowerUpdateOneWithoutProductNestedInput
    produt_voltage?: ProductVoltageUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProduct_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProduct_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProduct_colorInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateWithoutProduct_colorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUpdateManyWithoutProductNestedInput
    product_category?: ProductCategoryUpdateOneRequiredWithoutProductNestedInput
    product_size?: ProductSizeUpdateOneWithoutProductNestedInput
    product_custom_category?: ProductCustomCategoryUpdateOneWithoutProductNestedInput
    product_flavor?: ProductFlavorUpdateOneWithoutProductNestedInput
    product_power?: ProductPowerUpdateOneWithoutProductNestedInput
    produt_voltage?: ProductVoltageUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProduct_colorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProduct_colorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProduct_sizeInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateWithoutProduct_sizeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUpdateManyWithoutProductNestedInput
    product_color?: ProductColorUpdateOneWithoutProductNestedInput
    product_category?: ProductCategoryUpdateOneRequiredWithoutProductNestedInput
    product_custom_category?: ProductCustomCategoryUpdateOneWithoutProductNestedInput
    product_flavor?: ProductFlavorUpdateOneWithoutProductNestedInput
    product_power?: ProductPowerUpdateOneWithoutProductNestedInput
    produt_voltage?: ProductVoltageUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProduct_sizeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProduct_sizeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProdut_voltageInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateWithoutProdut_voltageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUpdateManyWithoutProductNestedInput
    product_color?: ProductColorUpdateOneWithoutProductNestedInput
    product_category?: ProductCategoryUpdateOneRequiredWithoutProductNestedInput
    product_size?: ProductSizeUpdateOneWithoutProductNestedInput
    product_custom_category?: ProductCustomCategoryUpdateOneWithoutProductNestedInput
    product_flavor?: ProductFlavorUpdateOneWithoutProductNestedInput
    product_power?: ProductPowerUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProdut_voltageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProdut_voltageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProduct_flavorInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateWithoutProduct_flavorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUpdateManyWithoutProductNestedInput
    product_color?: ProductColorUpdateOneWithoutProductNestedInput
    product_category?: ProductCategoryUpdateOneRequiredWithoutProductNestedInput
    product_size?: ProductSizeUpdateOneWithoutProductNestedInput
    product_custom_category?: ProductCustomCategoryUpdateOneWithoutProductNestedInput
    product_power?: ProductPowerUpdateOneWithoutProductNestedInput
    produt_voltage?: ProductVoltageUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProduct_flavorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProduct_flavorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProduct_powerInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    custom_category_id?: string | null
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateWithoutProduct_powerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUpdateManyWithoutProductNestedInput
    product_color?: ProductColorUpdateOneWithoutProductNestedInput
    product_category?: ProductCategoryUpdateOneRequiredWithoutProductNestedInput
    product_size?: ProductSizeUpdateOneWithoutProductNestedInput
    product_custom_category?: ProductCustomCategoryUpdateOneWithoutProductNestedInput
    product_flavor?: ProductFlavorUpdateOneWithoutProductNestedInput
    produt_voltage?: ProductVoltageUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProduct_powerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProduct_powerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    custom_category_id?: NullableStringFieldUpdateOperationsInput | string | null
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyProduct_custom_categoryInput = {
    id?: string
    sku: string
    active?: boolean | null
    brand?: string | null
    category_id: string
    color_id?: string | null
    cross_docking_days?: number | null
    description: string
    gender?: string | null
    height: number
    length: number
    images?: ProductCreateimagesInput | string[]
    ean?: string | null
    cost_price?: number | null
    manufacturer_part_number?: number | null
    model?: string | null
    name: string
    origin?: string | null
    ncm?: string | null
    price: number
    product_name?: string | null
    size_id?: string | null
    stock: number
    warranty?: number | null
    weight: number
    width: number
    flavor_id?: string | null
    measurement_unit?: string | null
    unit_multiplier?: number | null
    meta_fields?: ProductCreatemeta_fieldsInput | InputJsonValue[]
    power_id?: string | null
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    voltage_id?: string | null
    videos?: ProductCreatevideosInput | string[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductUpdateWithoutProduct_custom_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUpdateManyWithoutProductNestedInput
    product_color?: ProductColorUpdateOneWithoutProductNestedInput
    product_category?: ProductCategoryUpdateOneRequiredWithoutProductNestedInput
    product_size?: ProductSizeUpdateOneWithoutProductNestedInput
    product_flavor?: ProductFlavorUpdateOneWithoutProductNestedInput
    product_power?: ProductPowerUpdateOneWithoutProductNestedInput
    produt_voltage?: ProductVoltageUpdateOneWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProduct_custom_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_channels?: SaleChannelUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProduct_custom_categoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: StringFieldUpdateOperationsInput | string
    color_id?: NullableStringFieldUpdateOperationsInput | string | null
    cross_docking_days?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    height?: IntFieldUpdateOperationsInput | number
    length?: IntFieldUpdateOperationsInput | number
    images?: ProductUpdateimagesInput | string[]
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    cost_price?: NullableIntFieldUpdateOperationsInput | number | null
    manufacturer_part_number?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    ncm?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    size_id?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    warranty?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    flavor_id?: NullableStringFieldUpdateOperationsInput | string | null
    measurement_unit?: NullableStringFieldUpdateOperationsInput | string | null
    unit_multiplier?: NullableIntFieldUpdateOperationsInput | number | null
    meta_fields?: ProductUpdatemeta_fieldsInput | InputJsonValue[]
    power_id?: NullableStringFieldUpdateOperationsInput | string | null
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voltage_id?: NullableStringFieldUpdateOperationsInput | string | null
    videos?: ProductUpdatevideosInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleChannelCreateManyProductInput = {
    id?: string
    sale_channel: string
    code: number
    channel_type: string
    sale_price?: number | null
    sale_date_start?: Date | string | null
    sale_date_end?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SaleChannelUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sale_channel?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    channel_type?: StringFieldUpdateOperationsInput | string
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleChannelUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sale_channel?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    channel_type?: StringFieldUpdateOperationsInput | string
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleChannelUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sale_channel?: StringFieldUpdateOperationsInput | string
    code?: IntFieldUpdateOperationsInput | number
    channel_type?: StringFieldUpdateOperationsInput | string
    sale_price?: NullableFloatFieldUpdateOperationsInput | number | null
    sale_date_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_date_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationMessageCountOutputTypeDefaultArgs instead
     */
    export type OperationMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCategoryCountOutputTypeDefaultArgs instead
     */
    export type ProductCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductColorCountOutputTypeDefaultArgs instead
     */
    export type ProductColorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductColorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductSizeCountOutputTypeDefaultArgs instead
     */
    export type ProductSizeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductVoltageCountOutputTypeDefaultArgs instead
     */
    export type ProductVoltageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductVoltageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductFlavorCountOutputTypeDefaultArgs instead
     */
    export type ProductFlavorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductFlavorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductPowerCountOutputTypeDefaultArgs instead
     */
    export type ProductPowerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductPowerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCustomCategoryCountOutputTypeDefaultArgs instead
     */
    export type ProductCustomCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCustomCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MemberDefaultArgs instead
     */
    export type MemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationMessageDefaultArgs instead
     */
    export type OperationMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OperationMessageTranslationDefaultArgs instead
     */
    export type OperationMessageTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OperationMessageTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InviteCodeDefaultArgs instead
     */
    export type InviteCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InviteCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCategoryDefaultArgs instead
     */
    export type ProductCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductColorDefaultArgs instead
     */
    export type ProductColorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductColorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductSizeDefaultArgs instead
     */
    export type ProductSizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductSizeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductVoltageDefaultArgs instead
     */
    export type ProductVoltageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductVoltageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductFlavorDefaultArgs instead
     */
    export type ProductFlavorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductFlavorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductPowerDefaultArgs instead
     */
    export type ProductPowerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductPowerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleChannelDefaultArgs instead
     */
    export type SaleChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SaleChannelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCustomCategoryDefaultArgs instead
     */
    export type ProductCustomCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCustomCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}